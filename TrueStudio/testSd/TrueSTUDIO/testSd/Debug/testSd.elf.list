
testSd.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000198  08000000  08000000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00002214  08000198  08000198  00008198  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000024  080023ac  080023ac  0000a3ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  080023d0  080023d0  0000a3d0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  080023d4  080023d4  0000a3d4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000008  20000000  080023d8  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000340  20000008  080023e0  00010008  2**3
                  ALLOC
  7 ._user_heap_stack 00000600  20000348  080023e0  00010348  2**0
                  ALLOC
  8 .ARM.attributes 00000030  00000000  00000000  00010008  2**0
                  CONTENTS, READONLY
  9 .debug_info   0000e24d  00000000  00000000  00010038  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0000240b  00000000  00000000  0001e285  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007e5a  00000000  00000000  00020690  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 000007d8  00000000  00000000  000284f0  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000a10  00000000  00000000  00028cc8  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00004734  00000000  00000000  000296d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00002e87  00000000  00000000  0002de0c  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .comment      00000082  00000000  00000000  00030c93  2**0
                  CONTENTS, READONLY
 17 .debug_frame  000013a4  00000000  00000000  00030d18  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000198 <__do_global_dtors_aux>:
 8000198:	b510      	push	{r4, lr}
 800019a:	4c05      	ldr	r4, [pc, #20]	; (80001b0 <__do_global_dtors_aux+0x18>)
 800019c:	7823      	ldrb	r3, [r4, #0]
 800019e:	b933      	cbnz	r3, 80001ae <__do_global_dtors_aux+0x16>
 80001a0:	4b04      	ldr	r3, [pc, #16]	; (80001b4 <__do_global_dtors_aux+0x1c>)
 80001a2:	b113      	cbz	r3, 80001aa <__do_global_dtors_aux+0x12>
 80001a4:	4804      	ldr	r0, [pc, #16]	; (80001b8 <__do_global_dtors_aux+0x20>)
 80001a6:	f3af 8000 	nop.w
 80001aa:	2301      	movs	r3, #1
 80001ac:	7023      	strb	r3, [r4, #0]
 80001ae:	bd10      	pop	{r4, pc}
 80001b0:	20000008 	.word	0x20000008
 80001b4:	00000000 	.word	0x00000000
 80001b8:	08002394 	.word	0x08002394

080001bc <frame_dummy>:
 80001bc:	b508      	push	{r3, lr}
 80001be:	4b03      	ldr	r3, [pc, #12]	; (80001cc <frame_dummy+0x10>)
 80001c0:	b11b      	cbz	r3, 80001ca <frame_dummy+0xe>
 80001c2:	4803      	ldr	r0, [pc, #12]	; (80001d0 <frame_dummy+0x14>)
 80001c4:	4903      	ldr	r1, [pc, #12]	; (80001d4 <frame_dummy+0x18>)
 80001c6:	f3af 8000 	nop.w
 80001ca:	bd08      	pop	{r3, pc}
 80001cc:	00000000 	.word	0x00000000
 80001d0:	08002394 	.word	0x08002394
 80001d4:	2000000c 	.word	0x2000000c

080001d8 <SD_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : not used 
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_initialize(BYTE lun)
{
 80001d8:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
 80001da:	4c06      	ldr	r4, [pc, #24]	; (80001f4 <SD_initialize+0x1c>)
 80001dc:	2301      	movs	r3, #1
 80001de:	7023      	strb	r3, [r4, #0]
  
  /* Configure the uSD device */
  if(BSP_SD_Init() == MSD_OK)
 80001e0:	f002 f83c 	bl	800225c <BSP_SD_Init>
 80001e4:	4623      	mov	r3, r4
 80001e6:	b918      	cbnz	r0, 80001f0 <SD_initialize+0x18>
  {
    Stat &= ~STA_NOINIT;
 80001e8:	7822      	ldrb	r2, [r4, #0]
 80001ea:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
 80001ee:	7022      	strb	r2, [r4, #0]
  }

  return Stat;
 80001f0:	7818      	ldrb	r0, [r3, #0]
}
 80001f2:	bd10      	pop	{r4, pc}
 80001f4:	20000000 	.word	0x20000000

080001f8 <SD_status>:
  * @brief  Gets Disk Status
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_status(BYTE lun)
{
 80001f8:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
 80001fa:	4c06      	ldr	r4, [pc, #24]	; (8000214 <SD_status+0x1c>)
 80001fc:	2301      	movs	r3, #1
 80001fe:	7023      	strb	r3, [r4, #0]

  if(BSP_SD_GetStatus() == MSD_OK)
 8000200:	f002 f868 	bl	80022d4 <BSP_SD_GetStatus>
 8000204:	4623      	mov	r3, r4
 8000206:	b918      	cbnz	r0, 8000210 <SD_status+0x18>
  {
    Stat &= ~STA_NOINIT;
 8000208:	7822      	ldrb	r2, [r4, #0]
 800020a:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
 800020e:	7022      	strb	r2, [r4, #0]
  }
  
  return Stat;
 8000210:	7818      	ldrb	r0, [r3, #0]
}
 8000212:	bd10      	pop	{r4, pc}
 8000214:	20000000 	.word	0x20000000

08000218 <SD_read>:
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
DRESULT SD_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
 8000218:	b507      	push	{r0, r1, r2, lr}
  DRESULT res = RES_OK;
  
  if(BSP_SD_ReadBlocks((uint32_t*)buff, 
 800021a:	f44f 7000 	mov.w	r0, #512	; 0x200
 800021e:	e88d 0009 	stmia.w	sp, {r0, r3}
                       (uint64_t) (sector * BLOCK_SIZE), 
 8000222:	0252      	lsls	r2, r2, #9
  */
DRESULT SD_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
  DRESULT res = RES_OK;
  
  if(BSP_SD_ReadBlocks((uint32_t*)buff, 
 8000224:	4608      	mov	r0, r1
 8000226:	2300      	movs	r3, #0
 8000228:	f002 f834 	bl	8002294 <BSP_SD_ReadBlocks>
  {
    res = RES_ERROR;
  }
  
  return res;
}
 800022c:	3000      	adds	r0, #0
 800022e:	bf18      	it	ne
 8000230:	2001      	movne	r0, #1
 8000232:	b003      	add	sp, #12
 8000234:	f85d fb04 	ldr.w	pc, [sp], #4

08000238 <SD_write>:
  * @param  count: Number of sectors to write (1..128)
  * @retval DRESULT: Operation result
  */
#if _USE_WRITE == 1
DRESULT SD_write(BYTE lun, const BYTE *buff, DWORD sector, UINT count)
{
 8000238:	b507      	push	{r0, r1, r2, lr}
  DRESULT res = RES_OK;
  
  if(BSP_SD_WriteBlocks((uint32_t*)buff, 
 800023a:	f44f 7000 	mov.w	r0, #512	; 0x200
 800023e:	e88d 0009 	stmia.w	sp, {r0, r3}
                        (uint64_t)(sector * BLOCK_SIZE), 
 8000242:	0252      	lsls	r2, r2, #9
#if _USE_WRITE == 1
DRESULT SD_write(BYTE lun, const BYTE *buff, DWORD sector, UINT count)
{
  DRESULT res = RES_OK;
  
  if(BSP_SD_WriteBlocks((uint32_t*)buff, 
 8000244:	4608      	mov	r0, r1
 8000246:	2300      	movs	r3, #0
 8000248:	f002 f834 	bl	80022b4 <BSP_SD_WriteBlocks>
  {
    res = RES_ERROR;
  }
  
  return res;
}
 800024c:	3000      	adds	r0, #0
 800024e:	bf18      	it	ne
 8000250:	2001      	movne	r0, #1
 8000252:	b003      	add	sp, #12
 8000254:	f85d fb04 	ldr.w	pc, [sp], #4

08000258 <SD_ioctl>:
  * @param  *buff: Buffer to send/receive control data
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
 8000258:	b510      	push	{r4, lr}
  DRESULT res = RES_ERROR;
  SD_CardInfo CardInfo;
  
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 800025a:	4b12      	ldr	r3, [pc, #72]	; (80002a4 <SD_ioctl+0x4c>)
 800025c:	781b      	ldrb	r3, [r3, #0]
 800025e:	07db      	lsls	r3, r3, #31
  * @param  *buff: Buffer to send/receive control data
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
 8000260:	b096      	sub	sp, #88	; 0x58
 8000262:	4614      	mov	r4, r2
  DRESULT res = RES_ERROR;
  SD_CardInfo CardInfo;
  
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8000264:	d41b      	bmi.n	800029e <SD_ioctl+0x46>
  
  switch (cmd)
 8000266:	2903      	cmp	r1, #3
 8000268:	d817      	bhi.n	800029a <SD_ioctl+0x42>
 800026a:	e8df f001 	tbb	[pc, r1]
 800026e:	020b      	.short	0x020b
 8000270:	110d      	.short	0x110d
    res = RES_OK;
    break;
  
  /* Get number of sectors on the disk (DWORD) */
  case GET_SECTOR_COUNT :
    BSP_SD_GetCardInfo(&CardInfo);
 8000272:	4668      	mov	r0, sp
 8000274:	f002 f834 	bl	80022e0 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.CardCapacity / BLOCK_SIZE;
 8000278:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800027a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800027c:	0a50      	lsrs	r0, r2, #9
 800027e:	ea40 50c3 	orr.w	r0, r0, r3, lsl #23
 8000282:	6020      	str	r0, [r4, #0]
    res = RES_OK;
 8000284:	2000      	movs	r0, #0
 8000286:	e00b      	b.n	80002a0 <SD_ioctl+0x48>
    break;
  
  /* Get R/W sector size (WORD) */
  case GET_SECTOR_SIZE :
    *(WORD*)buff = BLOCK_SIZE;
 8000288:	f44f 7300 	mov.w	r3, #512	; 0x200
 800028c:	8013      	strh	r3, [r2, #0]
 800028e:	e7f9      	b.n	8000284 <SD_ioctl+0x2c>
    res = RES_OK;
    break;
  
  /* Get erase block size in unit of sector (DWORD) */
  case GET_BLOCK_SIZE :
    *(DWORD*)buff = BLOCK_SIZE;
 8000290:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000294:	6013      	str	r3, [r2, #0]
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  DRESULT res = RES_ERROR;
 8000296:	2001      	movs	r0, #1
 8000298:	e002      	b.n	80002a0 <SD_ioctl+0x48>
  case GET_BLOCK_SIZE :
    *(DWORD*)buff = BLOCK_SIZE;
    break;
  
  default:
    res = RES_PARERR;
 800029a:	2004      	movs	r0, #4
 800029c:	e000      	b.n	80002a0 <SD_ioctl+0x48>
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  DRESULT res = RES_ERROR;
  SD_CardInfo CardInfo;
  
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 800029e:	2003      	movs	r0, #3
  default:
    res = RES_PARERR;
  }
  
  return res;
}
 80002a0:	b016      	add	sp, #88	; 0x58
 80002a2:	bd10      	pop	{r4, pc}
 80002a4:	20000000 	.word	0x20000000

080002a8 <FATFS_LinkDriverEx>:
  * @param  lun : only used for USB Key Disk to add multi-lun management
            else the paramter must be equal to 0
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriverEx(Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
 80002a8:	b530      	push	{r4, r5, lr}
  uint8_t ret = 1;
  uint8_t DiskNum = 0;
  
  if(disk.nbr <= _VOLUMES)
 80002aa:	4b0f      	ldr	r3, [pc, #60]	; (80002e8 <FATFS_LinkDriverEx+0x40>)
 80002ac:	7a5c      	ldrb	r4, [r3, #9]
 80002ae:	2c01      	cmp	r4, #1
 80002b0:	d818      	bhi.n	80002e4 <FATFS_LinkDriverEx+0x3c>
  {
    disk.is_initialized[disk.nbr] = 0;
 80002b2:	7a5d      	ldrb	r5, [r3, #9]
 80002b4:	b2ed      	uxtb	r5, r5
 80002b6:	2400      	movs	r4, #0
 80002b8:	555c      	strb	r4, [r3, r5]
    disk.drv[disk.nbr] = drv;  
 80002ba:	7a5d      	ldrb	r5, [r3, #9]
 80002bc:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 80002c0:	6068      	str	r0, [r5, #4]
    disk.lun[disk.nbr] = lun;  
 80002c2:	7a58      	ldrb	r0, [r3, #9]
 80002c4:	4418      	add	r0, r3
 80002c6:	7202      	strb	r2, [r0, #8]
    DiskNum = disk.nbr++;
 80002c8:	7a5a      	ldrb	r2, [r3, #9]
 80002ca:	b2d2      	uxtb	r2, r2
 80002cc:	1c50      	adds	r0, r2, #1
 80002ce:	b2c0      	uxtb	r0, r0
 80002d0:	7258      	strb	r0, [r3, #9]
    path[0] = DiskNum + '0';
    path[1] = ':';
 80002d2:	233a      	movs	r3, #58	; 0x3a
  {
    disk.is_initialized[disk.nbr] = 0;
    disk.drv[disk.nbr] = drv;  
    disk.lun[disk.nbr] = lun;  
    DiskNum = disk.nbr++;
    path[0] = DiskNum + '0';
 80002d4:	3230      	adds	r2, #48	; 0x30
    path[1] = ':';
 80002d6:	704b      	strb	r3, [r1, #1]
    path[2] = '/';
 80002d8:	232f      	movs	r3, #47	; 0x2f
  {
    disk.is_initialized[disk.nbr] = 0;
    disk.drv[disk.nbr] = drv;  
    disk.lun[disk.nbr] = lun;  
    DiskNum = disk.nbr++;
    path[0] = DiskNum + '0';
 80002da:	700a      	strb	r2, [r1, #0]
    path[1] = ':';
    path[2] = '/';
 80002dc:	708b      	strb	r3, [r1, #2]
    path[3] = 0;
 80002de:	70cc      	strb	r4, [r1, #3]
    ret = 0;
 80002e0:	4620      	mov	r0, r4
 80002e2:	bd30      	pop	{r4, r5, pc}
            else the paramter must be equal to 0
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriverEx(Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
  uint8_t ret = 1;
 80002e4:	2001      	movs	r0, #1
    path[3] = 0;
    ret = 0;
  }
  
  return ret;
}
 80002e6:	bd30      	pop	{r4, r5, pc}
 80002e8:	20000024 	.word	0x20000024

080002ec <FATFS_LinkDriver>:
  * @param  path: pointer to the logical drive path 
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(Diskio_drvTypeDef *drv, char *path)
{
  return FATFS_LinkDriverEx(drv, path, 0);
 80002ec:	2200      	movs	r2, #0
 80002ee:	f7ff bfdb 	b.w	80002a8 <FATFS_LinkDriverEx>

080002f2 <get_ldnumber>:
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
 80002f2:	6803      	ldr	r3, [r0, #0]

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
 80002f4:	b510      	push	{r4, lr}
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
 80002f6:	b193      	cbz	r3, 800031e <get_ldnumber+0x2c>
 80002f8:	461a      	mov	r2, r3
 80002fa:	4614      	mov	r4, r2
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 80002fc:	f812 1b01 	ldrb.w	r1, [r2], #1
 8000300:	2920      	cmp	r1, #32
 8000302:	d90a      	bls.n	800031a <get_ldnumber+0x28>
 8000304:	293a      	cmp	r1, #58	; 0x3a
 8000306:	d1f8      	bne.n	80002fa <get_ldnumber+0x8>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
			tp = *path;
			i = *tp++ - '0'; 
 8000308:	461a      	mov	r2, r3
 800030a:	f812 1b01 	ldrb.w	r1, [r2], #1
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 800030e:	4294      	cmp	r4, r2
 8000310:	d105      	bne.n	800031e <get_ldnumber+0x2c>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 8000312:	2930      	cmp	r1, #48	; 0x30
 8000314:	d103      	bne.n	800031e <get_ldnumber+0x2c>
					vol = (int)i;
					*path = ++tt;
 8000316:	3302      	adds	r3, #2
 8000318:	6003      	str	r3, [r0, #0]
			return vol;
		}
#if _FS_RPATH && _VOLUMES >= 2
		vol = CurrVol;	/* Current drive */
#else
		vol = 0;		/* Drive 0 */
 800031a:	2000      	movs	r0, #0
 800031c:	bd10      	pop	{r4, pc}
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
	const TCHAR *tp, *tt;
	UINT i;
	int vol = -1;
 800031e:	f04f 30ff 	mov.w	r0, #4294967295
#else
		vol = 0;		/* Drive 0 */
#endif
	}
	return vol;
}
 8000322:	bd10      	pop	{r4, pc}

08000324 <sync_window.part.2>:
/*-----------------------------------------------------------------------*/
/* Move/Flush disk access window in the file system object               */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT sync_window (
 8000324:	b570      	push	{r4, r5, r6, lr}
	UINT nf;
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
 8000326:	f8d0 522c 	ldr.w	r5, [r0, #556]	; 0x22c
/*-----------------------------------------------------------------------*/
/* Move/Flush disk access window in the file system object               */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT sync_window (
 800032a:	4604      	mov	r4, r0
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win.d8, wsect, 1) != RES_OK) {
 800032c:	4621      	mov	r1, r4
 800032e:	f890 0201 	ldrb.w	r0, [r0, #513]	; 0x201
 8000332:	462a      	mov	r2, r5
 8000334:	2301      	movs	r3, #1
 8000336:	f000 fa85 	bl	8000844 <disk_write>
 800033a:	b9d0      	cbnz	r0, 8000372 <sync_window.part.2+0x4e>
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800033c:	f8d4 3220 	ldr.w	r3, [r4, #544]	; 0x220
	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win.d8, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
 8000340:	f884 0204 	strb.w	r0, [r4, #516]	; 0x204
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8000344:	1aea      	subs	r2, r5, r3
 8000346:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
 800034a:	429a      	cmp	r2, r3
 800034c:	d301      	bcc.n	8000352 <sync_window.part.2+0x2e>
	FATFS* fs		/* File system object */
)
{
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;
 800034e:	2000      	movs	r0, #0
 8000350:	bd70      	pop	{r4, r5, r6, pc}
		if (disk_write(fs->drv, fs->win.d8, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8000352:	f894 6203 	ldrb.w	r6, [r4, #515]	; 0x203
 8000356:	2e01      	cmp	r6, #1
 8000358:	d9f9      	bls.n	800034e <sync_window.part.2+0x2a>
					wsect += fs->fsize;
 800035a:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
					disk_write(fs->drv, fs->win.d8, wsect, 1);
 800035e:	f894 0201 	ldrb.w	r0, [r4, #513]	; 0x201
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
					wsect += fs->fsize;
 8000362:	441d      	add	r5, r3
					disk_write(fs->drv, fs->win.d8, wsect, 1);
 8000364:	4621      	mov	r1, r4
 8000366:	462a      	mov	r2, r5
 8000368:	2301      	movs	r3, #1
 800036a:	f000 fa6b 	bl	8000844 <disk_write>
		if (disk_write(fs->drv, fs->win.d8, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800036e:	3e01      	subs	r6, #1
 8000370:	e7f1      	b.n	8000356 <sync_window.part.2+0x32>


	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win.d8, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
 8000372:	2001      	movs	r0, #1
				}
			}
		}
	}
	return res;
}
 8000374:	bd70      	pop	{r4, r5, r6, pc}

08000376 <sync_window>:
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8000376:	f890 3204 	ldrb.w	r3, [r0, #516]	; 0x204
 800037a:	b10b      	cbz	r3, 8000380 <sync_window+0xa>
 800037c:	f7ff bfd2 	b.w	8000324 <sync_window.part.2>
				}
			}
		}
	}
	return res;
}
 8000380:	4618      	mov	r0, r3
 8000382:	4770      	bx	lr

08000384 <move_window>:
)
{
	FRESULT res = FR_OK;


	if (sector != fs->winsect) {	/* Window offset changed? */
 8000384:	f8d0 322c 	ldr.w	r3, [r0, #556]	; 0x22c
 8000388:	4299      	cmp	r1, r3
static
FRESULT move_window (
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[].d8 */
)
{
 800038a:	b570      	push	{r4, r5, r6, lr}
 800038c:	4606      	mov	r6, r0
 800038e:	460d      	mov	r5, r1
	FRESULT res = FR_OK;


	if (sector != fs->winsect) {	/* Window offset changed? */
 8000390:	d013      	beq.n	80003ba <move_window+0x36>
#if !_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
 8000392:	f7ff fff0 	bl	8000376 <sync_window>
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
 8000396:	4604      	mov	r4, r0
 8000398:	b980      	cbnz	r0, 80003bc <move_window+0x38>
			if (disk_read(fs->drv, fs->win.d8, sector, 1) != RES_OK) {
 800039a:	462a      	mov	r2, r5
 800039c:	f896 0201 	ldrb.w	r0, [r6, #513]	; 0x201
 80003a0:	4631      	mov	r1, r6
 80003a2:	2301      	movs	r3, #1
 80003a4:	f000 fa42 	bl	800082c <disk_read>
 80003a8:	2800      	cmp	r0, #0
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
				res = FR_DISK_ERR;
 80003aa:	bf18      	it	ne
 80003ac:	f04f 35ff 	movne.w	r5, #4294967295
 80003b0:	bf18      	it	ne
 80003b2:	2401      	movne	r4, #1
			}
			fs->winsect = sector;
 80003b4:	f8c6 522c 	str.w	r5, [r6, #556]	; 0x22c
 80003b8:	e000      	b.n	80003bc <move_window+0x38>
FRESULT move_window (
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[].d8 */
)
{
	FRESULT res = FR_OK;
 80003ba:	2400      	movs	r4, #0
			}
			fs->winsect = sector;
		}
	}
	return res;
}
 80003bc:	4620      	mov	r0, r4
 80003be:	bd70      	pop	{r4, r5, r6, pc}

080003c0 <check_fs>:
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
 80003c0:	2300      	movs	r3, #0
static
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 80003c2:	b510      	push	{r4, lr}
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
 80003c4:	f880 3204 	strb.w	r3, [r0, #516]	; 0x204
 80003c8:	f04f 33ff 	mov.w	r3, #4294967295
 80003cc:	f8c0 322c 	str.w	r3, [r0, #556]	; 0x22c
static
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 80003d0:	4604      	mov	r4, r0
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
 80003d2:	f7ff ffd7 	bl	8000384 <move_window>
 80003d6:	bb80      	cbnz	r0, 800043a <check_fs+0x7a>
		return 3;

	if (LD_WORD(&fs->win.d8[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
 80003d8:	f894 31fe 	ldrb.w	r3, [r4, #510]	; 0x1fe
 80003dc:	f894 21ff 	ldrb.w	r2, [r4, #511]	; 0x1ff
 80003e0:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 80003e4:	4b17      	ldr	r3, [pc, #92]	; (8000444 <check_fs+0x84>)
 80003e6:	b212      	sxth	r2, r2
 80003e8:	429a      	cmp	r2, r3
 80003ea:	d128      	bne.n	800043e <check_fs+0x7e>
		return 2;

	if ((LD_DWORD(&fs->win.d8[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
 80003ec:	f894 2038 	ldrb.w	r2, [r4, #56]	; 0x38
 80003f0:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
 80003f4:	0412      	lsls	r2, r2, #16
 80003f6:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 80003fa:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
 80003fe:	431a      	orrs	r2, r3
 8000400:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
 8000404:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 8000408:	4b0f      	ldr	r3, [pc, #60]	; (8000448 <check_fs+0x88>)
 800040a:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 800040e:	429a      	cmp	r2, r3
 8000410:	d016      	beq.n	8000440 <check_fs+0x80>
		return 0;
	if ((LD_DWORD(&fs->win.d8[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 8000412:	f894 0054 	ldrb.w	r0, [r4, #84]	; 0x54
 8000416:	f894 2055 	ldrb.w	r2, [r4, #85]	; 0x55
 800041a:	0400      	lsls	r0, r0, #16
 800041c:	ea40 6002 	orr.w	r0, r0, r2, lsl #24
 8000420:	f894 2052 	ldrb.w	r2, [r4, #82]	; 0x52
 8000424:	4310      	orrs	r0, r2
 8000426:	f894 2053 	ldrb.w	r2, [r4, #83]	; 0x53
 800042a:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
 800042e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		return 0;
 8000432:	1ac0      	subs	r0, r0, r3
 8000434:	bf18      	it	ne
 8000436:	2001      	movne	r0, #1
 8000438:	bd10      	pop	{r4, pc}
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
		return 3;
 800043a:	2003      	movs	r0, #3
 800043c:	bd10      	pop	{r4, pc}

	if (LD_WORD(&fs->win.d8[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
 800043e:	2002      	movs	r0, #2
		return 0;
	if ((LD_DWORD(&fs->win.d8[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;

	return 1;
}
 8000440:	bd10      	pop	{r4, pc}
 8000442:	bf00      	nop
 8000444:	ffffaa55 	.word	0xffffaa55
 8000448:	00544146 	.word	0x00544146

0800044c <find_volume>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
 800044c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	FATFS *fs;
	UINT i;


	/* Get logical drive number from the path name */
	*rfs = 0;
 8000450:	2300      	movs	r3, #0
 8000452:	6003      	str	r3, [r0, #0]
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
 8000454:	4606      	mov	r6, r0
	UINT i;


	/* Get logical drive number from the path name */
	*rfs = 0;
	vol = get_ldnumber(path);
 8000456:	4608      	mov	r0, r1
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
 8000458:	4615      	mov	r5, r2
	UINT i;


	/* Get logical drive number from the path name */
	*rfs = 0;
	vol = get_ldnumber(path);
 800045a:	f7ff ff4a 	bl	80002f2 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 800045e:	1e07      	subs	r7, r0, #0
 8000460:	f2c0 8172 	blt.w	8000748 <find_volume+0x2fc>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
 8000464:	4bbf      	ldr	r3, [pc, #764]	; (8000764 <find_volume+0x318>)
 8000466:	f853 4027 	ldr.w	r4, [r3, r7, lsl #2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 800046a:	2c00      	cmp	r4, #0
 800046c:	f000 816e 	beq.w	800074c <find_volume+0x300>

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
 8000470:	6034      	str	r4, [r6, #0]

	if (fs->fs_type) {					/* If the volume has been mounted */
 8000472:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
 8000476:	b173      	cbz	r3, 8000496 <find_volume+0x4a>
		stat = disk_status(fs->drv);
 8000478:	f894 0201 	ldrb.w	r0, [r4, #513]	; 0x201
 800047c:	f000 f9b8 	bl	80007f0 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 8000480:	07c6      	lsls	r6, r0, #31
 8000482:	d408      	bmi.n	8000496 <find_volume+0x4a>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
 8000484:	2d00      	cmp	r5, #0
 8000486:	f000 8163 	beq.w	8000750 <find_volume+0x304>
				return FR_WRITE_PROTECTED;
 800048a:	f010 0f04 	tst.w	r0, #4
 800048e:	bf0c      	ite	eq
 8000490:	2000      	moveq	r0, #0
 8000492:	200a      	movne	r0, #10
 8000494:	e163      	b.n	800075e <find_volume+0x312>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
 8000496:	2300      	movs	r3, #0
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8000498:	b2f8      	uxtb	r0, r7
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
 800049a:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 800049e:	f884 0201 	strb.w	r0, [r4, #513]	; 0x201
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 80004a2:	f000 f9b1 	bl	8000808 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
 80004a6:	07c1      	lsls	r1, r0, #31
 80004a8:	f100 8154 	bmi.w	8000754 <find_volume+0x308>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 80004ac:	b115      	cbz	r5, 80004b4 <find_volume+0x68>
 80004ae:	0742      	lsls	r2, r0, #29
 80004b0:	f100 8152 	bmi.w	8000758 <find_volume+0x30c>
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
 80004b4:	4620      	mov	r0, r4
 80004b6:	2100      	movs	r1, #0
 80004b8:	f7ff ff82 	bl	80003c0 <check_fs>
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
 80004bc:	2801      	cmp	r0, #1
 80004be:	d124      	bne.n	800050a <find_volume+0xbe>
 80004c0:	f504 73e1 	add.w	r3, r4, #450	; 0x1c2
 80004c4:	2200      	movs	r2, #0
		for (i = 0; i < 4; i++) {			/* Get partition offset */
			pt = fs->win.d8 + MBR_Table + i * SZ_PTE;
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
 80004c6:	7819      	ldrb	r1, [r3, #0]
 80004c8:	b149      	cbz	r1, 80004de <find_volume+0x92>
 80004ca:	7999      	ldrb	r1, [r3, #6]
 80004cc:	79d8      	ldrb	r0, [r3, #7]
 80004ce:	0409      	lsls	r1, r1, #16
 80004d0:	ea41 6100 	orr.w	r1, r1, r0, lsl #24
 80004d4:	7918      	ldrb	r0, [r3, #4]
 80004d6:	4301      	orrs	r1, r0
 80004d8:	7958      	ldrb	r0, [r3, #5]
 80004da:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 80004de:	f84d 1002 	str.w	r1, [sp, r2]
 80004e2:	3204      	adds	r2, #4
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
 80004e4:	2a10      	cmp	r2, #16
 80004e6:	f103 0310 	add.w	r3, r3, #16
 80004ea:	d1ec      	bne.n	80004c6 <find_volume+0x7a>
 80004ec:	2600      	movs	r6, #0
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
 80004ee:	f85d 5006 	ldr.w	r5, [sp, r6]
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
 80004f2:	b12d      	cbz	r5, 8000500 <find_volume+0xb4>
 80004f4:	4620      	mov	r0, r4
 80004f6:	4629      	mov	r1, r5
 80004f8:	f7ff ff62 	bl	80003c0 <check_fs>
		} while (!LD2PT(vol) && fmt && ++i < 4);
 80004fc:	b908      	cbnz	r0, 8000502 <find_volume+0xb6>
 80004fe:	e00b      	b.n	8000518 <find_volume+0xcc>
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
 8000500:	2002      	movs	r0, #2
 8000502:	3604      	adds	r6, #4
		} while (!LD2PT(vol) && fmt && ++i < 4);
 8000504:	2e10      	cmp	r6, #16
 8000506:	d1f2      	bne.n	80004ee <find_volume+0xa2>
 8000508:	e000      	b.n	800050c <find_volume+0xc0>
#if _MAX_SS != _MIN_SS						/* Get sector size (multiple sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
 800050a:	2500      	movs	r5, #0
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
		} while (!LD2PT(vol) && fmt && ++i < 4);
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 800050c:	2803      	cmp	r0, #3
 800050e:	f000 8125 	beq.w	800075c <find_volume+0x310>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 8000512:	b108      	cbz	r0, 8000518 <find_volume+0xcc>
 8000514:	200d      	movs	r0, #13
 8000516:	e122      	b.n	800075e <find_volume+0x312>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win.d8 + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8000518:	7b22      	ldrb	r2, [r4, #12]
 800051a:	7ae3      	ldrb	r3, [r4, #11]
 800051c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8000520:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8000524:	d1f6      	bne.n	8000514 <find_volume+0xc8>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win.d8 + BPB_FATSz16);			/* Number of sectors per FAT */
 8000526:	7de0      	ldrb	r0, [r4, #23]
 8000528:	7da3      	ldrb	r3, [r4, #22]
	if (!fasize) fasize = LD_DWORD(fs->win.d8 + BPB_FATSz32);
 800052a:	ea53 2000 	orrs.w	r0, r3, r0, lsl #8
 800052e:	d10d      	bne.n	800054c <find_volume+0x100>
 8000530:	f894 0026 	ldrb.w	r0, [r4, #38]	; 0x26
 8000534:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
 8000538:	0400      	lsls	r0, r0, #16
 800053a:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
 800053e:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 8000542:	4318      	orrs	r0, r3
 8000544:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
 8000548:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
	fs->fsize = fasize;

	fs->n_fats = fs->win.d8[BPB_NumFATs];					/* Number of FAT copies */
 800054c:	7c26      	ldrb	r6, [r4, #16]
	if (LD_WORD(fs->win.d8 + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win.d8 + BPB_FATSz16);			/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win.d8 + BPB_FATSz32);
	fs->fsize = fasize;
 800054e:	f8c4 0218 	str.w	r0, [r4, #536]	; 0x218

	fs->n_fats = fs->win.d8[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
 8000552:	1e73      	subs	r3, r6, #1
 8000554:	2b01      	cmp	r3, #1

	fasize = LD_WORD(fs->win.d8 + BPB_FATSz16);			/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win.d8 + BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = fs->win.d8[BPB_NumFATs];					/* Number of FAT copies */
 8000556:	f884 6203 	strb.w	r6, [r4, #515]	; 0x203
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
 800055a:	d8db      	bhi.n	8000514 <find_volume+0xc8>
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */

	fs->csize = fs->win.d8[BPB_SecPerClus];				/* Number of sectors per cluster */
 800055c:	7b61      	ldrb	r1, [r4, #13]
 800055e:	f884 1202 	strb.w	r1, [r4, #514]	; 0x202
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
 8000562:	2900      	cmp	r1, #0
 8000564:	d0d6      	beq.n	8000514 <find_volume+0xc8>
 8000566:	1e4b      	subs	r3, r1, #1
 8000568:	420b      	tst	r3, r1
 800056a:	d1d3      	bne.n	8000514 <find_volume+0xc8>
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win.d8 + BPB_RootEntCnt);	/* Number of root directory entries */
 800056c:	7c63      	ldrb	r3, [r4, #17]
 800056e:	7ca2      	ldrb	r2, [r4, #18]
 8000570:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
 8000574:	0713      	lsls	r3, r2, #28

	fs->csize = fs->win.d8[BPB_SecPerClus];				/* Number of sectors per cluster */
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win.d8 + BPB_RootEntCnt);	/* Number of root directory entries */
 8000576:	f8a4 2208 	strh.w	r2, [r4, #520]	; 0x208
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
 800057a:	d1cb      	bne.n	8000514 <find_volume+0xc8>
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win.d8 + BPB_TotSec16);			/* Number of sectors on the volume */
 800057c:	7d27      	ldrb	r7, [r4, #20]
 800057e:	7ce3      	ldrb	r3, [r4, #19]
	if (!tsect) tsect = LD_DWORD(fs->win.d8 + BPB_TotSec32);
 8000580:	ea53 2307 	orrs.w	r3, r3, r7, lsl #8
 8000584:	d10d      	bne.n	80005a2 <find_volume+0x156>
 8000586:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 800058a:	f894 7023 	ldrb.w	r7, [r4, #35]	; 0x23
 800058e:	041b      	lsls	r3, r3, #16
 8000590:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
 8000594:	f894 7020 	ldrb.w	r7, [r4, #32]
 8000598:	433b      	orrs	r3, r7
 800059a:	f894 7021 	ldrb.w	r7, [r4, #33]	; 0x21
 800059e:	ea43 2307 	orr.w	r3, r3, r7, lsl #8

	nrsv = LD_WORD(fs->win.d8 + BPB_RsvdSecCnt);			/* Number of reserved sectors */
 80005a2:	f894 800f 	ldrb.w	r8, [r4, #15]
 80005a6:	7ba7      	ldrb	r7, [r4, #14]
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
 80005a8:	ea57 2808 	orrs.w	r8, r7, r8, lsl #8
 80005ac:	d0b2      	beq.n	8000514 <find_volume+0xc8>
	fs->fsize = fasize;

	fs->n_fats = fs->win.d8[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
 80005ae:	fb06 fc00 	mul.w	ip, r6, r0

	nrsv = LD_WORD(fs->win.d8 + BPB_RsvdSecCnt);			/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
 80005b2:	eb08 1712 	add.w	r7, r8, r2, lsr #4
 80005b6:	4467      	add	r7, ip
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 80005b8:	42bb      	cmp	r3, r7
 80005ba:	d3ab      	bcc.n	8000514 <find_volume+0xc8>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 80005bc:	1bdb      	subs	r3, r3, r7
 80005be:	fbb3 f3f1 	udiv	r3, r3, r1
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 80005c2:	2b00      	cmp	r3, #0
 80005c4:	d0a6      	beq.n	8000514 <find_volume+0xc8>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 80005c6:	f640 71f5 	movw	r1, #4085	; 0xff5
 80005ca:	428b      	cmp	r3, r1
 80005cc:	d906      	bls.n	80005dc <find_volume+0x190>
 80005ce:	f64f 76f5 	movw	r6, #65525	; 0xfff5
 80005d2:	42b3      	cmp	r3, r6
 80005d4:	bf8c      	ite	hi
 80005d6:	2603      	movhi	r6, #3
 80005d8:	2602      	movls	r6, #2
 80005da:	e000      	b.n	80005de <find_volume+0x192>
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
 80005dc:	2601      	movs	r6, #1
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 80005de:	3302      	adds	r3, #2
	fs->volbase = bsect;								/* Volume start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 80005e0:	eb05 0108 	add.w	r1, r5, r8
	fs->database = bsect + sysect;						/* Data start sector */
 80005e4:	442f      	add	r7, r5
	if (fmt == FS_FAT32) {
 80005e6:	2e03      	cmp	r6, #3
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 80005e8:	f8c4 3214 	str.w	r3, [r4, #532]	; 0x214
	fs->volbase = bsect;								/* Volume start sector */
 80005ec:	f8c4 521c 	str.w	r5, [r4, #540]	; 0x21c
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 80005f0:	f8c4 1220 	str.w	r1, [r4, #544]	; 0x220
	fs->database = bsect + sysect;						/* Data start sector */
 80005f4:	f8c4 7228 	str.w	r7, [r4, #552]	; 0x228
	if (fmt == FS_FAT32) {
 80005f8:	d113      	bne.n	8000622 <find_volume+0x1d6>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 80005fa:	2a00      	cmp	r2, #0
 80005fc:	d18a      	bne.n	8000514 <find_volume+0xc8>
		fs->dirbase = LD_DWORD(fs->win.d8 + BPB_RootClus);	/* Root directory start cluster */
 80005fe:	f894 202e 	ldrb.w	r2, [r4, #46]	; 0x2e
 8000602:	f894 102f 	ldrb.w	r1, [r4, #47]	; 0x2f
 8000606:	0412      	lsls	r2, r2, #16
 8000608:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800060c:	f894 102c 	ldrb.w	r1, [r4, #44]	; 0x2c
 8000610:	430a      	orrs	r2, r1
 8000612:	f894 102d 	ldrb.w	r1, [r4, #45]	; 0x2d
 8000616:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800061a:	f8c4 2224 	str.w	r2, [r4, #548]	; 0x224
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
 800061e:	009b      	lsls	r3, r3, #2
 8000620:	e011      	b.n	8000646 <find_volume+0x1fa>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8000622:	2a00      	cmp	r2, #0
 8000624:	f43f af76 	beq.w	8000514 <find_volume+0xc8>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8000628:	2e02      	cmp	r6, #2
 800062a:	ea4f 0243 	mov.w	r2, r3, lsl #1
 800062e:	bf18      	it	ne
 8000630:	18d2      	addne	r2, r2, r3
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win.d8 + BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8000632:	4461      	add	r1, ip
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8000634:	bf18      	it	ne
 8000636:	f003 0301 	andne.w	r3, r3, #1
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win.d8 + BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 800063a:	f8c4 1224 	str.w	r1, [r4, #548]	; 0x224
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800063e:	bf0c      	ite	eq
 8000640:	4613      	moveq	r3, r2
 8000642:	eb03 0352 	addne.w	r3, r3, r2, lsr #1
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
 8000646:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
 800064a:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
 800064e:	f4ff af61 	bcc.w	8000514 <find_volume+0xc8>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
 8000652:	f04f 33ff 	mov.w	r3, #4294967295
 8000656:	f8c4 3210 	str.w	r3, [r4, #528]	; 0x210
 800065a:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
 800065e:	2e03      	cmp	r6, #3
#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
 8000660:	f04f 0380 	mov.w	r3, #128	; 0x80
 8000664:	f884 3205 	strb.w	r3, [r4, #517]	; 0x205
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
 8000668:	d157      	bne.n	800071a <find_volume+0x2ce>
		&& LD_WORD(fs->win.d8 + BPB_FSInfo) == 1
 800066a:	f894 2031 	ldrb.w	r2, [r4, #49]	; 0x31
 800066e:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 8000672:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8000676:	2b01      	cmp	r3, #1
 8000678:	d14f      	bne.n	800071a <find_volume+0x2ce>
		&& move_window(fs, bsect + 1) == FR_OK)
 800067a:	4620      	mov	r0, r4
 800067c:	1c69      	adds	r1, r5, #1
 800067e:	f7ff fe81 	bl	8000384 <move_window>
 8000682:	2800      	cmp	r0, #0
 8000684:	d149      	bne.n	800071a <find_volume+0x2ce>
	{
		fs->fsi_flag = 0;
		if (LD_WORD(fs->win.d8 + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 8000686:	f894 31fe 	ldrb.w	r3, [r4, #510]	; 0x1fe
 800068a:	f894 21ff 	ldrb.w	r2, [r4, #511]	; 0x1ff
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
		&& LD_WORD(fs->win.d8 + BPB_FSInfo) == 1
		&& move_window(fs, bsect + 1) == FR_OK)
	{
		fs->fsi_flag = 0;
 800068e:	f884 0205 	strb.w	r0, [r4, #517]	; 0x205
		if (LD_WORD(fs->win.d8 + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 8000692:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 8000696:	4b34      	ldr	r3, [pc, #208]	; (8000768 <find_volume+0x31c>)
 8000698:	b212      	sxth	r2, r2
 800069a:	429a      	cmp	r2, r3
 800069c:	d13d      	bne.n	800071a <find_volume+0x2ce>
			&& LD_DWORD(fs->win.d8 + FSI_LeadSig) == 0x41615252
 800069e:	78a2      	ldrb	r2, [r4, #2]
 80006a0:	78e3      	ldrb	r3, [r4, #3]
 80006a2:	0412      	lsls	r2, r2, #16
 80006a4:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 80006a8:	7823      	ldrb	r3, [r4, #0]
 80006aa:	431a      	orrs	r2, r3
 80006ac:	7863      	ldrb	r3, [r4, #1]
 80006ae:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 80006b2:	4b2e      	ldr	r3, [pc, #184]	; (800076c <find_volume+0x320>)
 80006b4:	429a      	cmp	r2, r3
 80006b6:	d130      	bne.n	800071a <find_volume+0x2ce>
			&& LD_DWORD(fs->win.d8 + FSI_StrucSig) == 0x61417272)
 80006b8:	f894 21e6 	ldrb.w	r2, [r4, #486]	; 0x1e6
 80006bc:	f894 31e7 	ldrb.w	r3, [r4, #487]	; 0x1e7
 80006c0:	0412      	lsls	r2, r2, #16
 80006c2:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 80006c6:	f894 31e4 	ldrb.w	r3, [r4, #484]	; 0x1e4
 80006ca:	431a      	orrs	r2, r3
 80006cc:	f894 31e5 	ldrb.w	r3, [r4, #485]	; 0x1e5
 80006d0:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 80006d4:	4b26      	ldr	r3, [pc, #152]	; (8000770 <find_volume+0x324>)
 80006d6:	429a      	cmp	r2, r3
 80006d8:	d11f      	bne.n	800071a <find_volume+0x2ce>
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win.d8 + FSI_Free_Count);
 80006da:	f894 31ea 	ldrb.w	r3, [r4, #490]	; 0x1ea
 80006de:	f894 21eb 	ldrb.w	r2, [r4, #491]	; 0x1eb
 80006e2:	041b      	lsls	r3, r3, #16
 80006e4:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80006e8:	f894 21e8 	ldrb.w	r2, [r4, #488]	; 0x1e8
 80006ec:	4313      	orrs	r3, r2
 80006ee:	f894 21e9 	ldrb.w	r2, [r4, #489]	; 0x1e9
 80006f2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80006f6:	f8c4 3210 	str.w	r3, [r4, #528]	; 0x210
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win.d8 + FSI_Nxt_Free);
 80006fa:	f894 31ee 	ldrb.w	r3, [r4, #494]	; 0x1ee
 80006fe:	f894 21ef 	ldrb.w	r2, [r4, #495]	; 0x1ef
 8000702:	041b      	lsls	r3, r3, #16
 8000704:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8000708:	f894 21ec 	ldrb.w	r2, [r4, #492]	; 0x1ec
 800070c:	4313      	orrs	r3, r2
 800070e:	f894 21ed 	ldrb.w	r2, [r4, #493]	; 0x1ed
 8000712:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8000716:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
	fs->id = ++Fsid;	/* File system mount ID */
 800071a:	4a16      	ldr	r2, [pc, #88]	; (8000774 <find_volume+0x328>)
#endif
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
 800071c:	f884 6200 	strb.w	r6, [r4, #512]	; 0x200
	fs->id = ++Fsid;	/* File system mount ID */
 8000720:	8813      	ldrh	r3, [r2, #0]
 8000722:	3301      	adds	r3, #1
 8000724:	b29b      	uxth	r3, r3
 8000726:	8013      	strh	r3, [r2, #0]
 8000728:	f8a4 3206 	strh.w	r3, [r4, #518]	; 0x206
)
{
	UINT i;

	for (i = 0; i < _FS_LOCK; i++) {
		if (Files[i].fs == fs) Files[i].fs = 0;
 800072c:	4b12      	ldr	r3, [pc, #72]	; (8000778 <find_volume+0x32c>)
 800072e:	681a      	ldr	r2, [r3, #0]
 8000730:	42a2      	cmp	r2, r4
 8000732:	bf04      	itt	eq
 8000734:	2200      	moveq	r2, #0
 8000736:	601a      	streq	r2, [r3, #0]
 8000738:	68db      	ldr	r3, [r3, #12]
 800073a:	42a3      	cmp	r3, r4
 800073c:	f04f 0000 	mov.w	r0, #0
 8000740:	d10d      	bne.n	800075e <find_volume+0x312>
 8000742:	4b0d      	ldr	r3, [pc, #52]	; (8000778 <find_volume+0x32c>)
 8000744:	60d8      	str	r0, [r3, #12]
 8000746:	e00a      	b.n	800075e <find_volume+0x312>


	/* Get logical drive number from the path name */
	*rfs = 0;
	vol = get_ldnumber(path);
	if (vol < 0) return FR_INVALID_DRIVE;
 8000748:	200b      	movs	r0, #11
 800074a:	e008      	b.n	800075e <find_volume+0x312>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 800074c:	200c      	movs	r0, #12
 800074e:	e006      	b.n	800075e <find_volume+0x312>
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
 8000750:	4628      	mov	r0, r5
 8000752:	e004      	b.n	800075e <find_volume+0x312>

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8000754:	2003      	movs	r0, #3
 8000756:	e002      	b.n	800075e <find_volume+0x312>
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
		return FR_WRITE_PROTECTED;
 8000758:	200a      	movs	r0, #10
 800075a:	e000      	b.n	800075e <find_volume+0x312>
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
		} while (!LD2PT(vol) && fmt && ++i < 4);
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 800075c:	2001      	movs	r0, #1
#if _FS_LOCK			/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
}
 800075e:	b004      	add	sp, #16
 8000760:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000764:	2000004c 	.word	0x2000004c
 8000768:	ffffaa55 	.word	0xffffaa55
 800076c:	41615252 	.word	0x41615252
 8000770:	61417272 	.word	0x61417272
 8000774:	20000030 	.word	0x20000030
 8000778:	20000034 	.word	0x20000034

0800077c <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 800077c:	b530      	push	{r4, r5, lr}
 800077e:	b085      	sub	sp, #20
 8000780:	4615      	mov	r5, r2
 8000782:	9001      	str	r0, [sp, #4]
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
 8000784:	a804      	add	r0, sp, #16
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 8000786:	9100      	str	r1, [sp, #0]
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
 8000788:	f840 1d04 	str.w	r1, [r0, #-4]!


	vol = get_ldnumber(&rp);
 800078c:	f7ff fdb1 	bl	80002f2 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 8000790:	1e01      	subs	r1, r0, #0
 8000792:	db24      	blt.n	80007de <f_mount+0x62>
	cfs = FatFs[vol];					/* Pointer to fs object */
 8000794:	4814      	ldr	r0, [pc, #80]	; (80007e8 <f_mount+0x6c>)
 8000796:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
 800079a:	4602      	mov	r2, r0

	if (cfs) {
 800079c:	b17b      	cbz	r3, 80007be <f_mount+0x42>
)
{
	UINT i;

	for (i = 0; i < _FS_LOCK; i++) {
		if (Files[i].fs == fs) Files[i].fs = 0;
 800079e:	4813      	ldr	r0, [pc, #76]	; (80007ec <f_mount+0x70>)
 80007a0:	6804      	ldr	r4, [r0, #0]
 80007a2:	429c      	cmp	r4, r3
 80007a4:	bf04      	itt	eq
 80007a6:	2400      	moveq	r4, #0
 80007a8:	6004      	streq	r4, [r0, #0]
 80007aa:	68c0      	ldr	r0, [r0, #12]
 80007ac:	4298      	cmp	r0, r3
 80007ae:	bf08      	it	eq
 80007b0:	4c0e      	ldreq	r4, [pc, #56]	; (80007ec <f_mount+0x70>)
 80007b2:	f04f 0000 	mov.w	r0, #0
 80007b6:	bf08      	it	eq
 80007b8:	60e0      	streq	r0, [r4, #12]
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 80007ba:	f883 0200 	strb.w	r0, [r3, #512]	; 0x200
	}

	if (fs) {
 80007be:	9801      	ldr	r0, [sp, #4]
 80007c0:	b110      	cbz	r0, 80007c8 <f_mount+0x4c>
		fs->fs_type = 0;				/* Clear new fs object */
 80007c2:	2300      	movs	r3, #0
 80007c4:	f880 3200 	strb.w	r3, [r0, #512]	; 0x200
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 80007c8:	f842 0021 	str.w	r0, [r2, r1, lsl #2]

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 80007cc:	b150      	cbz	r0, 80007e4 <f_mount+0x68>
 80007ce:	2d01      	cmp	r5, #1
 80007d0:	d107      	bne.n	80007e2 <f_mount+0x66>

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
 80007d2:	a801      	add	r0, sp, #4
 80007d4:	4669      	mov	r1, sp
 80007d6:	2200      	movs	r2, #0
 80007d8:	f7ff fe38 	bl	800044c <find_volume>
	LEAVE_FF(fs, res);
 80007dc:	e002      	b.n	80007e4 <f_mount+0x68>
	FRESULT res;
	const TCHAR *rp = path;


	vol = get_ldnumber(&rp);
	if (vol < 0) return FR_INVALID_DRIVE;
 80007de:	200b      	movs	r0, #11
 80007e0:	e000      	b.n	80007e4 <f_mount+0x68>
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 80007e2:	2000      	movs	r0, #0

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
	LEAVE_FF(fs, res);
}
 80007e4:	b005      	add	sp, #20
 80007e6:	bd30      	pop	{r4, r5, pc}
 80007e8:	2000004c 	.word	0x2000004c
 80007ec:	20000034 	.word	0x20000034

080007f0 <disk_status>:
  * @retval DSTATUS: Operation status
  */
DSTATUS disk_status (
	BYTE pdrv		/* Physical drive nmuber to identify the drive */
)
{
 80007f0:	b508      	push	{r3, lr}
  DSTATUS stat;
  
  stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
 80007f2:	4b04      	ldr	r3, [pc, #16]	; (8000804 <disk_status+0x14>)
 80007f4:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 80007f8:	4418      	add	r0, r3
 80007fa:	6852      	ldr	r2, [r2, #4]
 80007fc:	7a00      	ldrb	r0, [r0, #8]
 80007fe:	6852      	ldr	r2, [r2, #4]
 8000800:	4790      	blx	r2
  return stat;
}
 8000802:	bd08      	pop	{r3, pc}
 8000804:	20000024 	.word	0x20000024

08000808 <disk_initialize>:
  * @retval DSTATUS: Operation status
  */
DSTATUS disk_initialize (
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
 8000808:	b508      	push	{r3, lr}
  DSTATUS stat = RES_OK;
  
  if(disk.is_initialized[pdrv] == 0)
 800080a:	4b07      	ldr	r3, [pc, #28]	; (8000828 <disk_initialize+0x20>)
 800080c:	5c1a      	ldrb	r2, [r3, r0]
 800080e:	b94a      	cbnz	r2, 8000824 <disk_initialize+0x1c>
  { 
    disk.is_initialized[pdrv] = 1;
 8000810:	2201      	movs	r2, #1
 8000812:	541a      	strb	r2, [r3, r0]
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 8000814:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 8000818:	4418      	add	r0, r3
 800081a:	6852      	ldr	r2, [r2, #4]
 800081c:	7a00      	ldrb	r0, [r0, #8]
 800081e:	6812      	ldr	r2, [r2, #0]
 8000820:	4790      	blx	r2
 8000822:	bd08      	pop	{r3, pc}
  */
DSTATUS disk_initialize (
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
  DSTATUS stat = RES_OK;
 8000824:	2000      	movs	r0, #0
  { 
    disk.is_initialized[pdrv] = 1;
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
  }
  return stat;
}
 8000826:	bd08      	pop	{r3, pc}
 8000828:	20000024 	.word	0x20000024

0800082c <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	        /* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
 800082c:	b538      	push	{r3, r4, r5, lr}
  DRESULT res;
 
  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 800082e:	4c04      	ldr	r4, [pc, #16]	; (8000840 <disk_read+0x14>)
 8000830:	eb04 0580 	add.w	r5, r4, r0, lsl #2
 8000834:	4420      	add	r0, r4
 8000836:	686d      	ldr	r5, [r5, #4]
 8000838:	7a00      	ldrb	r0, [r0, #8]
 800083a:	68ad      	ldr	r5, [r5, #8]
 800083c:	47a8      	blx	r5
  return res;
}
 800083e:	bd38      	pop	{r3, r4, r5, pc}
 8000840:	20000024 	.word	0x20000024

08000844 <disk_write>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count        	/* Number of sectors to write */
)
{
 8000844:	b538      	push	{r3, r4, r5, lr}
  DRESULT res;
  
  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 8000846:	4c04      	ldr	r4, [pc, #16]	; (8000858 <disk_write+0x14>)
 8000848:	eb04 0580 	add.w	r5, r4, r0, lsl #2
 800084c:	4420      	add	r0, r4
 800084e:	686d      	ldr	r5, [r5, #4]
 8000850:	7a00      	ldrb	r0, [r0, #8]
 8000852:	68ed      	ldr	r5, [r5, #12]
 8000854:	47a8      	blx	r5
  return res;
}
 8000856:	bd38      	pop	{r3, r4, r5, pc}
 8000858:	20000024 	.word	0x20000024

0800085c <SDIO_Init>:
  * @param  SDIOx: Pointer to SDIO register base
  * @param  Init: SDIO initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_Init(SDIO_TypeDef *SDIOx, SDIO_InitTypeDef Init)
{
 800085c:	b084      	sub	sp, #16
 800085e:	b510      	push	{r4, lr}
 8000860:	ac03      	add	r4, sp, #12
 8000862:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  assert_param(IS_SDIO_BUS_WIDE(Init.BusWide));
  assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
  assert_param(IS_SDIO_CLKDIV(Init.ClockDiv));
  
  /* Set SDIO configuration parameters */
  tmpreg |= (Init.ClockEdge           |\
 8000866:	460a      	mov	r2, r1
 8000868:	9904      	ldr	r1, [sp, #16]
             Init.HardwareFlowControl |\
             Init.ClockDiv
             ); 
  
  /* Write to SDIO CLKCR */
  MODIFY_REG(SDIOx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 800086a:	6843      	ldr	r3, [r0, #4]
  assert_param(IS_SDIO_BUS_WIDE(Init.BusWide));
  assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
  assert_param(IS_SDIO_CLKDIV(Init.ClockDiv));
  
  /* Set SDIO configuration parameters */
  tmpreg |= (Init.ClockEdge           |\
 800086c:	4311      	orrs	r1, r2
             Init.ClockBypass         |\
 800086e:	9a05      	ldr	r2, [sp, #20]
 8000870:	4311      	orrs	r1, r2
             Init.ClockPowerSave      |\
 8000872:	9a06      	ldr	r2, [sp, #24]
 8000874:	4311      	orrs	r1, r2
             Init.BusWide             |\
 8000876:	9a07      	ldr	r2, [sp, #28]
 8000878:	4311      	orrs	r1, r2
             Init.HardwareFlowControl |\
 800087a:	9a08      	ldr	r2, [sp, #32]
  
  /* Write to SDIO CLKCR */
  MODIFY_REG(SDIOx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  

  return HAL_OK;
}
 800087c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
             Init.HardwareFlowControl |\
             Init.ClockDiv
             ); 
  
  /* Write to SDIO CLKCR */
  MODIFY_REG(SDIOx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 8000880:	f423 43fd 	bic.w	r3, r3, #32384	; 0x7e80
  /* Set SDIO configuration parameters */
  tmpreg |= (Init.ClockEdge           |\
             Init.ClockBypass         |\
             Init.ClockPowerSave      |\
             Init.BusWide             |\
             Init.HardwareFlowControl |\
 8000884:	430a      	orrs	r2, r1
             Init.ClockDiv
             ); 
  
  /* Write to SDIO CLKCR */
  MODIFY_REG(SDIOx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 8000886:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800088a:	4313      	orrs	r3, r2
 800088c:	6043      	str	r3, [r0, #4]

  return HAL_OK;
}
 800088e:	b004      	add	sp, #16
 8000890:	2000      	movs	r0, #0
 8000892:	4770      	bx	lr

08000894 <SDIO_ReadFIFO>:
  * @retval HAL status
  */
uint32_t SDIO_ReadFIFO(SDIO_TypeDef *SDIOx)
{
  /* Read data from Rx FIFO */ 
  return (SDIOx->FIFO);
 8000894:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
}
 8000898:	4770      	bx	lr

0800089a <SDIO_WriteFIFO>:
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_WriteFIFO(SDIO_TypeDef *SDIOx, uint32_t *pWriteData)
{ 
  /* Write data to FIFO */ 
  SDIOx->FIFO = *pWriteData;
 800089a:	680b      	ldr	r3, [r1, #0]
 800089c:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80

  return HAL_OK;
}
 80008a0:	2000      	movs	r0, #0
 80008a2:	4770      	bx	lr

080008a4 <SDIO_PowerState_ON>:
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_PowerState_ON(SDIO_TypeDef *SDIOx)
{  
  /* Set power state to ON */ 
  SDIOx->POWER = SDIO_POWER_PWRCTRL;
 80008a4:	2303      	movs	r3, #3
 80008a6:	6003      	str	r3, [r0, #0]
  
  return HAL_OK; 
}
 80008a8:	2000      	movs	r0, #0
 80008aa:	4770      	bx	lr

080008ac <SDIO_GetPowerState>:
  *            - 0x02: Power UP
  *            - 0x03: Power ON 
  */
uint32_t SDIO_GetPowerState(SDIO_TypeDef *SDIOx)  
{
  return (SDIOx->POWER & SDIO_POWER_PWRCTRL);
 80008ac:	6800      	ldr	r0, [r0, #0]
}
 80008ae:	f000 0003 	and.w	r0, r0, #3
 80008b2:	4770      	bx	lr

080008b4 <SDIO_SendCommand>:
  assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct->Response));
  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->WaitForInterrupt));
  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->CPSM));

  /* Set the SDIO Argument value */
  SDIOx->ARG = SDIO_CmdInitStruct->Argument;
 80008b4:	680b      	ldr	r3, [r1, #0]

  /* Set SDIO command parameters */
  tmpreg |= (uint32_t)(SDIO_CmdInitStruct->CmdIndex         |\
 80008b6:	684a      	ldr	r2, [r1, #4]
  * @param  SDIO_CmdInitStruct: pointer to a SDIO_CmdInitTypeDef structure that contains 
  *         the configuration information for the SDIO command
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_SendCommand(SDIO_TypeDef *SDIOx, SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
{
 80008b8:	b510      	push	{r4, lr}

  /* Set the SDIO Argument value */
  SDIOx->ARG = SDIO_CmdInitStruct->Argument;

  /* Set SDIO command parameters */
  tmpreg |= (uint32_t)(SDIO_CmdInitStruct->CmdIndex         |\
 80008ba:	688c      	ldr	r4, [r1, #8]
  assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct->Response));
  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->WaitForInterrupt));
  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->CPSM));

  /* Set the SDIO Argument value */
  SDIOx->ARG = SDIO_CmdInitStruct->Argument;
 80008bc:	6083      	str	r3, [r0, #8]
                       SDIO_CmdInitStruct->Response         |\
                       SDIO_CmdInitStruct->WaitForInterrupt |\
                       SDIO_CmdInitStruct->CPSM);
  
  /* Write to SDIO CMD register */
  MODIFY_REG(SDIOx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80008be:	68c3      	ldr	r3, [r0, #12]

  /* Set the SDIO Argument value */
  SDIOx->ARG = SDIO_CmdInitStruct->Argument;

  /* Set SDIO command parameters */
  tmpreg |= (uint32_t)(SDIO_CmdInitStruct->CmdIndex         |\
 80008c0:	4314      	orrs	r4, r2
                       SDIO_CmdInitStruct->Response         |\
 80008c2:	68ca      	ldr	r2, [r1, #12]

  /* Set the SDIO Argument value */
  SDIOx->ARG = SDIO_CmdInitStruct->Argument;

  /* Set SDIO command parameters */
  tmpreg |= (uint32_t)(SDIO_CmdInitStruct->CmdIndex         |\
 80008c4:	6909      	ldr	r1, [r1, #16]
                       SDIO_CmdInitStruct->Response         |\
 80008c6:	4322      	orrs	r2, r4
                       SDIO_CmdInitStruct->WaitForInterrupt |\
                       SDIO_CmdInitStruct->CPSM);
  
  /* Write to SDIO CMD register */
  MODIFY_REG(SDIOx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80008c8:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0

  /* Set the SDIO Argument value */
  SDIOx->ARG = SDIO_CmdInitStruct->Argument;

  /* Set SDIO command parameters */
  tmpreg |= (uint32_t)(SDIO_CmdInitStruct->CmdIndex         |\
 80008cc:	430a      	orrs	r2, r1
                       SDIO_CmdInitStruct->Response         |\
                       SDIO_CmdInitStruct->WaitForInterrupt |\
                       SDIO_CmdInitStruct->CPSM);
  
  /* Write to SDIO CMD register */
  MODIFY_REG(SDIOx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80008ce:	f023 030f 	bic.w	r3, r3, #15
 80008d2:	4313      	orrs	r3, r2
 80008d4:	60c3      	str	r3, [r0, #12]
  
  return HAL_OK;  
}
 80008d6:	2000      	movs	r0, #0
 80008d8:	bd10      	pop	{r4, pc}

080008da <SDIO_GetCommandResponse>:
  * @param  SDIOx: Pointer to SDIO register base
  * @retval Command index of the last command response received
  */
uint8_t SDIO_GetCommandResponse(SDIO_TypeDef *SDIOx)
{
  return (uint8_t)(SDIOx->RESPCMD);
 80008da:	6900      	ldr	r0, [r0, #16]
}
 80008dc:	b2c0      	uxtb	r0, r0
 80008de:	4770      	bx	lr

080008e0 <SDIO_GetResponse>:
  *            @arg SDIO_RESP3: Response Register 3
  *            @arg SDIO_RESP4: Response Register 4  
  * @retval The Corresponding response register value
  */
uint32_t SDIO_GetResponse(uint32_t SDIO_RESP)
{
 80008e0:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0U;
 80008e2:	2300      	movs	r3, #0
 80008e4:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_SDIO_RESP(SDIO_RESP));

  /* Get the response */
  tmp = SDIO_RESP_ADDR + SDIO_RESP;
 80008e6:	4b03      	ldr	r3, [pc, #12]	; (80008f4 <SDIO_GetResponse+0x14>)
 80008e8:	4403      	add	r3, r0
 80008ea:	9301      	str	r3, [sp, #4]
  
  return (*(__IO uint32_t *) tmp);
 80008ec:	9b01      	ldr	r3, [sp, #4]
 80008ee:	6818      	ldr	r0, [r3, #0]
}  
 80008f0:	b002      	add	sp, #8
 80008f2:	4770      	bx	lr
 80008f4:	40012c14 	.word	0x40012c14

080008f8 <SDIO_DataConfig>:
  assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct->TransferDir));
  assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->TransferMode));
  assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->DPSM));

  /* Set the SDIO Data Timeout value */
  SDIOx->DTIMER = SDIO_DataInitStruct->DataTimeOut;
 80008f8:	680b      	ldr	r3, [r1, #0]

  /* Set the SDIO DataLength value */
  SDIOx->DLEN = SDIO_DataInitStruct->DataLength;

  /* Set the SDIO data configuration parameters */
  tmpreg |= (uint32_t)(SDIO_DataInitStruct->DataBlockSize |\
 80008fa:	68ca      	ldr	r2, [r1, #12]
  * @param  SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef structure 
  *         that contains the configuration information for the SDIO command.
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_DataConfig(SDIO_TypeDef *SDIOx, SDIO_DataInitTypeDef* SDIO_DataInitStruct)
{
 80008fc:	b510      	push	{r4, lr}
  assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct->TransferDir));
  assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->TransferMode));
  assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->DPSM));

  /* Set the SDIO Data Timeout value */
  SDIOx->DTIMER = SDIO_DataInitStruct->DataTimeOut;
 80008fe:	6243      	str	r3, [r0, #36]	; 0x24

  /* Set the SDIO DataLength value */
  SDIOx->DLEN = SDIO_DataInitStruct->DataLength;
 8000900:	684b      	ldr	r3, [r1, #4]
 8000902:	6283      	str	r3, [r0, #40]	; 0x28

  /* Set the SDIO data configuration parameters */
  tmpreg |= (uint32_t)(SDIO_DataInitStruct->DataBlockSize |\
 8000904:	688b      	ldr	r3, [r1, #8]
                       SDIO_DataInitStruct->TransferDir   |\
                       SDIO_DataInitStruct->TransferMode  |\
                       SDIO_DataInitStruct->DPSM);
  
  /* Write to SDIO DCTRL */
  MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 8000906:	6ac4      	ldr	r4, [r0, #44]	; 0x2c

  /* Set the SDIO DataLength value */
  SDIOx->DLEN = SDIO_DataInitStruct->DataLength;

  /* Set the SDIO data configuration parameters */
  tmpreg |= (uint32_t)(SDIO_DataInitStruct->DataBlockSize |\
 8000908:	431a      	orrs	r2, r3
                       SDIO_DataInitStruct->TransferDir   |\
 800090a:	690b      	ldr	r3, [r1, #16]

  /* Set the SDIO DataLength value */
  SDIOx->DLEN = SDIO_DataInitStruct->DataLength;

  /* Set the SDIO data configuration parameters */
  tmpreg |= (uint32_t)(SDIO_DataInitStruct->DataBlockSize |\
 800090c:	6949      	ldr	r1, [r1, #20]
                       SDIO_DataInitStruct->TransferDir   |\
 800090e:	4313      	orrs	r3, r2

  /* Set the SDIO DataLength value */
  SDIOx->DLEN = SDIO_DataInitStruct->DataLength;

  /* Set the SDIO data configuration parameters */
  tmpreg |= (uint32_t)(SDIO_DataInitStruct->DataBlockSize |\
 8000910:	430b      	orrs	r3, r1
                       SDIO_DataInitStruct->TransferDir   |\
                       SDIO_DataInitStruct->TransferMode  |\
                       SDIO_DataInitStruct->DPSM);
  
  /* Write to SDIO DCTRL */
  MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 8000912:	f024 01f7 	bic.w	r1, r4, #247	; 0xf7
 8000916:	430b      	orrs	r3, r1
 8000918:	62c3      	str	r3, [r0, #44]	; 0x2c

  return HAL_OK;

}
 800091a:	2000      	movs	r0, #0
 800091c:	bd10      	pop	{r4, pc}

0800091e <SD_CmdResp2Error>:
  */
static HAL_SD_ErrorTypedef SD_CmdResp2Error(SD_HandleTypeDef *hsd)
{
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  while (!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 800091e:	6803      	ldr	r3, [r0, #0]
 8000920:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000922:	f012 0f45 	tst.w	r2, #69	; 0x45
 8000926:	d0fb      	beq.n	8000920 <SD_CmdResp2Error+0x2>
  {
  }
    
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 8000928:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800092a:	0752      	lsls	r2, r2, #29
 800092c:	d503      	bpl.n	8000936 <SD_CmdResp2Error+0x18>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 800092e:	2204      	movs	r2, #4
 8000930:	639a      	str	r2, [r3, #56]	; 0x38
    
    return errorstate;
 8000932:	2003      	movs	r0, #3
 8000934:	4770      	bx	lr
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
 8000936:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8000938:	f010 0001 	ands.w	r0, r0, #1
  {
    errorstate = SD_CMD_CRC_FAIL;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 800093c:	bf15      	itete	ne
 800093e:	2001      	movne	r0, #1
  {
    /* No error flag set */
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8000940:	f240 52ff 	movweq	r2, #1535	; 0x5ff
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
  {
    errorstate = SD_CMD_CRC_FAIL;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 8000944:	6398      	strne	r0, [r3, #56]	; 0x38
  {
    /* No error flag set */
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8000946:	639a      	streq	r2, [r3, #56]	; 0x38
  
  return errorstate;
}
 8000948:	4770      	bx	lr
	...

0800094c <SD_IsCardProgramming>:
  * @param  hsd: SD handle
  * @param  pStatus: pointer to the variable that will contain the SD card state  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
 800094c:	b570      	push	{r4, r5, r6, lr}
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 800094e:	6a42      	ldr	r2, [r0, #36]	; 0x24
  * @param  hsd: SD handle
  * @param  pStatus: pointer to the variable that will contain the SD card state  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
 8000950:	b086      	sub	sp, #24
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 8000952:	0412      	lsls	r2, r2, #16
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
 8000954:	2300      	movs	r3, #0
  * @param  hsd: SD handle
  * @param  pStatus: pointer to the variable that will contain the SD card state  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
 8000956:	4604      	mov	r4, r0
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 8000958:	9201      	str	r2, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
 800095a:	220d      	movs	r2, #13
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
 800095c:	9300      	str	r3, [sp, #0]
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
 800095e:	9202      	str	r2, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8000960:	9304      	str	r3, [sp, #16]
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8000962:	2240      	movs	r2, #64	; 0x40
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8000964:	f44f 6380 	mov.w	r3, #1024	; 0x400
  * @param  hsd: SD handle
  * @param  pStatus: pointer to the variable that will contain the SD card state  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
 8000968:	460d      	mov	r5, r1
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800096a:	6800      	ldr	r0, [r0, #0]
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 800096c:	9305      	str	r3, [sp, #20]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800096e:	a901      	add	r1, sp, #4
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8000970:	9203      	str	r2, [sp, #12]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8000972:	f7ff ff9f 	bl	80008b4 <SDIO_SendCommand>
  
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8000976:	6823      	ldr	r3, [r4, #0]
 8000978:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800097a:	f012 0f45 	tst.w	r2, #69	; 0x45
 800097e:	d0fb      	beq.n	8000978 <SD_IsCardProgramming+0x2c>
  {
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 8000980:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000982:	0750      	lsls	r0, r2, #29
 8000984:	d503      	bpl.n	800098e <SD_IsCardProgramming+0x42>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8000986:	2204      	movs	r2, #4
 8000988:	639a      	str	r2, [r3, #56]	; 0x38
    
    return errorstate;
 800098a:	2003      	movs	r0, #3
 800098c:	e07c      	b.n	8000a88 <SD_IsCardProgramming+0x13c>
  }
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
 800098e:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8000990:	f010 0601 	ands.w	r6, r0, #1
 8000994:	d002      	beq.n	800099c <SD_IsCardProgramming+0x50>
  {
    errorstate = SD_CMD_CRC_FAIL;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 8000996:	2001      	movs	r0, #1
 8000998:	6398      	str	r0, [r3, #56]	; 0x38
    
    return errorstate;
 800099a:	e075      	b.n	8000a88 <SD_IsCardProgramming+0x13c>
  {
    /* No error flag set */
  }
  
  /* Check response received is of desired command */
  if((uint32_t)SDIO_GetCommandResponse(hsd->Instance) != SD_CMD_SEND_STATUS)
 800099c:	4618      	mov	r0, r3
 800099e:	f7ff ff9c 	bl	80008da <SDIO_GetCommandResponse>
 80009a2:	280d      	cmp	r0, #13
 80009a4:	d001      	beq.n	80009aa <SD_IsCardProgramming+0x5e>
  {
    errorstate = SD_ILLEGAL_CMD;
    
    return errorstate;
 80009a6:	2010      	movs	r0, #16
 80009a8:	e06e      	b.n	8000a88 <SD_IsCardProgramming+0x13c>
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80009aa:	6823      	ldr	r3, [r4, #0]
 80009ac:	f240 52ff 	movw	r2, #1535	; 0x5ff
 80009b0:	639a      	str	r2, [r3, #56]	; 0x38
  
  
  /* We have received response, retrieve it for analysis */
  responseR1 = SDIO_GetResponse(SDIO_RESP1);
 80009b2:	4630      	mov	r0, r6
 80009b4:	f7ff ff94 	bl	80008e0 <SDIO_GetResponse>
 80009b8:	9000      	str	r0, [sp, #0]
  
  /* Find out card status */
  *pStatus = (uint8_t)((responseR1 >> 9U) & 0x0000000FU);
 80009ba:	9b00      	ldr	r3, [sp, #0]
  
  if((responseR1 & SD_OCR_ERRORBITS) == SD_ALLZERO)
 80009bc:	4833      	ldr	r0, [pc, #204]	; (8000a8c <SD_IsCardProgramming+0x140>)
  
  /* We have received response, retrieve it for analysis */
  responseR1 = SDIO_GetResponse(SDIO_RESP1);
  
  /* Find out card status */
  *pStatus = (uint8_t)((responseR1 >> 9U) & 0x0000000FU);
 80009be:	f3c3 2343 	ubfx	r3, r3, #9, #4
 80009c2:	702b      	strb	r3, [r5, #0]
  
  if((responseR1 & SD_OCR_ERRORBITS) == SD_ALLZERO)
 80009c4:	9b00      	ldr	r3, [sp, #0]
 80009c6:	4018      	ands	r0, r3
 80009c8:	2800      	cmp	r0, #0
 80009ca:	d05d      	beq.n	8000a88 <SD_IsCardProgramming+0x13c>
  {
    return errorstate;
  }
  
  if((responseR1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
 80009cc:	9b00      	ldr	r3, [sp, #0]
 80009ce:	2b00      	cmp	r3, #0
 80009d0:	db39      	blt.n	8000a46 <SD_IsCardProgramming+0xfa>
  {
    return(SD_ADDR_OUT_OF_RANGE);
  }
  
  if((responseR1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
 80009d2:	9b00      	ldr	r3, [sp, #0]
 80009d4:	0059      	lsls	r1, r3, #1
 80009d6:	d438      	bmi.n	8000a4a <SD_IsCardProgramming+0xfe>
  {
    return(SD_ADDR_MISALIGNED);
  }
  
  if((responseR1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
 80009d8:	9b00      	ldr	r3, [sp, #0]
 80009da:	009a      	lsls	r2, r3, #2
 80009dc:	d437      	bmi.n	8000a4e <SD_IsCardProgramming+0x102>
  {
    return(SD_BLOCK_LEN_ERR);
  }
  
  if((responseR1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
 80009de:	9b00      	ldr	r3, [sp, #0]
 80009e0:	00db      	lsls	r3, r3, #3
 80009e2:	d436      	bmi.n	8000a52 <SD_IsCardProgramming+0x106>
  {
    return(SD_ERASE_SEQ_ERR);
  }
  
  if((responseR1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
 80009e4:	9b00      	ldr	r3, [sp, #0]
 80009e6:	011e      	lsls	r6, r3, #4
 80009e8:	d435      	bmi.n	8000a56 <SD_IsCardProgramming+0x10a>
  {
    return(SD_BAD_ERASE_PARAM);
  }
  
  if((responseR1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
 80009ea:	9b00      	ldr	r3, [sp, #0]
 80009ec:	015d      	lsls	r5, r3, #5
 80009ee:	d434      	bmi.n	8000a5a <SD_IsCardProgramming+0x10e>
  {
    return(SD_WRITE_PROT_VIOLATION);
  }
  
  if((responseR1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
 80009f0:	9b00      	ldr	r3, [sp, #0]
 80009f2:	01dc      	lsls	r4, r3, #7
 80009f4:	d433      	bmi.n	8000a5e <SD_IsCardProgramming+0x112>
  {
    return(SD_LOCK_UNLOCK_FAILED);
  }
  
  if((responseR1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
 80009f6:	9b00      	ldr	r3, [sp, #0]
 80009f8:	0218      	lsls	r0, r3, #8
 80009fa:	d432      	bmi.n	8000a62 <SD_IsCardProgramming+0x116>
  {
    return(SD_COM_CRC_FAILED);
  }
  
  if((responseR1 & SD_OCR_ILLEGAL_CMD) == SD_OCR_ILLEGAL_CMD)
 80009fc:	9b00      	ldr	r3, [sp, #0]
 80009fe:	0259      	lsls	r1, r3, #9
 8000a00:	d4d1      	bmi.n	80009a6 <SD_IsCardProgramming+0x5a>
  {
    return(SD_ILLEGAL_CMD);
  }
  
  if((responseR1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
 8000a02:	9b00      	ldr	r3, [sp, #0]
 8000a04:	029a      	lsls	r2, r3, #10
 8000a06:	d42e      	bmi.n	8000a66 <SD_IsCardProgramming+0x11a>
  {
    return(SD_CARD_ECC_FAILED);
  }
  
  if((responseR1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
 8000a08:	9b00      	ldr	r3, [sp, #0]
 8000a0a:	02db      	lsls	r3, r3, #11
 8000a0c:	d42d      	bmi.n	8000a6a <SD_IsCardProgramming+0x11e>
  {
    return(SD_CC_ERROR);
  }
  
  if((responseR1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
 8000a0e:	9b00      	ldr	r3, [sp, #0]
 8000a10:	031e      	lsls	r6, r3, #12
 8000a12:	d42c      	bmi.n	8000a6e <SD_IsCardProgramming+0x122>
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
  }
  
  if((responseR1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
 8000a14:	9b00      	ldr	r3, [sp, #0]
 8000a16:	035d      	lsls	r5, r3, #13
 8000a18:	d42b      	bmi.n	8000a72 <SD_IsCardProgramming+0x126>
  {
    return(SD_STREAM_READ_UNDERRUN);
  }
  
  if((responseR1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
 8000a1a:	9b00      	ldr	r3, [sp, #0]
 8000a1c:	039c      	lsls	r4, r3, #14
 8000a1e:	d42a      	bmi.n	8000a76 <SD_IsCardProgramming+0x12a>
  {
    return(SD_STREAM_WRITE_OVERRUN);
  }
  
  if((responseR1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
 8000a20:	9b00      	ldr	r3, [sp, #0]
 8000a22:	03d8      	lsls	r0, r3, #15
 8000a24:	d429      	bmi.n	8000a7a <SD_IsCardProgramming+0x12e>
  {
    return(SD_CID_CSD_OVERWRITE);
  }
  
  if((responseR1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
 8000a26:	9b00      	ldr	r3, [sp, #0]
 8000a28:	0419      	lsls	r1, r3, #16
 8000a2a:	d428      	bmi.n	8000a7e <SD_IsCardProgramming+0x132>
  {
    return(SD_WP_ERASE_SKIP);
  }
  
  if((responseR1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
 8000a2c:	9b00      	ldr	r3, [sp, #0]
 8000a2e:	045a      	lsls	r2, r3, #17
 8000a30:	d427      	bmi.n	8000a82 <SD_IsCardProgramming+0x136>
  {
    return(SD_CARD_ECC_DISABLED);
  }
  
  if((responseR1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
 8000a32:	9b00      	ldr	r3, [sp, #0]
 8000a34:	049b      	lsls	r3, r3, #18
 8000a36:	d426      	bmi.n	8000a86 <SD_IsCardProgramming+0x13a>
  {
    return(SD_ERASE_RESET);
  }
  
  if((responseR1 & SD_OCR_AKE_SEQ_ERROR) == SD_OCR_AKE_SEQ_ERROR)
 8000a38:	9b00      	ldr	r3, [sp, #0]
  {
    return(SD_AKE_SEQ_ERROR);
 8000a3a:	f013 0f08 	tst.w	r3, #8
 8000a3e:	bf0c      	ite	eq
 8000a40:	2000      	moveq	r0, #0
 8000a42:	201a      	movne	r0, #26
 8000a44:	e020      	b.n	8000a88 <SD_IsCardProgramming+0x13c>
    return errorstate;
  }
  
  if((responseR1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
  {
    return(SD_ADDR_OUT_OF_RANGE);
 8000a46:	201c      	movs	r0, #28
 8000a48:	e01e      	b.n	8000a88 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
  {
    return(SD_ADDR_MISALIGNED);
 8000a4a:	2009      	movs	r0, #9
 8000a4c:	e01c      	b.n	8000a88 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
  {
    return(SD_BLOCK_LEN_ERR);
 8000a4e:	200a      	movs	r0, #10
 8000a50:	e01a      	b.n	8000a88 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
  {
    return(SD_ERASE_SEQ_ERR);
 8000a52:	200b      	movs	r0, #11
 8000a54:	e018      	b.n	8000a88 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
  {
    return(SD_BAD_ERASE_PARAM);
 8000a56:	200c      	movs	r0, #12
 8000a58:	e016      	b.n	8000a88 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
  {
    return(SD_WRITE_PROT_VIOLATION);
 8000a5a:	200d      	movs	r0, #13
 8000a5c:	e014      	b.n	8000a88 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
  {
    return(SD_LOCK_UNLOCK_FAILED);
 8000a5e:	200e      	movs	r0, #14
 8000a60:	e012      	b.n	8000a88 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
  {
    return(SD_COM_CRC_FAILED);
 8000a62:	200f      	movs	r0, #15
 8000a64:	e010      	b.n	8000a88 <SD_IsCardProgramming+0x13c>
    return(SD_ILLEGAL_CMD);
  }
  
  if((responseR1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
  {
    return(SD_CARD_ECC_FAILED);
 8000a66:	2011      	movs	r0, #17
 8000a68:	e00e      	b.n	8000a88 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
  {
    return(SD_CC_ERROR);
 8000a6a:	2012      	movs	r0, #18
 8000a6c:	e00c      	b.n	8000a88 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
 8000a6e:	2013      	movs	r0, #19
 8000a70:	e00a      	b.n	8000a88 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
  {
    return(SD_STREAM_READ_UNDERRUN);
 8000a72:	2014      	movs	r0, #20
 8000a74:	e008      	b.n	8000a88 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
  {
    return(SD_STREAM_WRITE_OVERRUN);
 8000a76:	2015      	movs	r0, #21
 8000a78:	e006      	b.n	8000a88 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
  {
    return(SD_CID_CSD_OVERWRITE);
 8000a7a:	2016      	movs	r0, #22
 8000a7c:	e004      	b.n	8000a88 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
  {
    return(SD_WP_ERASE_SKIP);
 8000a7e:	2017      	movs	r0, #23
 8000a80:	e002      	b.n	8000a88 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
  {
    return(SD_CARD_ECC_DISABLED);
 8000a82:	2018      	movs	r0, #24
 8000a84:	e000      	b.n	8000a88 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
  {
    return(SD_ERASE_RESET);
 8000a86:	2019      	movs	r0, #25
  {
    return(SD_AKE_SEQ_ERROR);
  }
  
  return errorstate;
}   
 8000a88:	b006      	add	sp, #24
 8000a8a:	bd70      	pop	{r4, r5, r6, pc}
 8000a8c:	fdffe008 	.word	0xfdffe008

08000a90 <SD_CmdResp1Error>:
static HAL_SD_ErrorTypedef SD_CmdResp1Error(SD_HandleTypeDef *hsd, uint8_t SD_CMD)
{
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t response_r1;
  
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8000a90:	6803      	ldr	r3, [r0, #0]
  * @param  hsd: SD handle
  * @param  SD_CMD: The sent command index  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_CmdResp1Error(SD_HandleTypeDef *hsd, uint8_t SD_CMD)
{
 8000a92:	b570      	push	{r4, r5, r6, lr}
 8000a94:	4604      	mov	r4, r0
 8000a96:	460e      	mov	r6, r1
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t response_r1;
  
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8000a98:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000a9a:	f012 0f45 	tst.w	r2, #69	; 0x45
 8000a9e:	d0fb      	beq.n	8000a98 <SD_CmdResp1Error+0x8>
  {
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 8000aa0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000aa2:	0752      	lsls	r2, r2, #29
 8000aa4:	d503      	bpl.n	8000aae <SD_CmdResp1Error+0x1e>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8000aa6:	2204      	movs	r2, #4
 8000aa8:	639a      	str	r2, [r3, #56]	; 0x38
    
    return errorstate;
 8000aaa:	2003      	movs	r0, #3
 8000aac:	bd70      	pop	{r4, r5, r6, pc}
  }
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
 8000aae:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8000ab0:	f010 0501 	ands.w	r5, r0, #1
 8000ab4:	d002      	beq.n	8000abc <SD_CmdResp1Error+0x2c>
  {
    errorstate = SD_CMD_CRC_FAIL;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 8000ab6:	2001      	movs	r0, #1
 8000ab8:	6398      	str	r0, [r3, #56]	; 0x38
    
    return errorstate;
 8000aba:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  /* Check response received is of desired command */
  if(SDIO_GetCommandResponse(hsd->Instance) != SD_CMD)
 8000abc:	4618      	mov	r0, r3
 8000abe:	f7ff ff0c 	bl	80008da <SDIO_GetCommandResponse>
 8000ac2:	42b0      	cmp	r0, r6
 8000ac4:	d157      	bne.n	8000b76 <SD_CmdResp1Error+0xe6>
    
    return errorstate;
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8000ac6:	6823      	ldr	r3, [r4, #0]
 8000ac8:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8000acc:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* We have received response, retrieve it for analysis  */
  response_r1 = SDIO_GetResponse(SDIO_RESP1);
 8000ace:	4628      	mov	r0, r5
 8000ad0:	f7ff ff06 	bl	80008e0 <SDIO_GetResponse>
  
  if((response_r1 & SD_OCR_ERRORBITS) == SD_ALLZERO)
 8000ad4:	4b29      	ldr	r3, [pc, #164]	; (8000b7c <SD_CmdResp1Error+0xec>)
 8000ad6:	4003      	ands	r3, r0
 8000ad8:	b34b      	cbz	r3, 8000b2e <SD_CmdResp1Error+0x9e>
  {
    return errorstate;
  }
  
  if((response_r1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
 8000ada:	2800      	cmp	r0, #0
 8000adc:	db29      	blt.n	8000b32 <SD_CmdResp1Error+0xa2>
  {
    return(SD_ADDR_OUT_OF_RANGE);
  }
  
  if((response_r1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
 8000ade:	0045      	lsls	r5, r0, #1
 8000ae0:	d429      	bmi.n	8000b36 <SD_CmdResp1Error+0xa6>
  {
    return(SD_ADDR_MISALIGNED);
  }
  
  if((response_r1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
 8000ae2:	0084      	lsls	r4, r0, #2
 8000ae4:	d429      	bmi.n	8000b3a <SD_CmdResp1Error+0xaa>
  {
    return(SD_BLOCK_LEN_ERR);
  }
  
  if((response_r1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
 8000ae6:	00c1      	lsls	r1, r0, #3
 8000ae8:	d429      	bmi.n	8000b3e <SD_CmdResp1Error+0xae>
  {
    return(SD_ERASE_SEQ_ERR);
  }
  
  if((response_r1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
 8000aea:	0102      	lsls	r2, r0, #4
 8000aec:	d429      	bmi.n	8000b42 <SD_CmdResp1Error+0xb2>
  {
    return(SD_BAD_ERASE_PARAM);
  }
  
  if((response_r1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
 8000aee:	0143      	lsls	r3, r0, #5
 8000af0:	d429      	bmi.n	8000b46 <SD_CmdResp1Error+0xb6>
  {
    return(SD_WRITE_PROT_VIOLATION);
  }
  
  if((response_r1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
 8000af2:	01c6      	lsls	r6, r0, #7
 8000af4:	d429      	bmi.n	8000b4a <SD_CmdResp1Error+0xba>
  {
    return(SD_LOCK_UNLOCK_FAILED);
  }
  
  if((response_r1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
 8000af6:	0205      	lsls	r5, r0, #8
 8000af8:	d429      	bmi.n	8000b4e <SD_CmdResp1Error+0xbe>
  {
    return(SD_COM_CRC_FAILED);
  }
  
  if((response_r1 & SD_OCR_ILLEGAL_CMD) == SD_OCR_ILLEGAL_CMD)
 8000afa:	0244      	lsls	r4, r0, #9
 8000afc:	d43b      	bmi.n	8000b76 <SD_CmdResp1Error+0xe6>
  {
    return(SD_ILLEGAL_CMD);
  }
  
  if((response_r1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
 8000afe:	0281      	lsls	r1, r0, #10
 8000b00:	d427      	bmi.n	8000b52 <SD_CmdResp1Error+0xc2>
  {
    return(SD_CARD_ECC_FAILED);
  }
  
  if((response_r1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
 8000b02:	02c2      	lsls	r2, r0, #11
 8000b04:	d427      	bmi.n	8000b56 <SD_CmdResp1Error+0xc6>
  {
    return(SD_CC_ERROR);
  }
  
  if((response_r1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
 8000b06:	0303      	lsls	r3, r0, #12
 8000b08:	d427      	bmi.n	8000b5a <SD_CmdResp1Error+0xca>
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
  }
  
  if((response_r1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
 8000b0a:	0346      	lsls	r6, r0, #13
 8000b0c:	d427      	bmi.n	8000b5e <SD_CmdResp1Error+0xce>
  {
    return(SD_STREAM_READ_UNDERRUN);
  }
  
  if((response_r1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
 8000b0e:	0385      	lsls	r5, r0, #14
 8000b10:	d427      	bmi.n	8000b62 <SD_CmdResp1Error+0xd2>
  {
    return(SD_STREAM_WRITE_OVERRUN);
  }
  
  if((response_r1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
 8000b12:	03c4      	lsls	r4, r0, #15
 8000b14:	d427      	bmi.n	8000b66 <SD_CmdResp1Error+0xd6>
  {
    return(SD_CID_CSD_OVERWRITE);
  }
  
  if((response_r1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
 8000b16:	0401      	lsls	r1, r0, #16
 8000b18:	d427      	bmi.n	8000b6a <SD_CmdResp1Error+0xda>
  {
    return(SD_WP_ERASE_SKIP);
  }
  
  if((response_r1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
 8000b1a:	0442      	lsls	r2, r0, #17
 8000b1c:	d427      	bmi.n	8000b6e <SD_CmdResp1Error+0xde>
  {
    return(SD_CARD_ECC_DISABLED);
  }
  
  if((response_r1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
 8000b1e:	0483      	lsls	r3, r0, #18
 8000b20:	d427      	bmi.n	8000b72 <SD_CmdResp1Error+0xe2>
    return(SD_ERASE_RESET);
  }
  
  if((response_r1 & SD_OCR_AKE_SEQ_ERROR) == SD_OCR_AKE_SEQ_ERROR)
  {
    return(SD_AKE_SEQ_ERROR);
 8000b22:	f010 0f08 	tst.w	r0, #8
 8000b26:	bf0c      	ite	eq
 8000b28:	2000      	moveq	r0, #0
 8000b2a:	201a      	movne	r0, #26
 8000b2c:	bd70      	pop	{r4, r5, r6, pc}
  /* We have received response, retrieve it for analysis  */
  response_r1 = SDIO_GetResponse(SDIO_RESP1);
  
  if((response_r1 & SD_OCR_ERRORBITS) == SD_ALLZERO)
  {
    return errorstate;
 8000b2e:	4618      	mov	r0, r3
 8000b30:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
  {
    return(SD_ADDR_OUT_OF_RANGE);
 8000b32:	201c      	movs	r0, #28
 8000b34:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
  {
    return(SD_ADDR_MISALIGNED);
 8000b36:	2009      	movs	r0, #9
 8000b38:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
  {
    return(SD_BLOCK_LEN_ERR);
 8000b3a:	200a      	movs	r0, #10
 8000b3c:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
  {
    return(SD_ERASE_SEQ_ERR);
 8000b3e:	200b      	movs	r0, #11
 8000b40:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
  {
    return(SD_BAD_ERASE_PARAM);
 8000b42:	200c      	movs	r0, #12
 8000b44:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
  {
    return(SD_WRITE_PROT_VIOLATION);
 8000b46:	200d      	movs	r0, #13
 8000b48:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
  {
    return(SD_LOCK_UNLOCK_FAILED);
 8000b4a:	200e      	movs	r0, #14
 8000b4c:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
  {
    return(SD_COM_CRC_FAILED);
 8000b4e:	200f      	movs	r0, #15
 8000b50:	bd70      	pop	{r4, r5, r6, pc}
    return(SD_ILLEGAL_CMD);
  }
  
  if((response_r1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
  {
    return(SD_CARD_ECC_FAILED);
 8000b52:	2011      	movs	r0, #17
 8000b54:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
  {
    return(SD_CC_ERROR);
 8000b56:	2012      	movs	r0, #18
 8000b58:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
 8000b5a:	2013      	movs	r0, #19
 8000b5c:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
  {
    return(SD_STREAM_READ_UNDERRUN);
 8000b5e:	2014      	movs	r0, #20
 8000b60:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
  {
    return(SD_STREAM_WRITE_OVERRUN);
 8000b62:	2015      	movs	r0, #21
 8000b64:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
  {
    return(SD_CID_CSD_OVERWRITE);
 8000b66:	2016      	movs	r0, #22
 8000b68:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
  {
    return(SD_WP_ERASE_SKIP);
 8000b6a:	2017      	movs	r0, #23
 8000b6c:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
  {
    return(SD_CARD_ECC_DISABLED);
 8000b6e:	2018      	movs	r0, #24
 8000b70:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
  {
    return(SD_ERASE_RESET);
 8000b72:	2019      	movs	r0, #25
 8000b74:	bd70      	pop	{r4, r5, r6, pc}
  /* Check response received is of desired command */
  if(SDIO_GetCommandResponse(hsd->Instance) != SD_CMD)
  {
    errorstate = SD_ILLEGAL_CMD;
    
    return errorstate;
 8000b76:	2010      	movs	r0, #16
  {
    return(SD_AKE_SEQ_ERROR);
  }
  
  return errorstate;
}
 8000b78:	bd70      	pop	{r4, r5, r6, pc}
 8000b7a:	bf00      	nop
 8000b7c:	fdffe008 	.word	0xfdffe008

08000b80 <SD_FindSCR>:
  * @param  hsd: SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
 8000b80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000b82:	b08f      	sub	sp, #60	; 0x3c
  SDIO_CmdInitTypeDef  sdio_cmdinitstructure;
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0U, 0U};
 8000b84:	2300      	movs	r3, #0
  * @param  hsd: SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
 8000b86:	4604      	mov	r4, r0
  SDIO_CmdInitTypeDef  sdio_cmdinitstructure;
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0U, 0U};
 8000b88:	9301      	str	r3, [sp, #4]
 8000b8a:	9302      	str	r3, [sp, #8]
  
  /* Set Block Size To 8 Bytes */
  /* Send CMD55 APP_CMD with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = (uint32_t)8U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 8000b8c:	2510      	movs	r5, #16
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8000b8e:	2240      	movs	r2, #64	; 0x40
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8000b90:	9306      	str	r3, [sp, #24]
  * @param  hsd: SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
 8000b92:	460e      	mov	r6, r1
  /* Send CMD55 APP_CMD with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = (uint32_t)8U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8000b94:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8000b98:	a903      	add	r1, sp, #12
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0U, 0U};
  
  /* Set Block Size To 8 Bytes */
  /* Send CMD55 APP_CMD with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = (uint32_t)8U;
 8000b9a:	2708      	movs	r7, #8
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8000b9c:	6800      	ldr	r0, [r0, #0]
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0U, 0U};
  
  /* Set Block Size To 8 Bytes */
  /* Send CMD55 APP_CMD with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = (uint32_t)8U;
 8000b9e:	9703      	str	r7, [sp, #12]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 8000ba0:	9504      	str	r5, [sp, #16]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8000ba2:	9205      	str	r2, [sp, #20]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8000ba4:	9307      	str	r3, [sp, #28]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8000ba6:	f7ff fe85 	bl	80008b4 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
 8000baa:	4620      	mov	r0, r4
 8000bac:	4629      	mov	r1, r5
 8000bae:	f7ff ff6f 	bl	8000a90 <SD_CmdResp1Error>
  
  if(errorstate != SD_OK)
 8000bb2:	2800      	cmp	r0, #0
 8000bb4:	d161      	bne.n	8000c7a <SD_FindSCR+0xfa>
  {
    return errorstate;
  }
  
  /* Send CMD55 APP_CMD with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = (uint32_t)((hsd->RCA) << 16U);
 8000bb6:	6a63      	ldr	r3, [r4, #36]	; 0x24
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8000bb8:	6820      	ldr	r0, [r4, #0]
  {
    return errorstate;
  }
  
  /* Send CMD55 APP_CMD with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = (uint32_t)((hsd->RCA) << 16U);
 8000bba:	40ab      	lsls	r3, r5
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8000bbc:	a903      	add	r1, sp, #12
    return errorstate;
  }
  
  /* Send CMD55 APP_CMD with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = (uint32_t)((hsd->RCA) << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 8000bbe:	2537      	movs	r5, #55	; 0x37
  {
    return errorstate;
  }
  
  /* Send CMD55 APP_CMD with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = (uint32_t)((hsd->RCA) << 16U);
 8000bc0:	9303      	str	r3, [sp, #12]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 8000bc2:	9504      	str	r5, [sp, #16]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8000bc4:	f7ff fe76 	bl	80008b4 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 8000bc8:	4629      	mov	r1, r5
 8000bca:	4620      	mov	r0, r4
 8000bcc:	f7ff ff60 	bl	8000a90 <SD_CmdResp1Error>
  
  if(errorstate != SD_OK)
 8000bd0:	4605      	mov	r5, r0
 8000bd2:	2800      	cmp	r0, #0
 8000bd4:	d151      	bne.n	8000c7a <SD_FindSCR+0xfa>
  {
    return errorstate;
  }
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
 8000bd6:	f04f 33ff 	mov.w	r3, #4294967295
 8000bda:	9308      	str	r3, [sp, #32]
  sdio_datainitstructure.DataLength    = 8U;
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_8B;
 8000bdc:	2330      	movs	r3, #48	; 0x30
 8000bde:	930a      	str	r3, [sp, #40]	; 0x28
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
 8000be0:	2302      	movs	r3, #2
 8000be2:	930b      	str	r3, [sp, #44]	; 0x2c
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 8000be4:	900c      	str	r0, [sp, #48]	; 0x30
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 8000be6:	2301      	movs	r3, #1
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 8000be8:	a908      	add	r1, sp, #32
 8000bea:	6820      	ldr	r0, [r4, #0]
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
  sdio_datainitstructure.DataLength    = 8U;
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_8B;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 8000bec:	930d      	str	r3, [sp, #52]	; 0x34
  if(errorstate != SD_OK)
  {
    return errorstate;
  }
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
  sdio_datainitstructure.DataLength    = 8U;
 8000bee:	9709      	str	r7, [sp, #36]	; 0x24
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_8B;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 8000bf0:	f7ff fe82 	bl	80008f8 <SDIO_DataConfig>
  
  /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
  sdio_cmdinitstructure.Argument         = 0U;
 8000bf4:	9503      	str	r5, [sp, #12]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_SEND_SCR;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8000bf6:	a903      	add	r1, sp, #12
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
  
  /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_SEND_SCR;
 8000bf8:	2533      	movs	r5, #51	; 0x33
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8000bfa:	6820      	ldr	r0, [r4, #0]
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
  
  /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_SEND_SCR;
 8000bfc:	9504      	str	r5, [sp, #16]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8000bfe:	f7ff fe59 	bl	80008b4 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SD_APP_SEND_SCR);
 8000c02:	4620      	mov	r0, r4
 8000c04:	4629      	mov	r1, r5
 8000c06:	f7ff ff43 	bl	8000a90 <SD_CmdResp1Error>
  
  if(errorstate != SD_OK)
 8000c0a:	2800      	cmp	r0, #0
 8000c0c:	d135      	bne.n	8000c7a <SD_FindSCR+0xfa>
 8000c0e:	466d      	mov	r5, sp
  {
    return errorstate;
  }
#ifdef SDIO_STA_STBITERR  
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
 8000c10:	6823      	ldr	r3, [r4, #0]
 8000c12:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8000c14:	f240 622a 	movw	r2, #1578	; 0x62a
 8000c18:	400a      	ands	r2, r1
 8000c1a:	b942      	cbnz	r2, 8000c2e <SD_FindSCR+0xae>
#else /* SDIO_STA_STBITERR not defined */
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))
#endif /* SDIO_STA_STBITERR */
  {
    if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL))
 8000c1c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000c1e:	0297      	lsls	r7, r2, #10
 8000c20:	d5f7      	bpl.n	8000c12 <SD_FindSCR+0x92>
    {
      *(tempscr + index) = SDIO_ReadFIFO(hsd->Instance);
 8000c22:	4618      	mov	r0, r3
 8000c24:	f7ff fe36 	bl	8000894 <SDIO_ReadFIFO>
 8000c28:	f845 0f04 	str.w	r0, [r5, #4]!
 8000c2c:	e7f0      	b.n	8000c10 <SD_FindSCR+0x90>
      index++;
    }
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
 8000c2e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000c30:	0710      	lsls	r0, r2, #28
 8000c32:	d503      	bpl.n	8000c3c <SD_FindSCR+0xbc>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
 8000c34:	2208      	movs	r2, #8
 8000c36:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_TIMEOUT;
    
    return errorstate;
 8000c38:	2004      	movs	r0, #4
 8000c3a:	e01e      	b.n	8000c7a <SD_FindSCR+0xfa>
  }
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
 8000c3c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000c3e:	0791      	lsls	r1, r2, #30
 8000c40:	d502      	bpl.n	8000c48 <SD_FindSCR+0xc8>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
 8000c42:	2002      	movs	r0, #2
 8000c44:	6398      	str	r0, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_CRC_FAIL;
    
    return errorstate;
 8000c46:	e018      	b.n	8000c7a <SD_FindSCR+0xfa>
  }
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
 8000c48:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000c4a:	0692      	lsls	r2, r2, #26
 8000c4c:	d503      	bpl.n	8000c56 <SD_FindSCR+0xd6>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
 8000c4e:	2220      	movs	r2, #32
 8000c50:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_RX_OVERRUN;
    
    return errorstate;
 8000c52:	2006      	movs	r0, #6
 8000c54:	e011      	b.n	8000c7a <SD_FindSCR+0xfa>
  }
#ifdef SDIO_STA_STBITERR
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
 8000c56:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8000c58:	f410 7000 	ands.w	r0, r0, #512	; 0x200
 8000c5c:	d004      	beq.n	8000c68 <SD_FindSCR+0xe8>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
 8000c5e:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000c62:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_START_BIT_ERR;
    
    return errorstate;
 8000c64:	2007      	movs	r0, #7
 8000c66:	e008      	b.n	8000c7a <SD_FindSCR+0xfa>
  {
    /* No error flag set */
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8000c68:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8000c6c:	639a      	str	r2, [r3, #56]	; 0x38
 8000c6e:	9b01      	ldr	r3, [sp, #4]
 8000c70:	ba1b      	rev	r3, r3
  
  *(pSCR + 1U) = ((tempscr[0U] & SD_0TO7BITS) << 24U)  | ((tempscr[0U] & SD_8TO15BITS) << 8U) |\
 8000c72:	6073      	str	r3, [r6, #4]
 8000c74:	9b02      	ldr	r3, [sp, #8]
 8000c76:	ba1b      	rev	r3, r3
    ((tempscr[0U] & SD_16TO23BITS) >> 8U) | ((tempscr[0U] & SD_24TO31BITS) >> 24U);
  
  *(pSCR) = ((tempscr[1U] & SD_0TO7BITS) << 24U)  | ((tempscr[1U] & SD_8TO15BITS) << 8U) |\
 8000c78:	6033      	str	r3, [r6, #0]
    ((tempscr[1U] & SD_16TO23BITS) >> 8U) | ((tempscr[1U] & SD_24TO31BITS) >> 24U);
  
  return errorstate;
}
 8000c7a:	b00f      	add	sp, #60	; 0x3c
 8000c7c:	bdf0      	pop	{r4, r5, r6, r7, pc}

08000c7e <HAL_SD_XferCpltCallback>:
  * @brief  SD end of transfer callback.
  * @param  hsd: SD handle 
  * @retval None
  */
__weak void HAL_SD_XferCpltCallback(SD_HandleTypeDef *hsd)
{
 8000c7e:	4770      	bx	lr

08000c80 <HAL_SD_XferErrorCallback>:
  * @brief  SD Transfer Error callback.
  * @param  hsd: SD handle
  * @retval None
  */
__weak void HAL_SD_XferErrorCallback(SD_HandleTypeDef *hsd)
{
 8000c80:	4770      	bx	lr

08000c82 <HAL_SD_IRQHandler>:
  * @retval None
  */
void HAL_SD_IRQHandler(SD_HandleTypeDef *hsd)
{  
  /* Check for SDIO interrupt flags */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_DATAEND))
 8000c82:	6803      	ldr	r3, [r0, #0]
 8000c84:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000c86:	05d1      	lsls	r1, r2, #23
  * @brief  This function handles SD card interrupt request.
  * @param  hsd: SD handle
  * @retval None
  */
void HAL_SD_IRQHandler(SD_HandleTypeDef *hsd)
{  
 8000c88:	b510      	push	{r4, lr}
 8000c8a:	4604      	mov	r4, r0
  /* Check for SDIO interrupt flags */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_DATAEND))
 8000c8c:	d509      	bpl.n	8000ca2 <HAL_SD_IRQHandler+0x20>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_IT_DATAEND);  
 8000c8e:	f44f 7280 	mov.w	r2, #256	; 0x100
 8000c92:	639a      	str	r2, [r3, #56]	; 0x38
      
    /* SD transfer is complete */
    hsd->SdTransferCplt = 1U;
 8000c94:	2301      	movs	r3, #1
 8000c96:	6483      	str	r3, [r0, #72]	; 0x48

    /* No transfer error */ 
    hsd->SdTransferErr  = SD_OK;
 8000c98:	2300      	movs	r3, #0
 8000c9a:	64c3      	str	r3, [r0, #76]	; 0x4c

    HAL_SD_XferCpltCallback(hsd);  
 8000c9c:	f7ff ffef 	bl	8000c7e <HAL_SD_XferCpltCallback>
 8000ca0:	e025      	b.n	8000cee <HAL_SD_IRQHandler+0x6c>
  }  
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_DCRCFAIL))
 8000ca2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000ca4:	0792      	lsls	r2, r2, #30
 8000ca6:	d503      	bpl.n	8000cb0 <HAL_SD_IRQHandler+0x2e>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
 8000ca8:	2202      	movs	r2, #2
 8000caa:	639a      	str	r2, [r3, #56]	; 0x38
    
    hsd->SdTransferErr = SD_DATA_CRC_FAIL;
 8000cac:	64c2      	str	r2, [r0, #76]	; 0x4c
 8000cae:	e01c      	b.n	8000cea <HAL_SD_IRQHandler+0x68>
    
    HAL_SD_XferErrorCallback(hsd);
    
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_DTIMEOUT))
 8000cb0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000cb2:	0711      	lsls	r1, r2, #28
 8000cb4:	d503      	bpl.n	8000cbe <HAL_SD_IRQHandler+0x3c>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
 8000cb6:	2208      	movs	r2, #8
 8000cb8:	639a      	str	r2, [r3, #56]	; 0x38
    
    hsd->SdTransferErr = SD_DATA_TIMEOUT;
 8000cba:	2304      	movs	r3, #4
 8000cbc:	e014      	b.n	8000ce8 <HAL_SD_IRQHandler+0x66>
    
    HAL_SD_XferErrorCallback(hsd);
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_RXOVERR))
 8000cbe:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000cc0:	0692      	lsls	r2, r2, #26
 8000cc2:	d503      	bpl.n	8000ccc <HAL_SD_IRQHandler+0x4a>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
 8000cc4:	2220      	movs	r2, #32
 8000cc6:	639a      	str	r2, [r3, #56]	; 0x38
    
    hsd->SdTransferErr = SD_RX_OVERRUN;
 8000cc8:	2306      	movs	r3, #6
 8000cca:	e00d      	b.n	8000ce8 <HAL_SD_IRQHandler+0x66>
    
    HAL_SD_XferErrorCallback(hsd);
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_TXUNDERR))
 8000ccc:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000cce:	06d1      	lsls	r1, r2, #27
 8000cd0:	d503      	bpl.n	8000cda <HAL_SD_IRQHandler+0x58>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_TXUNDERR);
 8000cd2:	2210      	movs	r2, #16
 8000cd4:	639a      	str	r2, [r3, #56]	; 0x38
    
    hsd->SdTransferErr = SD_TX_UNDERRUN;
 8000cd6:	2305      	movs	r3, #5
 8000cd8:	e006      	b.n	8000ce8 <HAL_SD_IRQHandler+0x66>
    
    HAL_SD_XferErrorCallback(hsd);
  }
#ifdef SDIO_STA_STBITERR
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_STBITERR))
 8000cda:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000cdc:	0592      	lsls	r2, r2, #22
 8000cde:	d506      	bpl.n	8000cee <HAL_SD_IRQHandler+0x6c>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
 8000ce0:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000ce4:	639a      	str	r2, [r3, #56]	; 0x38
    
    hsd->SdTransferErr = SD_START_BIT_ERR;
 8000ce6:	2307      	movs	r3, #7
 8000ce8:	64e3      	str	r3, [r4, #76]	; 0x4c
    
    HAL_SD_XferErrorCallback(hsd);
 8000cea:	f7ff ffc9 	bl	8000c80 <HAL_SD_XferErrorCallback>
    /* No error flag set */
  }

  /* Disable all SDIO peripheral interrupt sources */
#ifdef SDIO_STA_STBITERR
  __HAL_SD_SDIO_DISABLE_IT(hsd, SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND  |\
 8000cee:	6822      	ldr	r2, [r4, #0]
 8000cf0:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8000cf2:	f423 4343 	bic.w	r3, r3, #49920	; 0xc300
 8000cf6:	f023 033a 	bic.w	r3, r3, #58	; 0x3a
 8000cfa:	63d3      	str	r3, [r2, #60]	; 0x3c
 8000cfc:	bd10      	pop	{r4, pc}

08000cfe <HAL_SD_Get_CardInfo>:
HAL_SD_ErrorTypedef HAL_SD_Get_CardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *pCardInfo)
{
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t tmp = 0U;
  
  pCardInfo->CardType = (uint8_t)(hsd->CardType);
 8000cfe:	6a03      	ldr	r3, [r0, #32]
 8000d00:	f881 3056 	strb.w	r3, [r1, #86]	; 0x56
  pCardInfo->RCA      = (uint16_t)(hsd->RCA);
 8000d04:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8000d06:	f8a1 3054 	strh.w	r3, [r1, #84]	; 0x54
  
  /* Byte 0 */
  tmp = (hsd->CSD[0U] & 0xFF000000U) >> 24U;
 8000d0a:	f890 302b 	ldrb.w	r3, [r0, #43]	; 0x2b
  pCardInfo->SD_csd.CSDStruct      = (uint8_t)((tmp & 0xC0U) >> 6U);
 8000d0e:	099a      	lsrs	r2, r3, #6
 8000d10:	700a      	strb	r2, [r1, #0]
  pCardInfo->SD_csd.SysSpecVersion = (uint8_t)((tmp & 0x3CU) >> 2U);
 8000d12:	f3c3 0283 	ubfx	r2, r3, #2, #4
  pCardInfo->SD_csd.Reserved1      = tmp & 0x03U;
 8000d16:	f003 0303 	and.w	r3, r3, #3
  pCardInfo->RCA      = (uint16_t)(hsd->RCA);
  
  /* Byte 0 */
  tmp = (hsd->CSD[0U] & 0xFF000000U) >> 24U;
  pCardInfo->SD_csd.CSDStruct      = (uint8_t)((tmp & 0xC0U) >> 6U);
  pCardInfo->SD_csd.SysSpecVersion = (uint8_t)((tmp & 0x3CU) >> 2U);
 8000d1a:	704a      	strb	r2, [r1, #1]
  pCardInfo->SD_csd.Reserved1      = tmp & 0x03U;
 8000d1c:	708b      	strb	r3, [r1, #2]
  
  /* Byte 1 */
  tmp = (hsd->CSD[0U] & 0x00FF0000U) >> 16U;
  pCardInfo->SD_csd.TAAC = (uint8_t)tmp;
 8000d1e:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
 8000d22:	70cb      	strb	r3, [r1, #3]
  
  /* Byte 2 */
  tmp = (hsd->CSD[0U] & 0x0000FF00U) >> 8U;
  pCardInfo->SD_csd.NSAC = (uint8_t)tmp;
 8000d24:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
 8000d28:	710b      	strb	r3, [r1, #4]
  
  /* Byte 3 */
  tmp = hsd->CSD[0U] & 0x000000FFU;
  pCardInfo->SD_csd.MaxBusClkFrec = (uint8_t)tmp;
 8000d2a:	f890 3028 	ldrb.w	r3, [r0, #40]	; 0x28
 8000d2e:	714b      	strb	r3, [r1, #5]
  
  /* Byte 4 */
  tmp = (hsd->CSD[1U] & 0xFF000000U) >> 24U;
 8000d30:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8000d32:	0e1a      	lsrs	r2, r3, #24
  pCardInfo->SD_csd.CardComdClasses = (uint16_t)(tmp << 4U);
 8000d34:	0112      	lsls	r2, r2, #4
 8000d36:	80ca      	strh	r2, [r1, #6]
  
  /* Byte 5 */
  tmp = (hsd->CSD[1U] & 0x00FF0000U) >> 16U;
  pCardInfo->SD_csd.CardComdClasses |= (uint16_t)((tmp & 0xF0) >> 4U);
 8000d38:	88ca      	ldrh	r2, [r1, #6]
  /* Byte 4 */
  tmp = (hsd->CSD[1U] & 0xFF000000U) >> 24U;
  pCardInfo->SD_csd.CardComdClasses = (uint16_t)(tmp << 4U);
  
  /* Byte 5 */
  tmp = (hsd->CSD[1U] & 0x00FF0000U) >> 16U;
 8000d3a:	f3c3 4307 	ubfx	r3, r3, #16, #8
  pCardInfo->SD_csd.CardComdClasses |= (uint16_t)((tmp & 0xF0) >> 4U);
 8000d3e:	b292      	uxth	r2, r2
 8000d40:	ea42 1213 	orr.w	r2, r2, r3, lsr #4
  pCardInfo->SD_csd.RdBlockLen       = (uint8_t)(tmp & 0x0FU);
 8000d44:	f003 030f 	and.w	r3, r3, #15
  tmp = (hsd->CSD[1U] & 0xFF000000U) >> 24U;
  pCardInfo->SD_csd.CardComdClasses = (uint16_t)(tmp << 4U);
  
  /* Byte 5 */
  tmp = (hsd->CSD[1U] & 0x00FF0000U) >> 16U;
  pCardInfo->SD_csd.CardComdClasses |= (uint16_t)((tmp & 0xF0) >> 4U);
 8000d48:	80ca      	strh	r2, [r1, #6]
  pCardInfo->SD_csd.RdBlockLen       = (uint8_t)(tmp & 0x0FU);
 8000d4a:	720b      	strb	r3, [r1, #8]
  * @param  pCardInfo: Pointer to a HAL_SD_CardInfoTypedef structure that  
  *         contains all SD cardinformation  
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_Get_CardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *pCardInfo)
{
 8000d4c:	b5f0      	push	{r4, r5, r6, r7, lr}
  tmp = (hsd->CSD[1U] & 0x00FF0000U) >> 16U;
  pCardInfo->SD_csd.CardComdClasses |= (uint16_t)((tmp & 0xF0) >> 4U);
  pCardInfo->SD_csd.RdBlockLen       = (uint8_t)(tmp & 0x0FU);
  
  /* Byte 6 */
  tmp = (hsd->CSD[1U] & 0x0000FF00U) >> 8U;
 8000d4e:	f890 702d 	ldrb.w	r7, [r0, #45]	; 0x2d
  pCardInfo->SD_csd.PartBlockRead   = (uint8_t)((tmp & 0x80U) >> 7U);
 8000d52:	09fb      	lsrs	r3, r7, #7
 8000d54:	724b      	strb	r3, [r1, #9]
  pCardInfo->SD_csd.WrBlockMisalign = (uint8_t)((tmp & 0x40U) >> 6U);
 8000d56:	f3c7 1380 	ubfx	r3, r7, #6, #1
 8000d5a:	728b      	strb	r3, [r1, #10]
  pCardInfo->SD_csd.RdBlockMisalign = (uint8_t)((tmp & 0x20U) >> 5U);
 8000d5c:	f3c7 1340 	ubfx	r3, r7, #5, #1
 8000d60:	72cb      	strb	r3, [r1, #11]
  * @param  pCardInfo: Pointer to a HAL_SD_CardInfoTypedef structure that  
  *         contains all SD cardinformation  
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_Get_CardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *pCardInfo)
{
 8000d62:	4606      	mov	r6, r0
  /* Byte 6 */
  tmp = (hsd->CSD[1U] & 0x0000FF00U) >> 8U;
  pCardInfo->SD_csd.PartBlockRead   = (uint8_t)((tmp & 0x80U) >> 7U);
  pCardInfo->SD_csd.WrBlockMisalign = (uint8_t)((tmp & 0x40U) >> 6U);
  pCardInfo->SD_csd.RdBlockMisalign = (uint8_t)((tmp & 0x20U) >> 5U);
  pCardInfo->SD_csd.DSRImpl         = (uint8_t)((tmp & 0x10U) >> 4U);
 8000d64:	f3c7 1300 	ubfx	r3, r7, #4, #1
  pCardInfo->SD_csd.Reserved2       = 0U; /*!< Reserved */
 8000d68:	2000      	movs	r0, #0
  /* Byte 6 */
  tmp = (hsd->CSD[1U] & 0x0000FF00U) >> 8U;
  pCardInfo->SD_csd.PartBlockRead   = (uint8_t)((tmp & 0x80U) >> 7U);
  pCardInfo->SD_csd.WrBlockMisalign = (uint8_t)((tmp & 0x40U) >> 6U);
  pCardInfo->SD_csd.RdBlockMisalign = (uint8_t)((tmp & 0x20U) >> 5U);
  pCardInfo->SD_csd.DSRImpl         = (uint8_t)((tmp & 0x10U) >> 4U);
 8000d6a:	730b      	strb	r3, [r1, #12]
  pCardInfo->SD_csd.Reserved2       = 0U; /*!< Reserved */
 8000d6c:	7348      	strb	r0, [r1, #13]
  
  if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0))
 8000d6e:	6a33      	ldr	r3, [r6, #32]
 8000d70:	2b01      	cmp	r3, #1
 8000d72:	d83c      	bhi.n	8000dee <HAL_SD_Get_CardInfo+0xf0>
  {
    pCardInfo->SD_csd.DeviceSize = (tmp & 0x03U) << 10U;
 8000d74:	f007 0703 	and.w	r7, r7, #3
 8000d78:	02bf      	lsls	r7, r7, #10
 8000d7a:	610f      	str	r7, [r1, #16]
    
    /* Byte 7 */
    tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
    pCardInfo->SD_csd.DeviceSize |= (tmp) << 2U;
 8000d7c:	690b      	ldr	r3, [r1, #16]
  if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0))
  {
    pCardInfo->SD_csd.DeviceSize = (tmp & 0x03U) << 10U;
    
    /* Byte 7 */
    tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
 8000d7e:	f896 202c 	ldrb.w	r2, [r6, #44]	; 0x2c
    pCardInfo->SD_csd.DeviceSize |= (tmp) << 2U;
 8000d82:	ea43 0382 	orr.w	r3, r3, r2, lsl #2
 8000d86:	610b      	str	r3, [r1, #16]
    
    /* Byte 8 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
    pCardInfo->SD_csd.DeviceSize |= (tmp & 0xC0U) >> 6U;
 8000d88:	690a      	ldr	r2, [r1, #16]
    /* Byte 7 */
    tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
    pCardInfo->SD_csd.DeviceSize |= (tmp) << 2U;
    
    /* Byte 8 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
 8000d8a:	f896 3033 	ldrb.w	r3, [r6, #51]	; 0x33
    pCardInfo->SD_csd.DeviceSize |= (tmp & 0xC0U) >> 6U;
 8000d8e:	ea42 1293 	orr.w	r2, r2, r3, lsr #6
 8000d92:	610a      	str	r2, [r1, #16]
    
    pCardInfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38U) >> 3U;
 8000d94:	f3c3 02c2 	ubfx	r2, r3, #3, #3
    pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07U);
 8000d98:	f003 0307 	and.w	r3, r3, #7
    
    /* Byte 8 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
    pCardInfo->SD_csd.DeviceSize |= (tmp & 0xC0U) >> 6U;
    
    pCardInfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38U) >> 3U;
 8000d9c:	750a      	strb	r2, [r1, #20]
    pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07U);
 8000d9e:	754b      	strb	r3, [r1, #21]
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
 8000da0:	f896 3032 	ldrb.w	r3, [r6, #50]	; 0x32
    pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
 8000da4:	095a      	lsrs	r2, r3, #5
 8000da6:	758a      	strb	r2, [r1, #22]
    pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
 8000da8:	f3c3 0282 	ubfx	r2, r3, #2, #3
    pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03U) << 1U;
 8000dac:	f003 0303 	and.w	r3, r3, #3
 8000db0:	005b      	lsls	r3, r3, #1
    pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07U);
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
    pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
 8000db2:	75ca      	strb	r2, [r1, #23]
    pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03U) << 1U;
 8000db4:	760b      	strb	r3, [r1, #24]
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
    pCardInfo->SD_csd.DeviceSizeMul |= (tmp & 0x80U) >> 7U;
 8000db6:	7e0b      	ldrb	r3, [r1, #24]
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
    pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
    pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03U) << 1U;
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
 8000db8:	f896 7031 	ldrb.w	r7, [r6, #49]	; 0x31
    pCardInfo->SD_csd.DeviceSizeMul |= (tmp & 0x80U) >> 7U;
 8000dbc:	ea43 13d7 	orr.w	r3, r3, r7, lsr #7
 8000dc0:	760b      	strb	r3, [r1, #24]
    
    pCardInfo->CardCapacity  = (pCardInfo->SD_csd.DeviceSize + 1U) ;
 8000dc2:	690c      	ldr	r4, [r1, #16]
    pCardInfo->CardCapacity *= (1U << (pCardInfo->SD_csd.DeviceSizeMul + 2U));
 8000dc4:	f891 c018 	ldrb.w	ip, [r1, #24]
    pCardInfo->CardBlockSize = 1U << (pCardInfo->SD_csd.RdBlockLen);
 8000dc8:	7a0a      	ldrb	r2, [r1, #8]
 8000dca:	2301      	movs	r3, #1
 8000dcc:	fa03 f202 	lsl.w	r2, r3, r2
    pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03U) << 1U;
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
    pCardInfo->SD_csd.DeviceSizeMul |= (tmp & 0x80U) >> 7U;
    
    pCardInfo->CardCapacity  = (pCardInfo->SD_csd.DeviceSize + 1U) ;
 8000dd0:	3401      	adds	r4, #1
    pCardInfo->CardCapacity *= (1U << (pCardInfo->SD_csd.DeviceSizeMul + 2U));
 8000dd2:	f10c 0c02 	add.w	ip, ip, #2
 8000dd6:	fba2 4504 	umull	r4, r5, r2, r4
 8000dda:	fa03 fc0c 	lsl.w	ip, r3, ip
    pCardInfo->CardBlockSize = 1U << (pCardInfo->SD_csd.RdBlockLen);
 8000dde:	650a      	str	r2, [r1, #80]	; 0x50
    pCardInfo->CardCapacity *= pCardInfo->CardBlockSize;
 8000de0:	fba4 230c 	umull	r2, r3, r4, ip
 8000de4:	fb0c 3305 	mla	r3, ip, r5, r3
 8000de8:	e9c1 2312 	strd	r2, r3, [r1, #72]	; 0x48
 8000dec:	e023      	b.n	8000e36 <HAL_SD_Get_CardInfo+0x138>
  }
  else if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
 8000dee:	2b02      	cmp	r3, #2
 8000df0:	d120      	bne.n	8000e34 <HAL_SD_Get_CardInfo+0x136>
  {
    /* Byte 7 */
    tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
    pCardInfo->SD_csd.DeviceSize = (tmp & 0x3FU) << 16U;
 8000df2:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    
    /* Byte 8 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
 8000df4:	6b37      	ldr	r7, [r6, #48]	; 0x30
  }
  else if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
  {
    /* Byte 7 */
    tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
    pCardInfo->SD_csd.DeviceSize = (tmp & 0x3FU) << 16U;
 8000df6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8000dfa:	041b      	lsls	r3, r3, #16
 8000dfc:	610b      	str	r3, [r1, #16]
    
    /* Byte 8 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
    
    pCardInfo->SD_csd.DeviceSize |= (tmp << 8U);
 8000dfe:	690b      	ldr	r3, [r1, #16]
    /* Byte 7 */
    tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
    pCardInfo->SD_csd.DeviceSize = (tmp & 0x3FU) << 16U;
    
    /* Byte 8 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
 8000e00:	0e3a      	lsrs	r2, r7, #24
    
    pCardInfo->SD_csd.DeviceSize |= (tmp << 8U);
 8000e02:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8000e06:	610b      	str	r3, [r1, #16]
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    
    pCardInfo->SD_csd.DeviceSize |= (tmp);
 8000e08:	690b      	ldr	r3, [r1, #16]
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
    
    pCardInfo->SD_csd.DeviceSize |= (tmp << 8U);
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
 8000e0a:	f3c7 4207 	ubfx	r2, r7, #16, #8
    
    pCardInfo->SD_csd.DeviceSize |= (tmp);
 8000e0e:	4313      	orrs	r3, r2
 8000e10:	610b      	str	r3, [r1, #16]
    
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
    
    pCardInfo->CardCapacity = (uint64_t)((((uint64_t)pCardInfo->SD_csd.DeviceSize + 1U)) * 512U * 1024U);
 8000e12:	690a      	ldr	r2, [r1, #16]
 8000e14:	2300      	movs	r3, #0
 8000e16:	3201      	adds	r2, #1
 8000e18:	f143 0300 	adc.w	r3, r3, #0
 8000e1c:	04db      	lsls	r3, r3, #19
 8000e1e:	ea43 3352 	orr.w	r3, r3, r2, lsr #13
 8000e22:	64cb      	str	r3, [r1, #76]	; 0x4c
 8000e24:	04d2      	lsls	r2, r2, #19
    pCardInfo->CardBlockSize = 512U;    
 8000e26:	f44f 7300 	mov.w	r3, #512	; 0x200
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    
    pCardInfo->SD_csd.DeviceSize |= (tmp);
    
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
 8000e2a:	f3c7 2707 	ubfx	r7, r7, #8, #8
    
    pCardInfo->CardCapacity = (uint64_t)((((uint64_t)pCardInfo->SD_csd.DeviceSize + 1U)) * 512U * 1024U);
 8000e2e:	648a      	str	r2, [r1, #72]	; 0x48
    pCardInfo->CardBlockSize = 512U;    
 8000e30:	650b      	str	r3, [r1, #80]	; 0x50
 8000e32:	e000      	b.n	8000e36 <HAL_SD_Get_CardInfo+0x138>
  }
  else
  {
    /* Not supported card type */
    errorstate = SD_ERROR;
 8000e34:	2029      	movs	r0, #41	; 0x29
  }
    
  pCardInfo->SD_csd.EraseGrSize = (tmp & 0x40U) >> 6U;
 8000e36:	f3c7 1380 	ubfx	r3, r7, #6, #1
  pCardInfo->SD_csd.EraseGrMul  = (tmp & 0x3FU) << 1U;
 8000e3a:	f007 073f 	and.w	r7, r7, #63	; 0x3f
 8000e3e:	007f      	lsls	r7, r7, #1
  {
    /* Not supported card type */
    errorstate = SD_ERROR;
  }
    
  pCardInfo->SD_csd.EraseGrSize = (tmp & 0x40U) >> 6U;
 8000e40:	764b      	strb	r3, [r1, #25]
  pCardInfo->SD_csd.EraseGrMul  = (tmp & 0x3FU) << 1U;
 8000e42:	768f      	strb	r7, [r1, #26]
  
  /* Byte 11 */
  tmp = (uint8_t)(hsd->CSD[2U] & 0x000000FFU);
 8000e44:	6b33      	ldr	r3, [r6, #48]	; 0x30
  pCardInfo->SD_csd.EraseGrMul     |= (tmp & 0x80U) >> 7U;
 8000e46:	7e8c      	ldrb	r4, [r1, #26]
 8000e48:	f3c3 12c0 	ubfx	r2, r3, #7, #1
 8000e4c:	4322      	orrs	r2, r4
  pCardInfo->SD_csd.WrProtectGrSize = (tmp & 0x7FU);
 8000e4e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  pCardInfo->SD_csd.EraseGrSize = (tmp & 0x40U) >> 6U;
  pCardInfo->SD_csd.EraseGrMul  = (tmp & 0x3FU) << 1U;
  
  /* Byte 11 */
  tmp = (uint8_t)(hsd->CSD[2U] & 0x000000FFU);
  pCardInfo->SD_csd.EraseGrMul     |= (tmp & 0x80U) >> 7U;
 8000e52:	768a      	strb	r2, [r1, #26]
  pCardInfo->SD_csd.WrProtectGrSize = (tmp & 0x7FU);
 8000e54:	76cb      	strb	r3, [r1, #27]
  
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0xFF000000U) >> 24U);
 8000e56:	f896 3037 	ldrb.w	r3, [r6, #55]	; 0x37
  pCardInfo->SD_csd.WrProtectGrEnable = (tmp & 0x80U) >> 7U;
 8000e5a:	09da      	lsrs	r2, r3, #7
 8000e5c:	770a      	strb	r2, [r1, #28]
  pCardInfo->SD_csd.ManDeflECC        = (tmp & 0x60U) >> 5U;
 8000e5e:	f3c3 1241 	ubfx	r2, r3, #5, #2
 8000e62:	774a      	strb	r2, [r1, #29]
  pCardInfo->SD_csd.WrSpeedFact       = (tmp & 0x1CU) >> 2U;
 8000e64:	f3c3 0282 	ubfx	r2, r3, #2, #3
  pCardInfo->SD_csd.MaxWrBlockLen     = (tmp & 0x03U) << 2U;
 8000e68:	f003 0303 	and.w	r3, r3, #3
 8000e6c:	009b      	lsls	r3, r3, #2
  
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_csd.WrProtectGrEnable = (tmp & 0x80U) >> 7U;
  pCardInfo->SD_csd.ManDeflECC        = (tmp & 0x60U) >> 5U;
  pCardInfo->SD_csd.WrSpeedFact       = (tmp & 0x1CU) >> 2U;
 8000e6e:	778a      	strb	r2, [r1, #30]
  pCardInfo->SD_csd.MaxWrBlockLen     = (tmp & 0x03U) << 2U;
 8000e70:	77cb      	strb	r3, [r1, #31]
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x00FF0000U) >> 16U);
 8000e72:	f896 3036 	ldrb.w	r3, [r6, #54]	; 0x36
  pCardInfo->SD_csd.MaxWrBlockLen      |= (tmp & 0xC0U) >> 6U;
 8000e76:	7fca      	ldrb	r2, [r1, #31]
 8000e78:	ea42 1293 	orr.w	r2, r2, r3, lsr #6
 8000e7c:	77ca      	strb	r2, [r1, #31]
  pCardInfo->SD_csd.WriteBlockPaPartial = (tmp & 0x20U) >> 5U;
 8000e7e:	f3c3 1240 	ubfx	r2, r3, #5, #1
 8000e82:	f881 2020 	strb.w	r2, [r1, #32]
  pCardInfo->SD_csd.Reserved3           = 0U;
  pCardInfo->SD_csd.ContentProtectAppli = (tmp & 0x01U);
 8000e86:	f003 0301 	and.w	r3, r3, #1
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_csd.MaxWrBlockLen      |= (tmp & 0xC0U) >> 6U;
  pCardInfo->SD_csd.WriteBlockPaPartial = (tmp & 0x20U) >> 5U;
  pCardInfo->SD_csd.Reserved3           = 0U;
 8000e8a:	2200      	movs	r2, #0
 8000e8c:	f881 2021 	strb.w	r2, [r1, #33]	; 0x21
  pCardInfo->SD_csd.ContentProtectAppli = (tmp & 0x01U);
 8000e90:	f881 3022 	strb.w	r3, [r1, #34]	; 0x22
  
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x0000FF00U) >> 8U);
 8000e94:	f896 3035 	ldrb.w	r3, [r6, #53]	; 0x35
  pCardInfo->SD_csd.FileFormatGrouop = (tmp & 0x80U) >> 7U;
 8000e98:	09da      	lsrs	r2, r3, #7
 8000e9a:	f881 2023 	strb.w	r2, [r1, #35]	; 0x23
  pCardInfo->SD_csd.CopyFlag         = (tmp & 0x40U) >> 6U;
 8000e9e:	f3c3 1280 	ubfx	r2, r3, #6, #1
 8000ea2:	f881 2024 	strb.w	r2, [r1, #36]	; 0x24
  pCardInfo->SD_csd.PermWrProtect    = (tmp & 0x20U) >> 5U;
 8000ea6:	f3c3 1240 	ubfx	r2, r3, #5, #1
 8000eaa:	f881 2025 	strb.w	r2, [r1, #37]	; 0x25
  pCardInfo->SD_csd.TempWrProtect    = (tmp & 0x10U) >> 4U;
 8000eae:	f3c3 1200 	ubfx	r2, r3, #4, #1
 8000eb2:	f881 2026 	strb.w	r2, [r1, #38]	; 0x26
  pCardInfo->SD_csd.FileFormat       = (tmp & 0x0CU) >> 2U;
 8000eb6:	f3c3 0281 	ubfx	r2, r3, #2, #2
  pCardInfo->SD_csd.ECC              = (tmp & 0x03U);
 8000eba:	f003 0303 	and.w	r3, r3, #3
  tmp = (uint8_t)((hsd->CSD[3U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_csd.FileFormatGrouop = (tmp & 0x80U) >> 7U;
  pCardInfo->SD_csd.CopyFlag         = (tmp & 0x40U) >> 6U;
  pCardInfo->SD_csd.PermWrProtect    = (tmp & 0x20U) >> 5U;
  pCardInfo->SD_csd.TempWrProtect    = (tmp & 0x10U) >> 4U;
  pCardInfo->SD_csd.FileFormat       = (tmp & 0x0CU) >> 2U;
 8000ebe:	f881 2027 	strb.w	r2, [r1, #39]	; 0x27
  pCardInfo->SD_csd.ECC              = (tmp & 0x03U);
 8000ec2:	f881 3028 	strb.w	r3, [r1, #40]	; 0x28
  
  /* Byte 15 */
  tmp = (uint8_t)(hsd->CSD[3U] & 0x000000FFU);
  pCardInfo->SD_csd.CSD_CRC   = (tmp & 0xFEU) >> 1U;
 8000ec6:	6b73      	ldr	r3, [r6, #52]	; 0x34
  pCardInfo->SD_csd.Reserved4 = 1U;
 8000ec8:	2201      	movs	r2, #1
  pCardInfo->SD_csd.FileFormat       = (tmp & 0x0CU) >> 2U;
  pCardInfo->SD_csd.ECC              = (tmp & 0x03U);
  
  /* Byte 15 */
  tmp = (uint8_t)(hsd->CSD[3U] & 0x000000FFU);
  pCardInfo->SD_csd.CSD_CRC   = (tmp & 0xFEU) >> 1U;
 8000eca:	f3c3 0346 	ubfx	r3, r3, #1, #7
 8000ece:	f881 3029 	strb.w	r3, [r1, #41]	; 0x29
  pCardInfo->SD_csd.Reserved4 = 1U;
 8000ed2:	f881 202a 	strb.w	r2, [r1, #42]	; 0x2a
  
  /* Byte 0 */
  tmp = (uint8_t)((hsd->CID[0U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ManufacturerID = tmp;
 8000ed6:	f896 303b 	ldrb.w	r3, [r6, #59]	; 0x3b
 8000eda:	f881 302c 	strb.w	r3, [r1, #44]	; 0x2c
  
  /* Byte 1 */
  tmp = (uint8_t)((hsd->CID[0U] & 0x00FF0000U) >> 16U);
 8000ede:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 8000ee0:	f3c3 4407 	ubfx	r4, r3, #16, #8
  pCardInfo->SD_cid.OEM_AppliID = tmp << 8U;
 8000ee4:	0224      	lsls	r4, r4, #8
 8000ee6:	85cc      	strh	r4, [r1, #46]	; 0x2e
  
  /* Byte 2 */
  tmp = (uint8_t)((hsd->CID[0U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.OEM_AppliID |= tmp;
 8000ee8:	8dcc      	ldrh	r4, [r1, #46]	; 0x2e
  /* Byte 1 */
  tmp = (uint8_t)((hsd->CID[0U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.OEM_AppliID = tmp << 8U;
  
  /* Byte 2 */
  tmp = (uint8_t)((hsd->CID[0U] & 0x0000FF00U) >> 8U);
 8000eea:	f3c3 2507 	ubfx	r5, r3, #8, #8
  pCardInfo->SD_cid.OEM_AppliID |= tmp;
 8000eee:	b2a4      	uxth	r4, r4
 8000ef0:	432c      	orrs	r4, r5
  
  /* Byte 3 */
  tmp = (uint8_t)(hsd->CID[0U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdName1 = tmp << 24U;
 8000ef2:	061b      	lsls	r3, r3, #24
  tmp = (uint8_t)((hsd->CID[0U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.OEM_AppliID = tmp << 8U;
  
  /* Byte 2 */
  tmp = (uint8_t)((hsd->CID[0U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.OEM_AppliID |= tmp;
 8000ef4:	85cc      	strh	r4, [r1, #46]	; 0x2e
  
  /* Byte 3 */
  tmp = (uint8_t)(hsd->CID[0U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdName1 = tmp << 24U;
 8000ef6:	630b      	str	r3, [r1, #48]	; 0x30
  
  /* Byte 4 */
  tmp = (uint8_t)((hsd->CID[1U] & 0xFF000000U) >> 24U);
 8000ef8:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
  pCardInfo->SD_cid.ProdName1 |= tmp << 16U;
 8000efa:	6b0c      	ldr	r4, [r1, #48]	; 0x30
  /* Byte 3 */
  tmp = (uint8_t)(hsd->CID[0U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdName1 = tmp << 24U;
  
  /* Byte 4 */
  tmp = (uint8_t)((hsd->CID[1U] & 0xFF000000U) >> 24U);
 8000efc:	0e1d      	lsrs	r5, r3, #24
  pCardInfo->SD_cid.ProdName1 |= tmp << 16U;
 8000efe:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8000f02:	630c      	str	r4, [r1, #48]	; 0x30
  
  /* Byte 5 */
  tmp = (uint8_t)((hsd->CID[1U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.ProdName1 |= tmp << 8U;
 8000f04:	6b0c      	ldr	r4, [r1, #48]	; 0x30
  /* Byte 4 */
  tmp = (uint8_t)((hsd->CID[1U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ProdName1 |= tmp << 16U;
  
  /* Byte 5 */
  tmp = (uint8_t)((hsd->CID[1U] & 0x00FF0000U) >> 16U);
 8000f06:	f3c3 4507 	ubfx	r5, r3, #16, #8
  pCardInfo->SD_cid.ProdName1 |= tmp << 8U;
 8000f0a:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
 8000f0e:	630c      	str	r4, [r1, #48]	; 0x30
  
  /* Byte 6 */
  tmp = (uint8_t)((hsd->CID[1U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.ProdName1 |= tmp;
 8000f10:	6b0c      	ldr	r4, [r1, #48]	; 0x30
  /* Byte 5 */
  tmp = (uint8_t)((hsd->CID[1U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.ProdName1 |= tmp << 8U;
  
  /* Byte 6 */
  tmp = (uint8_t)((hsd->CID[1U] & 0x0000FF00U) >> 8U);
 8000f12:	f3c3 2507 	ubfx	r5, r3, #8, #8
  pCardInfo->SD_cid.ProdName1 |= tmp;
 8000f16:	432c      	orrs	r4, r5
  
  /* Byte 7 */
  tmp = (uint8_t)(hsd->CID[1U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdName2 = tmp;
 8000f18:	b2db      	uxtb	r3, r3
  tmp = (uint8_t)((hsd->CID[1U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.ProdName1 |= tmp << 8U;
  
  /* Byte 6 */
  tmp = (uint8_t)((hsd->CID[1U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.ProdName1 |= tmp;
 8000f1a:	630c      	str	r4, [r1, #48]	; 0x30
  
  /* Byte 7 */
  tmp = (uint8_t)(hsd->CID[1U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdName2 = tmp;
 8000f1c:	f881 3034 	strb.w	r3, [r1, #52]	; 0x34
  
  /* Byte 8 */
  tmp = (uint8_t)((hsd->CID[2U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ProdRev = tmp;
 8000f20:	f896 3043 	ldrb.w	r3, [r6, #67]	; 0x43
 8000f24:	f881 3035 	strb.w	r3, [r1, #53]	; 0x35
  
  /* Byte 9 */
  tmp = (uint8_t)((hsd->CID[2U] & 0x00FF0000U) >> 16U);
 8000f28:	6c33      	ldr	r3, [r6, #64]	; 0x40
 8000f2a:	f3c3 4407 	ubfx	r4, r3, #16, #8
  pCardInfo->SD_cid.ProdSN = tmp << 24U;
 8000f2e:	0624      	lsls	r4, r4, #24
 8000f30:	638c      	str	r4, [r1, #56]	; 0x38
  
  /* Byte 10 */
  tmp = (uint8_t)((hsd->CID[2U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.ProdSN |= tmp << 16U;
 8000f32:	6b8c      	ldr	r4, [r1, #56]	; 0x38
  /* Byte 9 */
  tmp = (uint8_t)((hsd->CID[2U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.ProdSN = tmp << 24U;
  
  /* Byte 10 */
  tmp = (uint8_t)((hsd->CID[2U] & 0x0000FF00U) >> 8U);
 8000f34:	f3c3 2507 	ubfx	r5, r3, #8, #8
  pCardInfo->SD_cid.ProdSN |= tmp << 16U;
 8000f38:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8000f3c:	638c      	str	r4, [r1, #56]	; 0x38
  
  /* Byte 11 */
  tmp = (uint8_t)(hsd->CID[2U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdSN |= tmp << 8U;
 8000f3e:	6b8c      	ldr	r4, [r1, #56]	; 0x38
  /* Byte 10 */
  tmp = (uint8_t)((hsd->CID[2U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.ProdSN |= tmp << 16U;
  
  /* Byte 11 */
  tmp = (uint8_t)(hsd->CID[2U] & 0x000000FFU);
 8000f40:	b2db      	uxtb	r3, r3
  pCardInfo->SD_cid.ProdSN |= tmp << 8U;
 8000f42:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 8000f46:	638b      	str	r3, [r1, #56]	; 0x38
  
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CID[3U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ProdSN |= tmp;
 8000f48:	6b8c      	ldr	r4, [r1, #56]	; 0x38
  /* Byte 11 */
  tmp = (uint8_t)(hsd->CID[2U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdSN |= tmp << 8U;
  
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CID[3U] & 0xFF000000U) >> 24U);
 8000f4a:	6c73      	ldr	r3, [r6, #68]	; 0x44
  pCardInfo->SD_cid.ProdSN |= tmp;
 8000f4c:	ea44 6413 	orr.w	r4, r4, r3, lsr #24
 8000f50:	638c      	str	r4, [r1, #56]	; 0x38
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0U) >> 4U;
 8000f52:	f891 403c 	ldrb.w	r4, [r1, #60]	; 0x3c
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CID[3U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ProdSN |= tmp;
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x00FF0000U) >> 16U);
 8000f56:	f3c3 4307 	ubfx	r3, r3, #16, #8
  pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0U) >> 4U;
 8000f5a:	ea44 1413 	orr.w	r4, r4, r3, lsr #4
  pCardInfo->SD_cid.ManufactDate = (tmp & 0x0FU) << 8U;
 8000f5e:	f003 030f 	and.w	r3, r3, #15
 8000f62:	021b      	lsls	r3, r3, #8
  tmp = (uint8_t)((hsd->CID[3U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ProdSN |= tmp;
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0U) >> 4U;
 8000f64:	f881 403c 	strb.w	r4, [r1, #60]	; 0x3c
  pCardInfo->SD_cid.ManufactDate = (tmp & 0x0FU) << 8U;
 8000f68:	87cb      	strh	r3, [r1, #62]	; 0x3e
  
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.ManufactDate |= tmp;
 8000f6a:	8fcc      	ldrh	r4, [r1, #62]	; 0x3e
  tmp = (uint8_t)((hsd->CID[3U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0U) >> 4U;
  pCardInfo->SD_cid.ManufactDate = (tmp & 0x0FU) << 8U;
  
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x0000FF00U) >> 8U);
 8000f6c:	6c73      	ldr	r3, [r6, #68]	; 0x44
  pCardInfo->SD_cid.ManufactDate |= tmp;
 8000f6e:	b2a4      	uxth	r4, r4
  tmp = (uint8_t)((hsd->CID[3U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0U) >> 4U;
  pCardInfo->SD_cid.ManufactDate = (tmp & 0x0FU) << 8U;
  
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x0000FF00U) >> 8U);
 8000f70:	f3c3 2507 	ubfx	r5, r3, #8, #8
  pCardInfo->SD_cid.ManufactDate |= tmp;
 8000f74:	432c      	orrs	r4, r5
  
  /* Byte 15 */
  tmp = (uint8_t)(hsd->CID[3U] & 0x000000FFU);
  pCardInfo->SD_cid.CID_CRC   = (tmp & 0xFEU) >> 1U;
 8000f76:	f3c3 0346 	ubfx	r3, r3, #1, #7
  pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0U) >> 4U;
  pCardInfo->SD_cid.ManufactDate = (tmp & 0x0FU) << 8U;
  
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.ManufactDate |= tmp;
 8000f7a:	87cc      	strh	r4, [r1, #62]	; 0x3e
  
  /* Byte 15 */
  tmp = (uint8_t)(hsd->CID[3U] & 0x000000FFU);
  pCardInfo->SD_cid.CID_CRC   = (tmp & 0xFEU) >> 1U;
 8000f7c:	f881 3040 	strb.w	r3, [r1, #64]	; 0x40
  pCardInfo->SD_cid.Reserved2 = 1U;
 8000f80:	f881 2041 	strb.w	r2, [r1, #65]	; 0x41
  
  return errorstate;
}
 8000f84:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08000f88 <HAL_SD_Init>:
  * @param  hsd: SD handle
  * @param  SDCardInfo: HAL_SD_CardInfoTypedef structure for SD card information   
  * @retval HAL SD error state
  */
HAL_SD_ErrorTypedef HAL_SD_Init(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *SDCardInfo)
{ 
 8000f88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK;
 8000f8c:	2500      	movs	r5, #0
  * @param  hsd: SD handle
  * @param  SDCardInfo: HAL_SD_CardInfoTypedef structure for SD card information   
  * @retval HAL SD error state
  */
HAL_SD_ErrorTypedef HAL_SD_Init(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *SDCardInfo)
{ 
 8000f8e:	b091      	sub	sp, #68	; 0x44
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK;
  SD_InitTypeDef tmpinit;
  
  /* Allocate lock resource and initialize it */
  hsd->Lock = HAL_UNLOCKED;
 8000f90:	7705      	strb	r5, [r0, #28]
  * @param  hsd: SD handle
  * @param  SDCardInfo: HAL_SD_CardInfoTypedef structure for SD card information   
  * @retval HAL SD error state
  */
HAL_SD_ErrorTypedef HAL_SD_Init(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *SDCardInfo)
{ 
 8000f92:	4604      	mov	r4, r0
 8000f94:	460e      	mov	r6, r1
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK;
 8000f96:	f88d 5012 	strb.w	r5, [sp, #18]
  SD_InitTypeDef tmpinit;
  
  /* Allocate lock resource and initialize it */
  hsd->Lock = HAL_UNLOCKED;
  /* Initialize the low level hardware (MSP) */
  HAL_SD_MspInit(hsd);
 8000f9a:	f001 f86f 	bl	800207c <HAL_SD_MspInit>
  tmpinit.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
  tmpinit.ClockBypass         = SDIO_CLOCK_BYPASS_DISABLE;
  tmpinit.ClockPowerSave      = SDIO_CLOCK_POWER_SAVE_DISABLE;
  tmpinit.BusWide             = SDIO_BUS_WIDE_1B;
  tmpinit.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
  tmpinit.ClockDiv            = SDIO_INIT_CLK_DIV;
 8000f9e:	2376      	movs	r3, #118	; 0x76
 8000fa0:	930f      	str	r3, [sp, #60]	; 0x3c
  
  /* Default SDIO peripheral configuration for SD card initialization */
  tmpinit.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
  tmpinit.ClockBypass         = SDIO_CLOCK_BYPASS_DISABLE;
  tmpinit.ClockPowerSave      = SDIO_CLOCK_POWER_SAVE_DISABLE;
  tmpinit.BusWide             = SDIO_BUS_WIDE_1B;
 8000fa2:	950d      	str	r5, [sp, #52]	; 0x34
  tmpinit.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
 8000fa4:	950e      	str	r5, [sp, #56]	; 0x38
  tmpinit.ClockDiv            = SDIO_INIT_CLK_DIV;
  
  /* Initialize SDIO peripheral interface with default configuration */
  SDIO_Init(hsd->Instance, tmpinit);
 8000fa6:	ab10      	add	r3, sp, #64	; 0x40
 8000fa8:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 8000fac:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
  hsd->Lock = HAL_UNLOCKED;
  /* Initialize the low level hardware (MSP) */
  HAL_SD_MspInit(hsd);
  
  /* Default SDIO peripheral configuration for SD card initialization */
  tmpinit.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
 8000fb0:	950a      	str	r5, [sp, #40]	; 0x28
  tmpinit.ClockBypass         = SDIO_CLOCK_BYPASS_DISABLE;
 8000fb2:	950b      	str	r5, [sp, #44]	; 0x2c
  tmpinit.ClockPowerSave      = SDIO_CLOCK_POWER_SAVE_DISABLE;
 8000fb4:	950c      	str	r5, [sp, #48]	; 0x30
  uint32_t response = 0U, count = 0U, validvoltage = 0U;
  uint32_t sdtype = SD_STD_CAPACITY;
  
  /* Power ON Sequence -------------------------------------------------------*/
  /* Disable SDIO Clock */
  __HAL_SD_SDIO_DISABLE(); 
 8000fb6:	4f9f      	ldr	r7, [pc, #636]	; (8001234 <HAL_SD_Init+0x2ac>)
  tmpinit.BusWide             = SDIO_BUS_WIDE_1B;
  tmpinit.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
  tmpinit.ClockDiv            = SDIO_INIT_CLK_DIV;
  
  /* Initialize SDIO peripheral interface with default configuration */
  SDIO_Init(hsd->Instance, tmpinit);
 8000fb8:	6820      	ldr	r0, [r4, #0]
 8000fba:	ab0a      	add	r3, sp, #40	; 0x28
 8000fbc:	cb0e      	ldmia	r3, {r1, r2, r3}
 8000fbe:	f7ff fc4d 	bl	800085c <SDIO_Init>
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_PowerON(SD_HandleTypeDef *hsd)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure; 
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK; 
 8000fc2:	f88d 5013 	strb.w	r5, [sp, #19]
  /* Power ON Sequence -------------------------------------------------------*/
  /* Disable SDIO Clock */
  __HAL_SD_SDIO_DISABLE(); 
  
  /* Set Power State to ON */
  SDIO_PowerState_ON(hsd->Instance);
 8000fc6:	6820      	ldr	r0, [r4, #0]
  uint32_t response = 0U, count = 0U, validvoltage = 0U;
  uint32_t sdtype = SD_STD_CAPACITY;
  
  /* Power ON Sequence -------------------------------------------------------*/
  /* Disable SDIO Clock */
  __HAL_SD_SDIO_DISABLE(); 
 8000fc8:	603d      	str	r5, [r7, #0]
  
  /* Set Power State to ON */
  SDIO_PowerState_ON(hsd->Instance);
 8000fca:	f7ff fc6b 	bl	80008a4 <SDIO_PowerState_ON>
  
  /* 1ms: required power up waiting time before starting the SD initialization 
     sequence */
  HAL_Delay(1);
 8000fce:	2001      	movs	r0, #1
 8000fd0:	f001 f806 	bl	8001fe0 <HAL_Delay>
  
  /* Enable SDIO Clock */
  __HAL_SD_SDIO_ENABLE();
 8000fd4:	2301      	movs	r3, #1
 8000fd6:	603b      	str	r3, [r7, #0]
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_GO_IDLE_STATE;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_NO;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8000fd8:	6820      	ldr	r0, [r4, #0]
  /* Enable SDIO Clock */
  __HAL_SD_SDIO_ENABLE();
  
  /* CMD0: GO_IDLE_STATE -----------------------------------------------------*/
  /* No CMD response required */
  sdio_cmdinitstructure.Argument         = 0U;
 8000fda:	9505      	str	r5, [sp, #20]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_GO_IDLE_STATE;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_NO;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8000fdc:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8000fe0:	a905      	add	r1, sp, #20
  /* No CMD response required */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_GO_IDLE_STATE;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_NO;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8000fe2:	9309      	str	r3, [sp, #36]	; 0x24
  __HAL_SD_SDIO_ENABLE();
  
  /* CMD0: GO_IDLE_STATE -----------------------------------------------------*/
  /* No CMD response required */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_GO_IDLE_STATE;
 8000fe4:	9506      	str	r5, [sp, #24]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_NO;
 8000fe6:	9507      	str	r5, [sp, #28]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8000fe8:	9508      	str	r5, [sp, #32]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8000fea:	f7ff fc63 	bl	80008b4 <SDIO_SendCommand>
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t timeout, tmp;
  
  timeout = SDIO_CMD0TIMEOUT;
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
 8000fee:	6820      	ldr	r0, [r4, #0]
 8000ff0:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8000ff2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000ff6:	f3c2 12c0 	ubfx	r2, r2, #7, #1
    
  while((timeout > 0U) && (!tmp))
 8000ffa:	2a00      	cmp	r2, #0
 8000ffc:	f040 8182 	bne.w	8001304 <HAL_SD_Init+0x37c>
  {
    tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
 8001000:	6b42      	ldr	r2, [r0, #52]	; 0x34
  
  timeout = SDIO_CMD0TIMEOUT;
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
    
  while((timeout > 0U) && (!tmp))
 8001002:	3b01      	subs	r3, #1
  {
    tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
 8001004:	f3c2 12c0 	ubfx	r2, r2, #7, #1
  
  timeout = SDIO_CMD0TIMEOUT;
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
    
  while((timeout > 0U) && (!tmp))
 8001008:	d1f7      	bne.n	8000ffa <HAL_SD_Init+0x72>
  }
  
  if(timeout == 0U)
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    return errorstate;
 800100a:	2303      	movs	r3, #3
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
  
  /* Check for error conditions */
  errorstate = SD_CmdError(hsd);
 800100c:	f88d 3013 	strb.w	r3, [sp, #19]
  
  if(errorstate != SD_OK)
 8001010:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8001014:	2b00      	cmp	r3, #0
 8001016:	f040 80a5 	bne.w	8001164 <HAL_SD_Init+0x1dc>
  /* Send CMD8 to verify SD card interface operating condition */
  /* Argument: - [31:12]: Reserved (shall be set to '0')
  - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
  - [7:0]: Check Pattern (recommended 0xAA) */
  /* CMD Response: R7 */
  sdio_cmdinitstructure.Argument         = SD_CHECK_PATTERN;
 800101a:	f44f 73d5 	mov.w	r3, #426	; 0x1aa
 800101e:	9305      	str	r3, [sp, #20]
  sdio_cmdinitstructure.CmdIndex         = SD_SDIO_SEND_IF_COND;
 8001020:	2308      	movs	r3, #8
 8001022:	9306      	str	r3, [sp, #24]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001024:	a905      	add	r1, sp, #20
  - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
  - [7:0]: Check Pattern (recommended 0xAA) */
  /* CMD Response: R7 */
  sdio_cmdinitstructure.Argument         = SD_CHECK_PATTERN;
  sdio_cmdinitstructure.CmdIndex         = SD_SDIO_SEND_IF_COND;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8001026:	2340      	movs	r3, #64	; 0x40
 8001028:	9307      	str	r3, [sp, #28]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800102a:	f7ff fc43 	bl	80008b4 <SDIO_SendCommand>
static HAL_SD_ErrorTypedef SD_CmdResp7Error(SD_HandleTypeDef *hsd)
{
  HAL_SD_ErrorTypedef errorstate = SD_ERROR;
  uint32_t timeout = SDIO_CMD0TIMEOUT, tmp;
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT); 
 800102e:	6820      	ldr	r0, [r4, #0]
 8001030:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001032:	f013 0f45 	tst.w	r3, #69	; 0x45
 8001036:	bf0c      	ite	eq
 8001038:	2200      	moveq	r2, #0
 800103a:	2201      	movne	r2, #1
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_CmdResp7Error(SD_HandleTypeDef *hsd)
{
  HAL_SD_ErrorTypedef errorstate = SD_ERROR;
  uint32_t timeout = SDIO_CMD0TIMEOUT, tmp;
 800103c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT); 
  
  while((!tmp) && (timeout > 0U))
 8001040:	b942      	cbnz	r2, 8001054 <HAL_SD_Init+0xcc>
 8001042:	b13b      	cbz	r3, 8001054 <HAL_SD_Init+0xcc>
  {
    tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT);
 8001044:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8001046:	f012 0f45 	tst.w	r2, #69	; 0x45
 800104a:	bf0c      	ite	eq
 800104c:	2200      	moveq	r2, #0
 800104e:	2201      	movne	r2, #1
    timeout--;
 8001050:	3b01      	subs	r3, #1
 8001052:	e7f5      	b.n	8001040 <HAL_SD_Init+0xb8>
  }
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT); 
 8001054:	6b42      	ldr	r2, [r0, #52]	; 0x34
  
  if((timeout == 0U) || tmp)
 8001056:	b113      	cbz	r3, 800105e <HAL_SD_Init+0xd6>
 8001058:	f012 0304 	ands.w	r3, r2, #4
 800105c:	d003      	beq.n	8001066 <HAL_SD_Init+0xde>
  {
    /* Card is not V2.0 compliant or card does not support the set voltage range */
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 800105e:	2304      	movs	r3, #4
 8001060:	6383      	str	r3, [r0, #56]	; 0x38
    
    return errorstate;
 8001062:	2303      	movs	r3, #3
 8001064:	e005      	b.n	8001072 <HAL_SD_Init+0xea>
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDREND))
 8001066:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8001068:	0657      	lsls	r7, r2, #25
  {
    /* Card is SD V2.0 compliant */
    errorstate = SD_OK;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CMDREND);
 800106a:	bf46      	itte	mi
 800106c:	2240      	movmi	r2, #64	; 0x40
 800106e:	6382      	strmi	r2, [r0, #56]	; 0x38
    
    return errorstate;
  }
  
  return errorstate;
 8001070:	2329      	movpl	r3, #41	; 0x29
  sdio_cmdinitstructure.CmdIndex         = SD_SDIO_SEND_IF_COND;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
  
  /* Check for error conditions */ 
  errorstate = SD_CmdResp7Error(hsd);
 8001072:	f88d 3013 	strb.w	r3, [sp, #19]
  
  if (errorstate == SD_OK)
 8001076:	f89d 2013 	ldrb.w	r2, [sp, #19]
 800107a:	2300      	movs	r3, #0
 800107c:	b922      	cbnz	r2, 8001088 <HAL_SD_Init+0x100>
  {
    /* SD Card 2.0 */
    hsd->CardType = STD_CAPACITY_SD_CARD_V2_0; 
 800107e:	2201      	movs	r2, #1
 8001080:	6222      	str	r2, [r4, #32]
    sdtype        = SD_HIGH_CAPACITY;
 8001082:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
 8001086:	e000      	b.n	800108a <HAL_SD_Init+0x102>
static HAL_SD_ErrorTypedef SD_PowerON(SD_HandleTypeDef *hsd)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure; 
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK; 
  uint32_t response = 0U, count = 0U, validvoltage = 0U;
  uint32_t sdtype = SD_STD_CAPACITY;
 8001088:	4698      	mov	r8, r3
    sdtype        = SD_HIGH_CAPACITY;
  }
  
  /* Send CMD55 */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 800108a:	2537      	movs	r5, #55	; 0x37
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800108c:	a905      	add	r1, sp, #20
    hsd->CardType = STD_CAPACITY_SD_CARD_V2_0; 
    sdtype        = SD_HIGH_CAPACITY;
  }
  
  /* Send CMD55 */
  sdio_cmdinitstructure.Argument         = 0U;
 800108e:	9305      	str	r3, [sp, #20]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 8001090:	9506      	str	r5, [sp, #24]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001092:	f7ff fc0f 	bl	80008b4 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 8001096:	4629      	mov	r1, r5
 8001098:	4620      	mov	r0, r4
 800109a:	f7ff fcf9 	bl	8000a90 <SD_CmdResp1Error>
 800109e:	f88d 0013 	strb.w	r0, [sp, #19]
  
  /* If errorstate is Command Timeout, it is a MMC card */
  /* If errorstate is SD_OK it is a SD card: SD card 2.0 (voltage range mismatch)
     or SD card 1.x */
  if(errorstate == SD_OK)
 80010a2:	f89d 3013 	ldrb.w	r3, [sp, #19]
 80010a6:	f003 05ff 	and.w	r5, r3, #255	; 0xff
 80010aa:	2b00      	cmp	r3, #0
 80010ac:	d15a      	bne.n	8001164 <HAL_SD_Init+0x1dc>
 80010ae:	462f      	mov	r7, r5
 80010b0:	4628      	mov	r0, r5
 80010b2:	f64f 73ff 	movw	r3, #65535	; 0xffff
  {
    /* SD CARD */
    /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
 80010b6:	2d00      	cmp	r5, #0
 80010b8:	d14a      	bne.n	8001150 <HAL_SD_Init+0x1c8>
 80010ba:	429f      	cmp	r7, r3
 80010bc:	d04a      	beq.n	8001154 <HAL_SD_Init+0x1cc>
    {
      
      /* SEND CMD55 APP_CMD with RCA as 0 */
      sdio_cmdinitstructure.Argument         = 0U;
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 80010be:	f04f 0b37 	mov.w	fp, #55	; 0x37
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80010c2:	a905      	add	r1, sp, #20
    {
      
      /* SEND CMD55 APP_CMD with RCA as 0 */
      sdio_cmdinitstructure.Argument         = 0U;
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80010c4:	f04f 0a40 	mov.w	sl, #64	; 0x40
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80010c8:	f44f 6980 	mov.w	r9, #1024	; 0x400
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80010cc:	6820      	ldr	r0, [r4, #0]
    /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
    {
      
      /* SEND CMD55 APP_CMD with RCA as 0 */
      sdio_cmdinitstructure.Argument         = 0U;
 80010ce:	9505      	str	r5, [sp, #20]
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 80010d0:	f8cd b018 	str.w	fp, [sp, #24]
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80010d4:	f8cd a01c 	str.w	sl, [sp, #28]
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80010d8:	9508      	str	r5, [sp, #32]
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80010da:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80010de:	f7ff fbe9 	bl	80008b4 <SDIO_SendCommand>
      
      /* Check for error conditions */
      errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 80010e2:	4620      	mov	r0, r4
 80010e4:	4659      	mov	r1, fp
 80010e6:	f7ff fcd3 	bl	8000a90 <SD_CmdResp1Error>
 80010ea:	f88d 0013 	strb.w	r0, [sp, #19]
      
      if(errorstate != SD_OK)
 80010ee:	f89d 3013 	ldrb.w	r3, [sp, #19]
 80010f2:	2b00      	cmp	r3, #0
 80010f4:	d136      	bne.n	8001164 <HAL_SD_Init+0x1dc>
      {
        return errorstate;
      }
      
      /* Send CMD41 */
      sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
 80010f6:	f048 4300 	orr.w	r3, r8, #2147483648	; 0x80000000
 80010fa:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80010fe:	9305      	str	r3, [sp, #20]
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_OP_COND;
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001100:	6820      	ldr	r0, [r4, #0]
      }
      
      /* Send CMD41 */
      sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_OP_COND;
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8001102:	f8cd a01c 	str.w	sl, [sp, #28]
        return errorstate;
      }
      
      /* Send CMD41 */
      sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_OP_COND;
 8001106:	2329      	movs	r3, #41	; 0x29
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001108:	a905      	add	r1, sp, #20
        return errorstate;
      }
      
      /* Send CMD41 */
      sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_OP_COND;
 800110a:	9306      	str	r3, [sp, #24]
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 800110c:	9508      	str	r5, [sp, #32]
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 800110e:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001112:	f7ff fbcf 	bl	80008b4 <SDIO_SendCommand>
  */
static HAL_SD_ErrorTypedef SD_CmdResp3Error(SD_HandleTypeDef *hsd)
{
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  while (!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8001116:	6823      	ldr	r3, [r4, #0]
 8001118:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800111a:	f012 0f45 	tst.w	r2, #69	; 0x45
 800111e:	d0fb      	beq.n	8001118 <HAL_SD_Init+0x190>
  {
  }
  
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 8001120:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001122:	f012 0204 	ands.w	r2, r2, #4
 8001126:	d003      	beq.n	8001130 <HAL_SD_Init+0x1a8>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8001128:	2204      	movs	r2, #4
 800112a:	639a      	str	r2, [r3, #56]	; 0x38
    
    return errorstate;
 800112c:	2303      	movs	r3, #3
 800112e:	e003      	b.n	8001138 <HAL_SD_Init+0x1b0>
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8001130:	f240 51ff 	movw	r1, #1535	; 0x5ff
 8001134:	6399      	str	r1, [r3, #56]	; 0x38
  
  return errorstate;
 8001136:	4613      	mov	r3, r2
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
      
      /* Check for error conditions */
      errorstate = SD_CmdResp3Error(hsd);
 8001138:	f88d 3013 	strb.w	r3, [sp, #19]
      
      if(errorstate != SD_OK)
 800113c:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8001140:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8001144:	b973      	cbnz	r3, 8001164 <HAL_SD_Init+0x1dc>
      {
        return errorstate;
      }
      
      /* Get command response */
      response = SDIO_GetResponse(SDIO_RESP1);
 8001146:	f7ff fbcb 	bl	80008e0 <SDIO_GetResponse>
      
      /* Get operating voltage*/
      validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
      
      count++;
 800114a:	3701      	adds	r7, #1
      
      /* Get command response */
      response = SDIO_GetResponse(SDIO_RESP1);
      
      /* Get operating voltage*/
      validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
 800114c:	0fc5      	lsrs	r5, r0, #31
 800114e:	e7b0      	b.n	80010b2 <HAL_SD_Init+0x12a>
      
      count++;
    }
    
    if(count >= SD_MAX_VOLT_TRIAL)
 8001150:	429f      	cmp	r7, r3
 8001152:	d103      	bne.n	800115c <HAL_SD_Init+0x1d4>
    {
      errorstate = SD_INVALID_VOLTRANGE;
 8001154:	231b      	movs	r3, #27
 8001156:	f88d 3013 	strb.w	r3, [sp, #19]
 800115a:	e003      	b.n	8001164 <HAL_SD_Init+0x1dc>
      
      return errorstate;
    }
    
    if((response & SD_HIGH_CAPACITY) == SD_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
 800115c:	0045      	lsls	r5, r0, #1
    {
      hsd->CardType = HIGH_CAPACITY_SD_CARD;
 800115e:	bf44      	itt	mi
 8001160:	2302      	movmi	r3, #2
 8001162:	6223      	strmi	r3, [r4, #32]
    }
    
  } /* else MMC Card */
  
  return errorstate;
 8001164:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8001168:	b2db      	uxtb	r3, r3
  
  /* Initialize SDIO peripheral interface with default configuration */
  SDIO_Init(hsd->Instance, tmpinit);
  
  /* Identify card operating voltage */
  errorstate = SD_PowerON(hsd); 
 800116a:	f88d 3012 	strb.w	r3, [sp, #18]
  
  if(errorstate != SD_OK)     
 800116e:	f89d 3012 	ldrb.w	r3, [sp, #18]
 8001172:	f003 05ff 	and.w	r5, r3, #255	; 0xff
 8001176:	2b00      	cmp	r3, #0
 8001178:	f040 80be 	bne.w	80012f8 <HAL_SD_Init+0x370>
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure; 
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint16_t sd_rca = 1U;
  
  if(SDIO_GetPowerState(hsd->Instance) == 0U) /* Power off */
 800117c:	6820      	ldr	r0, [r4, #0]
 800117e:	f7ff fb95 	bl	80008ac <SDIO_GetPowerState>
 8001182:	2800      	cmp	r0, #0
 8001184:	f000 8082 	beq.w	800128c <HAL_SD_Init+0x304>
    errorstate = SD_REQUEST_NOT_APPLICABLE;
    
    return errorstate;
  }
  
  if(hsd->CardType != SECURE_DIGITAL_IO_CARD)
 8001188:	6a23      	ldr	r3, [r4, #32]
 800118a:	2b04      	cmp	r3, #4
 800118c:	d020      	beq.n	80011d0 <HAL_SD_Init+0x248>
  {
    /* Send CMD2 ALL_SEND_CID */
    sdio_cmdinitstructure.Argument         = 0U;
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_ALL_SEND_CID;
 800118e:	2302      	movs	r3, #2
 8001190:	9306      	str	r3, [sp, #24]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
 8001192:	23c0      	movs	r3, #192	; 0xc0
 8001194:	9307      	str	r3, [sp, #28]
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001196:	6820      	ldr	r0, [r4, #0]
  }
  
  if(hsd->CardType != SECURE_DIGITAL_IO_CARD)
  {
    /* Send CMD2 ALL_SEND_CID */
    sdio_cmdinitstructure.Argument         = 0U;
 8001198:	9505      	str	r5, [sp, #20]
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_ALL_SEND_CID;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 800119a:	f44f 6380 	mov.w	r3, #1024	; 0x400
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800119e:	a905      	add	r1, sp, #20
  {
    /* Send CMD2 ALL_SEND_CID */
    sdio_cmdinitstructure.Argument         = 0U;
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_ALL_SEND_CID;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80011a0:	9508      	str	r5, [sp, #32]
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80011a2:	9309      	str	r3, [sp, #36]	; 0x24
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80011a4:	f7ff fb86 	bl	80008b4 <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp2Error(hsd);
 80011a8:	4620      	mov	r0, r4
 80011aa:	f7ff fbb8 	bl	800091e <SD_CmdResp2Error>
    
    if(errorstate != SD_OK)
 80011ae:	2800      	cmp	r0, #0
 80011b0:	d171      	bne.n	8001296 <HAL_SD_Init+0x30e>
    {
      return errorstate;
    }
    
    /* Get Card identification number data */
    hsd->CID[0U] = SDIO_GetResponse(SDIO_RESP1);
 80011b2:	f7ff fb95 	bl	80008e0 <SDIO_GetResponse>
 80011b6:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->CID[1U] = SDIO_GetResponse(SDIO_RESP2);
 80011b8:	2004      	movs	r0, #4
 80011ba:	f7ff fb91 	bl	80008e0 <SDIO_GetResponse>
 80011be:	63e0      	str	r0, [r4, #60]	; 0x3c
    hsd->CID[2U] = SDIO_GetResponse(SDIO_RESP3);
 80011c0:	2008      	movs	r0, #8
 80011c2:	f7ff fb8d 	bl	80008e0 <SDIO_GetResponse>
 80011c6:	6420      	str	r0, [r4, #64]	; 0x40
    hsd->CID[3U] = SDIO_GetResponse(SDIO_RESP4);
 80011c8:	200c      	movs	r0, #12
 80011ca:	f7ff fb89 	bl	80008e0 <SDIO_GetResponse>
 80011ce:	6460      	str	r0, [r4, #68]	; 0x44
  }
  
  if((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1)    || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
 80011d0:	6a23      	ldr	r3, [r4, #32]
 80011d2:	2b02      	cmp	r3, #2
 80011d4:	d901      	bls.n	80011da <HAL_SD_Init+0x252>
 80011d6:	2b06      	cmp	r3, #6
 80011d8:	d134      	bne.n	8001244 <HAL_SD_Init+0x2bc>
     (hsd->CardType == SECURE_DIGITAL_IO_COMBO_CARD) || (hsd->CardType == HIGH_CAPACITY_SD_CARD))
  {
    /* Send CMD3 SET_REL_ADDR with argument 0 */
    /* SD Card publishes its RCA. */
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_REL_ADDR;
 80011da:	2303      	movs	r3, #3
 80011dc:	9306      	str	r3, [sp, #24]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80011de:	6820      	ldr	r0, [r4, #0]
     (hsd->CardType == SECURE_DIGITAL_IO_COMBO_CARD) || (hsd->CardType == HIGH_CAPACITY_SD_CARD))
  {
    /* Send CMD3 SET_REL_ADDR with argument 0 */
    /* SD Card publishes its RCA. */
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_REL_ADDR;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80011e0:	2340      	movs	r3, #64	; 0x40
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80011e2:	a905      	add	r1, sp, #20
     (hsd->CardType == SECURE_DIGITAL_IO_COMBO_CARD) || (hsd->CardType == HIGH_CAPACITY_SD_CARD))
  {
    /* Send CMD3 SET_REL_ADDR with argument 0 */
    /* SD Card publishes its RCA. */
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_REL_ADDR;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80011e4:	9307      	str	r3, [sp, #28]
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80011e6:	f7ff fb65 	bl	80008b4 <SDIO_SendCommand>
static HAL_SD_ErrorTypedef SD_CmdResp6Error(SD_HandleTypeDef *hsd, uint8_t SD_CMD, uint16_t *pRCA)
{
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t response_r1;
  
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 80011ea:	6823      	ldr	r3, [r4, #0]
 80011ec:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80011ee:	f012 0f45 	tst.w	r2, #69	; 0x45
 80011f2:	d0fb      	beq.n	80011ec <HAL_SD_Init+0x264>
  {
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 80011f4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80011f6:	0750      	lsls	r0, r2, #29
 80011f8:	d503      	bpl.n	8001202 <HAL_SD_Init+0x27a>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 80011fa:	2204      	movs	r2, #4
 80011fc:	639a      	str	r2, [r3, #56]	; 0x38
    
    return errorstate;
 80011fe:	2003      	movs	r0, #3
 8001200:	e049      	b.n	8001296 <HAL_SD_Init+0x30e>
  }
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
 8001202:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8001204:	f010 0501 	ands.w	r5, r0, #1
 8001208:	d002      	beq.n	8001210 <HAL_SD_Init+0x288>
  {
    errorstate = SD_CMD_CRC_FAIL;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 800120a:	2001      	movs	r0, #1
 800120c:	6398      	str	r0, [r3, #56]	; 0x38
 800120e:	e042      	b.n	8001296 <HAL_SD_Init+0x30e>
  {
    /* No error flag set */
  }
  
  /* Check response received is of desired command */
  if(SDIO_GetCommandResponse(hsd->Instance) != SD_CMD)
 8001210:	4618      	mov	r0, r3
 8001212:	f7ff fb62 	bl	80008da <SDIO_GetCommandResponse>
 8001216:	2803      	cmp	r0, #3
 8001218:	d179      	bne.n	800130e <HAL_SD_Init+0x386>
    
    return errorstate;
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 800121a:	6823      	ldr	r3, [r4, #0]
 800121c:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8001220:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* We have received response, retrieve it.  */
  response_r1 = SDIO_GetResponse(SDIO_RESP1);
 8001222:	4628      	mov	r0, r5
 8001224:	f7ff fb5c 	bl	80008e0 <SDIO_GetResponse>
  
  if((response_r1 & (SD_R6_GENERAL_UNKNOWN_ERROR | SD_R6_ILLEGAL_CMD | SD_R6_COM_CRC_FAILED)) == SD_ALLZERO)
 8001228:	f410 4f60 	tst.w	r0, #57344	; 0xe000
 800122c:	d104      	bne.n	8001238 <HAL_SD_Init+0x2b0>
  {
    *pRCA = (uint16_t) (response_r1 >> 16U);
 800122e:	0c00      	lsrs	r0, r0, #16
 8001230:	e009      	b.n	8001246 <HAL_SD_Init+0x2be>
 8001232:	bf00      	nop
 8001234:	422580a0 	.word	0x422580a0
    
    return errorstate;
  }
  
  if((response_r1 & SD_R6_GENERAL_UNKNOWN_ERROR) == SD_R6_GENERAL_UNKNOWN_ERROR)
 8001238:	0481      	lsls	r1, r0, #18
 800123a:	d46a      	bmi.n	8001312 <HAL_SD_Init+0x38a>
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
  }
  
  if((response_r1 & SD_R6_ILLEGAL_CMD) == SD_R6_ILLEGAL_CMD)
 800123c:	0442      	lsls	r2, r0, #17
 800123e:	d466      	bmi.n	800130e <HAL_SD_Init+0x386>
  {
    return(SD_ILLEGAL_CMD);
  }
  
  if((response_r1 & SD_R6_COM_CRC_FAILED) == SD_R6_COM_CRC_FAILED)
 8001240:	0403      	lsls	r3, r0, #16
 8001242:	d468      	bmi.n	8001316 <HAL_SD_Init+0x38e>
  */
static HAL_SD_ErrorTypedef SD_Initialize_Cards(SD_HandleTypeDef *hsd)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure; 
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint16_t sd_rca = 1U;
 8001244:	2001      	movs	r0, #1
    {
      return errorstate;
    }
  }
  
  if (hsd->CardType != SECURE_DIGITAL_IO_CARD)
 8001246:	6a23      	ldr	r3, [r4, #32]
 8001248:	2b04      	cmp	r3, #4
 800124a:	d021      	beq.n	8001290 <HAL_SD_Init+0x308>
  {
    /* Get the SD card RCA */
    hsd->RCA = sd_rca;
 800124c:	6260      	str	r0, [r4, #36]	; 0x24
    
    /* Send CMD9 SEND_CSD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_CSD;
 800124e:	2309      	movs	r3, #9
  {
    /* Get the SD card RCA */
    hsd->RCA = sd_rca;
    
    /* Send CMD9 SEND_CSD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 8001250:	0400      	lsls	r0, r0, #16
 8001252:	9005      	str	r0, [sp, #20]
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_CSD;
 8001254:	9306      	str	r3, [sp, #24]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001256:	a905      	add	r1, sp, #20
    hsd->RCA = sd_rca;
    
    /* Send CMD9 SEND_CSD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_CSD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
 8001258:	23c0      	movs	r3, #192	; 0xc0
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800125a:	6820      	ldr	r0, [r4, #0]
    hsd->RCA = sd_rca;
    
    /* Send CMD9 SEND_CSD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_CSD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
 800125c:	9307      	str	r3, [sp, #28]
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800125e:	f7ff fb29 	bl	80008b4 <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp2Error(hsd);
 8001262:	4620      	mov	r0, r4
 8001264:	f7ff fb5b 	bl	800091e <SD_CmdResp2Error>
    
    if(errorstate != SD_OK)
 8001268:	4605      	mov	r5, r0
 800126a:	b998      	cbnz	r0, 8001294 <HAL_SD_Init+0x30c>
    {
      return errorstate;
    }
    
    /* Get Card Specific Data */
    hsd->CSD[0U] = SDIO_GetResponse(SDIO_RESP1);
 800126c:	f7ff fb38 	bl	80008e0 <SDIO_GetResponse>
 8001270:	62a0      	str	r0, [r4, #40]	; 0x28
    hsd->CSD[1U] = SDIO_GetResponse(SDIO_RESP2);
 8001272:	2004      	movs	r0, #4
 8001274:	f7ff fb34 	bl	80008e0 <SDIO_GetResponse>
 8001278:	62e0      	str	r0, [r4, #44]	; 0x2c
    hsd->CSD[2U] = SDIO_GetResponse(SDIO_RESP3);
 800127a:	2008      	movs	r0, #8
 800127c:	f7ff fb30 	bl	80008e0 <SDIO_GetResponse>
 8001280:	6320      	str	r0, [r4, #48]	; 0x30
    hsd->CSD[3U] = SDIO_GetResponse(SDIO_RESP4);
 8001282:	200c      	movs	r0, #12
 8001284:	f7ff fb2c 	bl	80008e0 <SDIO_GetResponse>
 8001288:	6360      	str	r0, [r4, #52]	; 0x34
 800128a:	e003      	b.n	8001294 <HAL_SD_Init+0x30c>
  
  if(SDIO_GetPowerState(hsd->Instance) == 0U) /* Power off */
  {
    errorstate = SD_REQUEST_NOT_APPLICABLE;
    
    return errorstate;
 800128c:	2025      	movs	r0, #37	; 0x25
 800128e:	e002      	b.n	8001296 <HAL_SD_Init+0x30e>
    {
      return errorstate;
    }
  }
  
  if (hsd->CardType != SECURE_DIGITAL_IO_CARD)
 8001290:	2000      	movs	r0, #0
 8001292:	e000      	b.n	8001296 <HAL_SD_Init+0x30e>
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
    
    /* Check for error conditions */
    errorstate = SD_CmdResp2Error(hsd);
    
    if(errorstate != SD_OK)
 8001294:	4628      	mov	r0, r5
  {
    return errorstate;
  }
  
  /* Initialize the present SDIO card(s) and put them in idle state */
  errorstate = SD_Initialize_Cards(hsd);
 8001296:	f88d 0012 	strb.w	r0, [sp, #18]
  
  if (errorstate != SD_OK)
 800129a:	f89d 3012 	ldrb.w	r3, [sp, #18]
 800129e:	bb5b      	cbnz	r3, 80012f8 <HAL_SD_Init+0x370>
  {
    return errorstate;
  }
  
  /* Read CSD/CID MSD registers */
  errorstate = HAL_SD_Get_CardInfo(hsd, SDCardInfo);
 80012a0:	4620      	mov	r0, r4
 80012a2:	4631      	mov	r1, r6
 80012a4:	f7ff fd2b 	bl	8000cfe <HAL_SD_Get_CardInfo>
 80012a8:	f88d 0012 	strb.w	r0, [sp, #18]
  
  if (errorstate == SD_OK)
 80012ac:	f89d 3012 	ldrb.w	r3, [sp, #18]
 80012b0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80012b4:	b9ab      	cbnz	r3, 80012e2 <HAL_SD_Init+0x35a>
  {
    /* Select the Card */
    errorstate = SD_Select_Deselect(hsd, (uint32_t)(((uint32_t)SDCardInfo->RCA) << 16U));
 80012b6:	f8b6 3054 	ldrh.w	r3, [r6, #84]	; 0x54
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80012ba:	6820      	ldr	r0, [r4, #0]
  
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80012bc:	9208      	str	r2, [sp, #32]
  errorstate = HAL_SD_Get_CardInfo(hsd, SDCardInfo);
  
  if (errorstate == SD_OK)
  {
    /* Select the Card */
    errorstate = SD_Select_Deselect(hsd, (uint32_t)(((uint32_t)SDCardInfo->RCA) << 16U));
 80012be:	041b      	lsls	r3, r3, #16
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
 80012c0:	9305      	str	r3, [sp, #20]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80012c2:	2340      	movs	r3, #64	; 0x40
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
 80012c4:	2507      	movs	r5, #7
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80012c6:	9307      	str	r3, [sp, #28]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80012c8:	a905      	add	r1, sp, #20
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80012ca:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80012ce:	9309      	str	r3, [sp, #36]	; 0x24
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
 80012d0:	9506      	str	r5, [sp, #24]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80012d2:	f7ff faef 	bl	80008b4 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SEL_DESEL_CARD);
 80012d6:	4620      	mov	r0, r4
 80012d8:	4629      	mov	r1, r5
 80012da:	f7ff fbd9 	bl	8000a90 <SD_CmdResp1Error>
  errorstate = HAL_SD_Get_CardInfo(hsd, SDCardInfo);
  
  if (errorstate == SD_OK)
  {
    /* Select the Card */
    errorstate = SD_Select_Deselect(hsd, (uint32_t)(((uint32_t)SDCardInfo->RCA) << 16U));
 80012de:	f88d 0012 	strb.w	r0, [sp, #18]
  }
  
  /* Configure SDIO peripheral interface */
  SDIO_Init(hsd->Instance, hsd->Init);   
 80012e2:	f104 0310 	add.w	r3, r4, #16
 80012e6:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80012ea:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 80012ee:	1d23      	adds	r3, r4, #4
 80012f0:	cb0e      	ldmia	r3, {r1, r2, r3}
 80012f2:	6820      	ldr	r0, [r4, #0]
 80012f4:	f7ff fab2 	bl	800085c <SDIO_Init>
  
  return errorstate;
 80012f8:	f89d 0012 	ldrb.w	r0, [sp, #18]
 80012fc:	b2c0      	uxtb	r0, r0
}
 80012fe:	b011      	add	sp, #68	; 0x44
 8001300:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    errorstate = SD_CMD_RSP_TIMEOUT;
    return errorstate;
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8001304:	f240 53ff 	movw	r3, #1535	; 0x5ff
 8001308:	6383      	str	r3, [r0, #56]	; 0x38
  
  return errorstate;
 800130a:	2300      	movs	r3, #0
 800130c:	e67e      	b.n	800100c <HAL_SD_Init+0x84>
  /* Check response received is of desired command */
  if(SDIO_GetCommandResponse(hsd->Instance) != SD_CMD)
  {
    errorstate = SD_ILLEGAL_CMD;
    
    return errorstate;
 800130e:	2010      	movs	r0, #16
 8001310:	e7c1      	b.n	8001296 <HAL_SD_Init+0x30e>
    return errorstate;
  }
  
  if((response_r1 & SD_R6_GENERAL_UNKNOWN_ERROR) == SD_R6_GENERAL_UNKNOWN_ERROR)
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
 8001312:	2013      	movs	r0, #19
 8001314:	e7bf      	b.n	8001296 <HAL_SD_Init+0x30e>
    return(SD_ILLEGAL_CMD);
  }
  
  if((response_r1 & SD_R6_COM_CRC_FAILED) == SD_R6_COM_CRC_FAILED)
  {
    return(SD_COM_CRC_FAILED);
 8001316:	200f      	movs	r0, #15
 8001318:	e7bd      	b.n	8001296 <HAL_SD_Init+0x30e>
 800131a:	bf00      	nop

0800131c <HAL_SD_WideBusOperation_Config>:
  *            @arg SDIO_BUS_WIDE_4B: 4-bit data transfer
  *            @arg SDIO_BUS_WIDE_1B: 1-bit data transfer
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_WideBusOperation_Config(SD_HandleTypeDef *hsd, uint32_t WideMode)
{
 800131c:	b5f0      	push	{r4, r5, r6, r7, lr}
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  SDIO_InitTypeDef tmpinit;
  
  /* MMC Card does not support this feature */
  if (hsd->CardType == MULTIMEDIA_CARD)
 800131e:	6a03      	ldr	r3, [r0, #32]
 8001320:	2b03      	cmp	r3, #3
  *            @arg SDIO_BUS_WIDE_4B: 4-bit data transfer
  *            @arg SDIO_BUS_WIDE_1B: 1-bit data transfer
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_WideBusOperation_Config(SD_HandleTypeDef *hsd, uint32_t WideMode)
{
 8001322:	b08d      	sub	sp, #52	; 0x34
 8001324:	4604      	mov	r4, r0
 8001326:	460e      	mov	r6, r1
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  SDIO_InitTypeDef tmpinit;
  
  /* MMC Card does not support this feature */
  if (hsd->CardType == MULTIMEDIA_CARD)
 8001328:	f000 8084 	beq.w	8001434 <HAL_SD_WideBusOperation_Config+0x118>
  {
    errorstate = SD_UNSUPPORTED_FEATURE;
    
    return errorstate;
  }
  else if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
 800132c:	2b02      	cmp	r3, #2
 800132e:	f200 8083 	bhi.w	8001438 <HAL_SD_WideBusOperation_Config+0x11c>
    (hsd->CardType == HIGH_CAPACITY_SD_CARD))
  {
    if (WideMode == SDIO_BUS_WIDE_8B)
 8001332:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 8001336:	f000 8081 	beq.w	800143c <HAL_SD_WideBusOperation_Config+0x120>
    {
      errorstate = SD_UNSUPPORTED_FEATURE;
    }
    else if (WideMode == SDIO_BUS_WIDE_4B)
 800133a:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
 800133e:	d129      	bne.n	8001394 <HAL_SD_WideBusOperation_Config+0x78>
static HAL_SD_ErrorTypedef SD_WideBus_Enable(SD_HandleTypeDef *hsd)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  uint32_t scr[2U] = {0U, 0U};
 8001340:	2000      	movs	r0, #0
 8001342:	9004      	str	r0, [sp, #16]
 8001344:	9005      	str	r0, [sp, #20]
  
  if((SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
 8001346:	f7ff facb 	bl	80008e0 <SDIO_GetResponse>
 800134a:	0180      	lsls	r0, r0, #6
 800134c:	d46e      	bmi.n	800142c <HAL_SD_WideBusOperation_Config+0x110>
    
    return errorstate;
  }
  
  /* Get SCR Register */
  errorstate = SD_FindSCR(hsd, scr);
 800134e:	4620      	mov	r0, r4
 8001350:	a904      	add	r1, sp, #16
 8001352:	f7ff fc15 	bl	8000b80 <SD_FindSCR>
  
  if(errorstate != SD_OK)
 8001356:	4605      	mov	r5, r0
 8001358:	2800      	cmp	r0, #0
 800135a:	d172      	bne.n	8001442 <HAL_SD_WideBusOperation_Config+0x126>
  {
    return errorstate;
  }
  
  /* If requested card supports wide bus operation */
  if((scr[1U] & SD_WIDE_BUS_SUPPORT) != SD_ALLZERO)
 800135c:	9b05      	ldr	r3, [sp, #20]
 800135e:	0359      	lsls	r1, r3, #13
 8001360:	d566      	bpl.n	8001430 <HAL_SD_WideBusOperation_Config+0x114>
  {
    /* Send CMD55 APP_CMD with argument as card's RCA.*/
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 8001362:	6a63      	ldr	r3, [r4, #36]	; 0x24
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8001364:	9009      	str	r0, [sp, #36]	; 0x24
  
  /* If requested card supports wide bus operation */
  if((scr[1U] & SD_WIDE_BUS_SUPPORT) != SD_ALLZERO)
  {
    /* Send CMD55 APP_CMD with argument as card's RCA.*/
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 8001366:	041b      	lsls	r3, r3, #16
 8001368:	9306      	str	r3, [sp, #24]
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 800136a:	2340      	movs	r3, #64	; 0x40
  /* If requested card supports wide bus operation */
  if((scr[1U] & SD_WIDE_BUS_SUPPORT) != SD_ALLZERO)
  {
    /* Send CMD55 APP_CMD with argument as card's RCA.*/
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 800136c:	2737      	movs	r7, #55	; 0x37
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 800136e:	9308      	str	r3, [sp, #32]
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001370:	a906      	add	r1, sp, #24
    /* Send CMD55 APP_CMD with argument as card's RCA.*/
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8001372:	f44f 6380 	mov.w	r3, #1024	; 0x400
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001376:	6820      	ldr	r0, [r4, #0]
    /* Send CMD55 APP_CMD with argument as card's RCA.*/
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8001378:	930a      	str	r3, [sp, #40]	; 0x28
  /* If requested card supports wide bus operation */
  if((scr[1U] & SD_WIDE_BUS_SUPPORT) != SD_ALLZERO)
  {
    /* Send CMD55 APP_CMD with argument as card's RCA.*/
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 800137a:	9707      	str	r7, [sp, #28]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800137c:	f7ff fa9a 	bl	80008b4 <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 8001380:	4620      	mov	r0, r4
 8001382:	4639      	mov	r1, r7
 8001384:	f7ff fb84 	bl	8000a90 <SD_CmdResp1Error>
    
    if(errorstate != SD_OK)
 8001388:	4605      	mov	r5, r0
 800138a:	2800      	cmp	r0, #0
 800138c:	d159      	bne.n	8001442 <HAL_SD_WideBusOperation_Config+0x126>
    {
      return errorstate;
    }
    
    /* Send ACMD6 APP_CMD with argument as 2 for wide bus mode */
    sdio_cmdinitstructure.Argument         = 2U;
 800138e:	2302      	movs	r3, #2
 8001390:	9306      	str	r3, [sp, #24]
 8001392:	e029      	b.n	80013e8 <HAL_SD_WideBusOperation_Config+0xcc>
    }
    else if (WideMode == SDIO_BUS_WIDE_4B)
    {
      errorstate = SD_WideBus_Enable(hsd);
    }
    else if (WideMode == SDIO_BUS_WIDE_1B)
 8001394:	2900      	cmp	r1, #0
 8001396:	d153      	bne.n	8001440 <HAL_SD_WideBusOperation_Config+0x124>
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  uint32_t scr[2U] = {0U, 0U};
  
  if((SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
 8001398:	4608      	mov	r0, r1
static HAL_SD_ErrorTypedef SD_WideBus_Disable(SD_HandleTypeDef *hsd)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  uint32_t scr[2U] = {0U, 0U};
 800139a:	9104      	str	r1, [sp, #16]
 800139c:	9105      	str	r1, [sp, #20]
  
  if((SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
 800139e:	f7ff fa9f 	bl	80008e0 <SDIO_GetResponse>
 80013a2:	0182      	lsls	r2, r0, #6
 80013a4:	d442      	bmi.n	800142c <HAL_SD_WideBusOperation_Config+0x110>
    
    return errorstate;
  }
  
  /* Get SCR Register */
  errorstate = SD_FindSCR(hsd, scr);
 80013a6:	4620      	mov	r0, r4
 80013a8:	a904      	add	r1, sp, #16
 80013aa:	f7ff fbe9 	bl	8000b80 <SD_FindSCR>
  
  if(errorstate != SD_OK)
 80013ae:	4605      	mov	r5, r0
 80013b0:	2800      	cmp	r0, #0
 80013b2:	d146      	bne.n	8001442 <HAL_SD_WideBusOperation_Config+0x126>
  {
    return errorstate;
  }
  
  /* If requested card supports 1 bit mode operation */
  if((scr[1U] & SD_SINGLE_BUS_SUPPORT) != SD_ALLZERO)
 80013b4:	9b05      	ldr	r3, [sp, #20]
 80013b6:	03db      	lsls	r3, r3, #15
 80013b8:	d53a      	bpl.n	8001430 <HAL_SD_WideBusOperation_Config+0x114>
  {
    /* Send CMD55 APP_CMD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 80013ba:	6a63      	ldr	r3, [r4, #36]	; 0x24
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80013bc:	9009      	str	r0, [sp, #36]	; 0x24
  
  /* If requested card supports 1 bit mode operation */
  if((scr[1U] & SD_SINGLE_BUS_SUPPORT) != SD_ALLZERO)
  {
    /* Send CMD55 APP_CMD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 80013be:	041b      	lsls	r3, r3, #16
 80013c0:	9306      	str	r3, [sp, #24]
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80013c2:	2340      	movs	r3, #64	; 0x40
  /* If requested card supports 1 bit mode operation */
  if((scr[1U] & SD_SINGLE_BUS_SUPPORT) != SD_ALLZERO)
  {
    /* Send CMD55 APP_CMD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 80013c4:	2737      	movs	r7, #55	; 0x37
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80013c6:	9308      	str	r3, [sp, #32]
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80013c8:	a906      	add	r1, sp, #24
    /* Send CMD55 APP_CMD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80013ca:	f44f 6380 	mov.w	r3, #1024	; 0x400
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80013ce:	6820      	ldr	r0, [r4, #0]
    /* Send CMD55 APP_CMD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80013d0:	930a      	str	r3, [sp, #40]	; 0x28
  /* If requested card supports 1 bit mode operation */
  if((scr[1U] & SD_SINGLE_BUS_SUPPORT) != SD_ALLZERO)
  {
    /* Send CMD55 APP_CMD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 80013d2:	9707      	str	r7, [sp, #28]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80013d4:	f7ff fa6e 	bl	80008b4 <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 80013d8:	4620      	mov	r0, r4
 80013da:	4639      	mov	r1, r7
 80013dc:	f7ff fb58 	bl	8000a90 <SD_CmdResp1Error>
    
    if(errorstate != SD_OK)
 80013e0:	4605      	mov	r5, r0
 80013e2:	2800      	cmp	r0, #0
 80013e4:	d12d      	bne.n	8001442 <HAL_SD_WideBusOperation_Config+0x126>
    {
      return errorstate;
    }
    
    /* Send ACMD6 APP_CMD with argument as 0 for single bus mode */
    sdio_cmdinitstructure.Argument         = 0U;
 80013e6:	9006      	str	r0, [sp, #24]
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_SD_SET_BUSWIDTH;
 80013e8:	2506      	movs	r5, #6
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80013ea:	a906      	add	r1, sp, #24
 80013ec:	6820      	ldr	r0, [r4, #0]
      return errorstate;
    }
    
    /* Send ACMD6 APP_CMD with argument as 0 for single bus mode */
    sdio_cmdinitstructure.Argument         = 0U;
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_SD_SET_BUSWIDTH;
 80013ee:	9507      	str	r5, [sp, #28]
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80013f0:	f7ff fa60 	bl	80008b4 <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_SD_SET_BUSWIDTH);
 80013f4:	4629      	mov	r1, r5
 80013f6:	4620      	mov	r0, r4
 80013f8:	f7ff fb4a 	bl	8000a90 <SD_CmdResp1Error>
 80013fc:	4605      	mov	r5, r0
    {
      /* WideMode is not a valid argument*/
      errorstate = SD_INVALID_PARAMETER;
    }
      
    if (errorstate == SD_OK)
 80013fe:	bb00      	cbnz	r0, 8001442 <HAL_SD_WideBusOperation_Config+0x126>
    {
      /* Configure the SDIO peripheral */
      tmpinit.ClockEdge           = hsd->Init.ClockEdge;
 8001400:	6863      	ldr	r3, [r4, #4]
 8001402:	9306      	str	r3, [sp, #24]
      tmpinit.ClockBypass         = hsd->Init.ClockBypass;
 8001404:	68a3      	ldr	r3, [r4, #8]
 8001406:	9307      	str	r3, [sp, #28]
      tmpinit.ClockPowerSave      = hsd->Init.ClockPowerSave;
 8001408:	68e3      	ldr	r3, [r4, #12]
 800140a:	9308      	str	r3, [sp, #32]
      tmpinit.BusWide             = WideMode;
      tmpinit.HardwareFlowControl = hsd->Init.HardwareFlowControl;
 800140c:	6963      	ldr	r3, [r4, #20]
 800140e:	930a      	str	r3, [sp, #40]	; 0x28
      tmpinit.ClockDiv            = hsd->Init.ClockDiv;
 8001410:	69a3      	ldr	r3, [r4, #24]
 8001412:	930b      	str	r3, [sp, #44]	; 0x2c
    {
      /* Configure the SDIO peripheral */
      tmpinit.ClockEdge           = hsd->Init.ClockEdge;
      tmpinit.ClockBypass         = hsd->Init.ClockBypass;
      tmpinit.ClockPowerSave      = hsd->Init.ClockPowerSave;
      tmpinit.BusWide             = WideMode;
 8001414:	9609      	str	r6, [sp, #36]	; 0x24
      tmpinit.HardwareFlowControl = hsd->Init.HardwareFlowControl;
      tmpinit.ClockDiv            = hsd->Init.ClockDiv;
      SDIO_Init(hsd->Instance, tmpinit);
 8001416:	ab0c      	add	r3, sp, #48	; 0x30
 8001418:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 800141c:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 8001420:	ab06      	add	r3, sp, #24
 8001422:	cb0e      	ldmia	r3, {r1, r2, r3}
 8001424:	6820      	ldr	r0, [r4, #0]
 8001426:	f7ff fa19 	bl	800085c <SDIO_Init>
 800142a:	e00a      	b.n	8001442 <HAL_SD_WideBusOperation_Config+0x126>
  
  if((SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
  {
    errorstate = SD_LOCK_UNLOCK_FAILED;
    
    return errorstate;
 800142c:	250e      	movs	r5, #14
 800142e:	e008      	b.n	8001442 <HAL_SD_WideBusOperation_Config+0x126>
  }
  else
  {
    errorstate = SD_REQUEST_NOT_APPLICABLE;
    
    return errorstate;
 8001430:	2525      	movs	r5, #37	; 0x25
 8001432:	e006      	b.n	8001442 <HAL_SD_WideBusOperation_Config+0x126>
  /* MMC Card does not support this feature */
  if (hsd->CardType == MULTIMEDIA_CARD)
  {
    errorstate = SD_UNSUPPORTED_FEATURE;
    
    return errorstate;
 8001434:	2027      	movs	r0, #39	; 0x27
 8001436:	e005      	b.n	8001444 <HAL_SD_WideBusOperation_Config+0x128>
  *            @arg SDIO_BUS_WIDE_1B: 1-bit data transfer
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_WideBusOperation_Config(SD_HandleTypeDef *hsd, uint32_t WideMode)
{
  HAL_SD_ErrorTypedef errorstate = SD_OK;
 8001438:	2000      	movs	r0, #0
 800143a:	e003      	b.n	8001444 <HAL_SD_WideBusOperation_Config+0x128>
  else if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
    (hsd->CardType == HIGH_CAPACITY_SD_CARD))
  {
    if (WideMode == SDIO_BUS_WIDE_8B)
    {
      errorstate = SD_UNSUPPORTED_FEATURE;
 800143c:	2527      	movs	r5, #39	; 0x27
 800143e:	e000      	b.n	8001442 <HAL_SD_WideBusOperation_Config+0x126>
      errorstate = SD_WideBus_Disable(hsd);
    }
    else
    {
      /* WideMode is not a valid argument*/
      errorstate = SD_INVALID_PARAMETER;
 8001440:	2526      	movs	r5, #38	; 0x26
  /* MMC Card does not support this feature */
  if (hsd->CardType == MULTIMEDIA_CARD)
  {
    errorstate = SD_UNSUPPORTED_FEATURE;
    
    return errorstate;
 8001442:	4628      	mov	r0, r5
      SDIO_Init(hsd->Instance, tmpinit);
    }
  }
  
  return errorstate;
}
 8001444:	b00d      	add	sp, #52	; 0x34
 8001446:	bdf0      	pop	{r4, r5, r6, r7, pc}

08001448 <HAL_SD_StopTransfer>:
  * @brief  Aborts an ongoing data transfer.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_StopTransfer(SD_HandleTypeDef *hsd)
{
 8001448:	b530      	push	{r4, r5, lr}
 800144a:	b087      	sub	sp, #28
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
 800144c:	2300      	movs	r3, #0
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 800144e:	2240      	movs	r2, #64	; 0x40
  * @brief  Aborts an ongoing data transfer.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_StopTransfer(SD_HandleTypeDef *hsd)
{
 8001450:	4605      	mov	r5, r0
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
 8001452:	9301      	str	r3, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
 8001454:	240c      	movs	r4, #12
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8001456:	9304      	str	r3, [sp, #16]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001458:	a901      	add	r1, sp, #4
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 800145a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800145e:	6800      	ldr	r0, [r0, #0]
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8001460:	9203      	str	r2, [sp, #12]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8001462:	9305      	str	r3, [sp, #20]
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
 8001464:	9402      	str	r4, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001466:	f7ff fa25 	bl	80008b4 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_STOP_TRANSMISSION);
 800146a:	4628      	mov	r0, r5
 800146c:	4621      	mov	r1, r4
 800146e:	f7ff fb0f 	bl	8000a90 <SD_CmdResp1Error>
  
  return errorstate;
}
 8001472:	b007      	add	sp, #28
 8001474:	bd30      	pop	{r4, r5, pc}

08001476 <HAL_SD_ReadBlocks>:
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 8001476:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800147a:	4606      	mov	r6, r0
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t count = 0U, *tempbuff = (uint32_t *)pReadBuffer;
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
 800147c:	6800      	ldr	r0, [r0, #0]
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 800147e:	461d      	mov	r5, r3
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t count = 0U, *tempbuff = (uint32_t *)pReadBuffer;
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
 8001480:	2300      	movs	r3, #0
 8001482:	62c3      	str	r3, [r0, #44]	; 0x2c
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
 8001484:	6a33      	ldr	r3, [r6, #32]
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 8001486:	b08c      	sub	sp, #48	; 0x30
  uint32_t count = 0U, *tempbuff = (uint32_t *)pReadBuffer;
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
 8001488:	2b02      	cmp	r3, #2
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 800148a:	460f      	mov	r7, r1
 800148c:	4614      	mov	r4, r2
 800148e:	f8dd a050 	ldr.w	sl, [sp, #80]	; 0x50
 8001492:	f8dd 9054 	ldr.w	r9, [sp, #84]	; 0x54
  uint32_t count = 0U, *tempbuff = (uint32_t *)pReadBuffer;
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
 8001496:	d105      	bne.n	80014a4 <HAL_SD_ReadBlocks+0x2e>
  {
    BlockSize = 512U;
    ReadAddr /= 512U;
 8001498:	0a52      	lsrs	r2, r2, #9
 800149a:	ea42 52c5 	orr.w	r2, r2, r5, lsl #23
 800149e:	4614      	mov	r4, r2
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
  {
    BlockSize = 512U;
 80014a0:	f44f 7a00 	mov.w	sl, #512	; 0x200
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80014a4:	2340      	movs	r3, #64	; 0x40
 80014a6:	9303      	str	r3, [sp, #12]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80014a8:	2300      	movs	r3, #0
    ReadAddr /= 512U;
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 80014aa:	f04f 0810 	mov.w	r8, #16
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80014ae:	9304      	str	r3, [sp, #16]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80014b0:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80014b2:	f44f 6380 	mov.w	r3, #1024	; 0x400
    ReadAddr /= 512U;
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 80014b6:	f8cd 8008 	str.w	r8, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80014ba:	9305      	str	r3, [sp, #20]
    BlockSize = 512U;
    ReadAddr /= 512U;
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
 80014bc:	f8cd a004 	str.w	sl, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80014c0:	f7ff f9f8 	bl	80008b4 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
 80014c4:	4641      	mov	r1, r8
 80014c6:	4630      	mov	r0, r6
 80014c8:	f7ff fae2 	bl	8000a90 <SD_CmdResp1Error>
  
  if (errorstate != SD_OK)
 80014cc:	4680      	mov	r8, r0
 80014ce:	2800      	cmp	r0, #0
 80014d0:	f040 8088 	bne.w	80015e4 <HAL_SD_ReadBlocks+0x16e>
  {
    return errorstate;
  }
  
  /* Configure the SD DPSM (Data Path State Machine) */
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
 80014d4:	f04f 33ff 	mov.w	r3, #4294967295
 80014d8:	9306      	str	r3, [sp, #24]
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
 80014da:	fb09 f30a 	mul.w	r3, r9, sl
 80014de:	9307      	str	r3, [sp, #28]
  sdio_datainitstructure.DataBlockSize = DATA_BLOCK_SIZE;
 80014e0:	2390      	movs	r3, #144	; 0x90
 80014e2:	9308      	str	r3, [sp, #32]
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
 80014e4:	2302      	movs	r3, #2
 80014e6:	9309      	str	r3, [sp, #36]	; 0x24
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 80014e8:	900a      	str	r0, [sp, #40]	; 0x28
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 80014ea:	2301      	movs	r3, #1
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 80014ec:	a906      	add	r1, sp, #24
 80014ee:	6830      	ldr	r0, [r6, #0]
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
  sdio_datainitstructure.DataBlockSize = DATA_BLOCK_SIZE;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 80014f0:	930b      	str	r3, [sp, #44]	; 0x2c
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 80014f2:	f7ff fa01 	bl	80008f8 <SDIO_DataConfig>
  
  if(NumberOfBlocks > 1U)
 80014f6:	f1b9 0f01 	cmp.w	r9, #1
  {
    /* Send CMD18 READ_MULT_BLOCK with argument data address */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_MULT_BLOCK;
 80014fa:	bf8c      	ite	hi
 80014fc:	2312      	movhi	r3, #18
  }
  else
  {
    /* Send CMD17 READ_SINGLE_BLOCK */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_SINGLE_BLOCK;    
 80014fe:	2311      	movls	r3, #17
  }
  
  sdio_cmdinitstructure.Argument         = (uint32_t)ReadAddr;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001500:	6830      	ldr	r0, [r6, #0]
    sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_MULT_BLOCK;
  }
  else
  {
    /* Send CMD17 READ_SINGLE_BLOCK */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_SINGLE_BLOCK;    
 8001502:	9302      	str	r3, [sp, #8]
  }
  
  sdio_cmdinitstructure.Argument         = (uint32_t)ReadAddr;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001504:	a901      	add	r1, sp, #4
  {
    /* Send CMD17 READ_SINGLE_BLOCK */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_SINGLE_BLOCK;    
  }
  
  sdio_cmdinitstructure.Argument         = (uint32_t)ReadAddr;
 8001506:	9401      	str	r4, [sp, #4]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001508:	f7ff f9d4 	bl	80008b4 <SDIO_SendCommand>
  
  /* Read block(s) in polling mode */
  if(NumberOfBlocks > 1U)
 800150c:	f1b9 0f01 	cmp.w	r9, #1
  {
    /* Check for error conditions */
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_READ_MULT_BLOCK);
 8001510:	4630      	mov	r0, r6
  
  sdio_cmdinitstructure.Argument         = (uint32_t)ReadAddr;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
  
  /* Read block(s) in polling mode */
  if(NumberOfBlocks > 1U)
 8001512:	d916      	bls.n	8001542 <HAL_SD_ReadBlocks+0xcc>
  {
    /* Check for error conditions */
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_READ_MULT_BLOCK);
 8001514:	2112      	movs	r1, #18
 8001516:	f7ff fabb 	bl	8000a90 <SD_CmdResp1Error>
    
    if (errorstate != SD_OK)
 800151a:	2800      	cmp	r0, #0
 800151c:	d163      	bne.n	80015e6 <HAL_SD_ReadBlocks+0x170>
      return errorstate;
    }
    
    /* Poll on SDIO flags */
#ifdef SDIO_STA_STBITERR
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND | SDIO_FLAG_STBITERR))
 800151e:	6833      	ldr	r3, [r6, #0]
 8001520:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001522:	f240 342a 	movw	r4, #810	; 0x32a
 8001526:	4014      	ands	r4, r2
 8001528:	bb14      	cbnz	r4, 8001570 <HAL_SD_ReadBlocks+0xfa>
#else /* SDIO_STA_STBITERR not defined */
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND))
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
 800152a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800152c:	0411      	lsls	r1, r2, #16
 800152e:	d5f7      	bpl.n	8001520 <HAL_SD_ReadBlocks+0xaa>
      {
        /* Read data from SDIO Rx FIFO */
        for (count = 0U; count < 8U; count++)
        {
          *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
 8001530:	6830      	ldr	r0, [r6, #0]
 8001532:	f7ff f9af 	bl	8000894 <SDIO_ReadFIFO>
 8001536:	5138      	str	r0, [r7, r4]
 8001538:	3404      	adds	r4, #4
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
      {
        /* Read data from SDIO Rx FIFO */
        for (count = 0U; count < 8U; count++)
 800153a:	2c20      	cmp	r4, #32
 800153c:	d1f8      	bne.n	8001530 <HAL_SD_ReadBlocks+0xba>
        {
          *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
        }
        
        tempbuff += 8U;
 800153e:	3720      	adds	r7, #32
 8001540:	e7ed      	b.n	800151e <HAL_SD_ReadBlocks+0xa8>
    }      
  }
  else
  {
    /* Check for error conditions */
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_READ_SINGLE_BLOCK); 
 8001542:	2111      	movs	r1, #17
 8001544:	f7ff faa4 	bl	8000a90 <SD_CmdResp1Error>
    
    if (errorstate != SD_OK)
 8001548:	2800      	cmp	r0, #0
 800154a:	d14c      	bne.n	80015e6 <HAL_SD_ReadBlocks+0x170>
      return errorstate;
    }    
    
    /* In case of single block transfer, no need of stop transfer at all */
#ifdef SDIO_STA_STBITERR
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
 800154c:	6833      	ldr	r3, [r6, #0]
 800154e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001550:	f240 642a 	movw	r4, #1578	; 0x62a
 8001554:	4014      	ands	r4, r2
 8001556:	b95c      	cbnz	r4, 8001570 <HAL_SD_ReadBlocks+0xfa>
#else /* SDIO_STA_STBITERR not defined */
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))      
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
 8001558:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800155a:	0412      	lsls	r2, r2, #16
 800155c:	d5f7      	bpl.n	800154e <HAL_SD_ReadBlocks+0xd8>
      {
        /* Read data from SDIO Rx FIFO */
        for (count = 0U; count < 8U; count++)
        {
          *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
 800155e:	6830      	ldr	r0, [r6, #0]
 8001560:	f7ff f998 	bl	8000894 <SDIO_ReadFIFO>
 8001564:	5138      	str	r0, [r7, r4]
 8001566:	3404      	adds	r4, #4
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
      {
        /* Read data from SDIO Rx FIFO */
        for (count = 0U; count < 8U; count++)
 8001568:	2c20      	cmp	r4, #32
 800156a:	d1f8      	bne.n	800155e <HAL_SD_ReadBlocks+0xe8>
        {
          *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
        }
        
        tempbuff += 8U;
 800156c:	3720      	adds	r7, #32
 800156e:	e7ed      	b.n	800154c <HAL_SD_ReadBlocks+0xd6>
      }
    }
  }
  
  /* Send stop transmission command in case of multiblock read */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 8001570:	6833      	ldr	r3, [r6, #0]
 8001572:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001574:	05dd      	lsls	r5, r3, #23
 8001576:	d509      	bpl.n	800158c <HAL_SD_ReadBlocks+0x116>
 8001578:	f1b9 0f01 	cmp.w	r9, #1
 800157c:	d906      	bls.n	800158c <HAL_SD_ReadBlocks+0x116>
  {    
    if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) ||\
 800157e:	6a33      	ldr	r3, [r6, #32]
 8001580:	2b02      	cmp	r3, #2
 8001582:	d803      	bhi.n	800158c <HAL_SD_ReadBlocks+0x116>
      (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
        (hsd->CardType == HIGH_CAPACITY_SD_CARD))
    {
      /* Send stop transmission command */
      errorstate = HAL_SD_StopTransfer(hsd);
 8001584:	4630      	mov	r0, r6
 8001586:	f7ff ff5f 	bl	8001448 <HAL_SD_StopTransfer>
 800158a:	4680      	mov	r8, r0
    }
  }
  
  /* Get error state */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
 800158c:	6833      	ldr	r3, [r6, #0]
 800158e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001590:	0714      	lsls	r4, r2, #28
 8001592:	d503      	bpl.n	800159c <HAL_SD_ReadBlocks+0x126>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
 8001594:	2208      	movs	r2, #8
 8001596:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_TIMEOUT;
    
    return errorstate;
 8001598:	2004      	movs	r0, #4
 800159a:	e024      	b.n	80015e6 <HAL_SD_ReadBlocks+0x170>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
 800159c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800159e:	0790      	lsls	r0, r2, #30
 80015a0:	d502      	bpl.n	80015a8 <HAL_SD_ReadBlocks+0x132>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
 80015a2:	2002      	movs	r0, #2
 80015a4:	6398      	str	r0, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_CRC_FAIL;
    
    return errorstate;
 80015a6:	e01e      	b.n	80015e6 <HAL_SD_ReadBlocks+0x170>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
 80015a8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80015aa:	0691      	lsls	r1, r2, #26
 80015ac:	d503      	bpl.n	80015b6 <HAL_SD_ReadBlocks+0x140>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
 80015ae:	2220      	movs	r2, #32
 80015b0:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_RX_OVERRUN;
    
    return errorstate;
 80015b2:	2006      	movs	r0, #6
 80015b4:	e017      	b.n	80015e6 <HAL_SD_ReadBlocks+0x170>
  }
#ifdef SDIO_STA_STBITERR
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
 80015b6:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 80015b8:	f414 7400 	ands.w	r4, r4, #512	; 0x200
 80015bc:	d00b      	beq.n	80015d6 <HAL_SD_ReadBlocks+0x160>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
 80015be:	f44f 7200 	mov.w	r2, #512	; 0x200
 80015c2:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_START_BIT_ERR;
    
    return errorstate;
 80015c4:	2007      	movs	r0, #7
 80015c6:	e00e      	b.n	80015e6 <HAL_SD_ReadBlocks+0x170>
  }
  
  count = SD_DATATIMEOUT;
  
  /* Empty FIFO if there is still any data */
  while ((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)) && (count > 0U))
 80015c8:	1c63      	adds	r3, r4, #1
 80015ca:	d008      	beq.n	80015de <HAL_SD_ReadBlocks+0x168>
  {
    *tempbuff = SDIO_ReadFIFO(hsd->Instance);
 80015cc:	f7ff f962 	bl	8000894 <SDIO_ReadFIFO>
 80015d0:	f847 0024 	str.w	r0, [r7, r4, lsl #2]
 80015d4:	3401      	adds	r4, #1
  }
  
  count = SD_DATATIMEOUT;
  
  /* Empty FIFO if there is still any data */
  while ((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)) && (count > 0U))
 80015d6:	6830      	ldr	r0, [r6, #0]
 80015d8:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80015da:	029a      	lsls	r2, r3, #10
 80015dc:	d4f4      	bmi.n	80015c8 <HAL_SD_ReadBlocks+0x152>
    tempbuff++;
    count--;
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80015de:	f240 53ff 	movw	r3, #1535	; 0x5ff
 80015e2:	6383      	str	r3, [r0, #56]	; 0x38
 80015e4:	4640      	mov	r0, r8
  
  return errorstate;
}
 80015e6:	b00c      	add	sp, #48	; 0x30
 80015e8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080015ec <HAL_SD_WriteBlocks>:
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to write 
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, uint32_t *pWriteBuffer, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 80015ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80015f0:	4606      	mov	r6, r0
 80015f2:	b08c      	sub	sp, #48	; 0x30
  uint32_t totalnumberofbytes = 0U, bytestransferred = 0U, count = 0U, restwords = 0U;
  uint32_t *tempbuff = (uint32_t *)pWriteBuffer;
  uint8_t cardstate  = 0U;
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
 80015f4:	6800      	ldr	r0, [r0, #0]
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to write 
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, uint32_t *pWriteBuffer, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 80015f6:	f8dd 9050 	ldr.w	r9, [sp, #80]	; 0x50
 80015fa:	f8dd 8054 	ldr.w	r8, [sp, #84]	; 0x54
 80015fe:	461d      	mov	r5, r3
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t totalnumberofbytes = 0U, bytestransferred = 0U, count = 0U, restwords = 0U;
  uint32_t *tempbuff = (uint32_t *)pWriteBuffer;
  uint8_t cardstate  = 0U;
 8001600:	2300      	movs	r3, #0
 8001602:	f88d 3003 	strb.w	r3, [sp, #3]
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
 8001606:	62c3      	str	r3, [r0, #44]	; 0x2c
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
 8001608:	6a33      	ldr	r3, [r6, #32]
 800160a:	2b02      	cmp	r3, #2
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to write 
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, uint32_t *pWriteBuffer, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 800160c:	460f      	mov	r7, r1
 800160e:	4614      	mov	r4, r2
  uint8_t cardstate  = 0U;
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
 8001610:	d105      	bne.n	800161e <HAL_SD_WriteBlocks+0x32>
  {
    BlockSize = 512U;
    WriteAddr /= 512U;
 8001612:	0a52      	lsrs	r2, r2, #9
 8001614:	ea42 52c5 	orr.w	r2, r2, r5, lsl #23
 8001618:	4614      	mov	r4, r2
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
  {
    BlockSize = 512U;
 800161a:	f44f 7900 	mov.w	r9, #512	; 0x200
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 800161e:	2340      	movs	r3, #64	; 0x40
 8001620:	9303      	str	r3, [sp, #12]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8001622:	2300      	movs	r3, #0
    WriteAddr /= 512U;
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 8001624:	f04f 0a10 	mov.w	sl, #16
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8001628:	9304      	str	r3, [sp, #16]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800162a:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 800162c:	f44f 6380 	mov.w	r3, #1024	; 0x400
    BlockSize = 512U;
    WriteAddr /= 512U;
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
 8001630:	f8cd 9004 	str.w	r9, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 8001634:	f8cd a008 	str.w	sl, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8001638:	9305      	str	r3, [sp, #20]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800163a:	f7ff f93b 	bl	80008b4 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
 800163e:	4630      	mov	r0, r6
 8001640:	4651      	mov	r1, sl
 8001642:	f7ff fa25 	bl	8000a90 <SD_CmdResp1Error>
  
  if (errorstate != SD_OK)
 8001646:	2800      	cmp	r0, #0
 8001648:	f040 80bd 	bne.w	80017c6 <HAL_SD_WriteBlocks+0x1da>
  {
    return errorstate;
  }
  
  if(NumberOfBlocks > 1U)
 800164c:	f1b8 0f01 	cmp.w	r8, #1
  {
    /* Send CMD25 WRITE_MULT_BLOCK with argument data address */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_MULT_BLOCK;
 8001650:	bf8c      	ite	hi
 8001652:	2319      	movhi	r3, #25
  }
  else
  {
    /* Send CMD24 WRITE_SINGLE_BLOCK */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_SINGLE_BLOCK;
 8001654:	2318      	movls	r3, #24
  }
  
  sdio_cmdinitstructure.Argument         = (uint32_t)WriteAddr;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001656:	a901      	add	r1, sp, #4
 8001658:	6830      	ldr	r0, [r6, #0]
    sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_MULT_BLOCK;
  }
  else
  {
    /* Send CMD24 WRITE_SINGLE_BLOCK */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_SINGLE_BLOCK;
 800165a:	9302      	str	r3, [sp, #8]
  }
  
  sdio_cmdinitstructure.Argument         = (uint32_t)WriteAddr;
 800165c:	9401      	str	r4, [sp, #4]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800165e:	f7ff f929 	bl	80008b4 <SDIO_SendCommand>
  
  /* Check for error conditions */
  if(NumberOfBlocks > 1U)
 8001662:	f1b8 0f01 	cmp.w	r8, #1
  {
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_WRITE_MULT_BLOCK);
 8001666:	4630      	mov	r0, r6
 8001668:	bf8c      	ite	hi
 800166a:	2119      	movhi	r1, #25
  }
  else
  {
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_WRITE_SINGLE_BLOCK);
 800166c:	2118      	movls	r1, #24
 800166e:	f7ff fa0f 	bl	8000a90 <SD_CmdResp1Error>
 8001672:	4604      	mov	r4, r0
  }  
  
  if (errorstate != SD_OK)
 8001674:	2800      	cmp	r0, #0
 8001676:	f040 80a6 	bne.w	80017c6 <HAL_SD_WriteBlocks+0x1da>
  
  /* Set total number of bytes to write */
  totalnumberofbytes = NumberOfBlocks * BlockSize;
  
  /* Configure the SD DPSM (Data Path State Machine) */ 
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
 800167a:	f04f 33ff 	mov.w	r3, #4294967295
 800167e:	9306      	str	r3, [sp, #24]
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
 8001680:	2390      	movs	r3, #144	; 0x90
 8001682:	9308      	str	r3, [sp, #32]
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
 8001684:	9009      	str	r0, [sp, #36]	; 0x24
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 8001686:	900a      	str	r0, [sp, #40]	; 0x28
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 8001688:	2301      	movs	r3, #1
  {
    return errorstate;
  }
  
  /* Set total number of bytes to write */
  totalnumberofbytes = NumberOfBlocks * BlockSize;
 800168a:	fb08 f909 	mul.w	r9, r8, r9
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 800168e:	6830      	ldr	r0, [r6, #0]
  /* Set total number of bytes to write */
  totalnumberofbytes = NumberOfBlocks * BlockSize;
  
  /* Configure the SD DPSM (Data Path State Machine) */ 
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
 8001690:	f8cd 901c 	str.w	r9, [sp, #28]
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 8001694:	a906      	add	r1, sp, #24
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 8001696:	930b      	str	r3, [sp, #44]	; 0x2c
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 8001698:	f7ff f92e 	bl	80008f8 <SDIO_DataConfig>
  
  /* Write block(s) in polling mode */
  if(NumberOfBlocks > 1U)
 800169c:	f1b8 0f01 	cmp.w	r8, #1
 80016a0:	d93b      	bls.n	800171a <HAL_SD_WriteBlocks+0x12e>
  {
#ifdef SDIO_STA_STBITERR
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND | SDIO_FLAG_STBITERR))
 80016a2:	6833      	ldr	r3, [r6, #0]
 80016a4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80016a6:	f240 351a 	movw	r5, #794	; 0x31a
 80016aa:	4015      	ands	r5, r2
 80016ac:	bb75      	cbnz	r5, 800170c <HAL_SD_WriteBlocks+0x120>
#else /* SDIO_STA_STBITERR not defined */
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND))
#endif /* SDIO_STA_STBITERR */     
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXFIFOHE))
 80016ae:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80016b0:	0450      	lsls	r0, r2, #17
 80016b2:	d5f7      	bpl.n	80016a4 <HAL_SD_WriteBlocks+0xb8>
      {
        if ((totalnumberofbytes - bytestransferred) < 32U)
 80016b4:	ebc4 0309 	rsb	r3, r4, r9
 80016b8:	2b1f      	cmp	r3, #31
 80016ba:	d814      	bhi.n	80016e6 <HAL_SD_WriteBlocks+0xfa>
        {
          restwords = ((totalnumberofbytes - bytestransferred) % 4U == 0U) ? ((totalnumberofbytes - bytestransferred) / 4U) : (( totalnumberofbytes -  bytestransferred) / 4U + 1U);
 80016bc:	f013 0f03 	tst.w	r3, #3
 80016c0:	ea4f 0a93 	mov.w	sl, r3, lsr #2
 80016c4:	bf18      	it	ne
 80016c6:	f10a 0a01 	addne.w	sl, sl, #1
          
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < restwords; count++)
 80016ca:	2500      	movs	r5, #0
 80016cc:	00ab      	lsls	r3, r5, #2
 80016ce:	4555      	cmp	r5, sl
 80016d0:	eb07 0103 	add.w	r1, r7, r3
 80016d4:	d004      	beq.n	80016e0 <HAL_SD_WriteBlocks+0xf4>
          {
            SDIO_WriteFIFO(hsd->Instance, tempbuff);
 80016d6:	6830      	ldr	r0, [r6, #0]
 80016d8:	f7ff f8df 	bl	800089a <SDIO_WriteFIFO>
        if ((totalnumberofbytes - bytestransferred) < 32U)
        {
          restwords = ((totalnumberofbytes - bytestransferred) % 4U == 0U) ? ((totalnumberofbytes - bytestransferred) / 4U) : (( totalnumberofbytes -  bytestransferred) / 4U + 1U);
          
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < restwords; count++)
 80016dc:	3501      	adds	r5, #1
 80016de:	e7f5      	b.n	80016cc <HAL_SD_WriteBlocks+0xe0>
 80016e0:	441c      	add	r4, r3
 80016e2:	460f      	mov	r7, r1
 80016e4:	e7dd      	b.n	80016a2 <HAL_SD_WriteBlocks+0xb6>
        else
        {
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < 8U; count++)
          {
            SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
 80016e6:	1979      	adds	r1, r7, r5
 80016e8:	6830      	ldr	r0, [r6, #0]
 80016ea:	3504      	adds	r5, #4
 80016ec:	f7ff f8d5 	bl	800089a <SDIO_WriteFIFO>
          }
        }
        else
        {
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < 8U; count++)
 80016f0:	2d20      	cmp	r5, #32
 80016f2:	d1f8      	bne.n	80016e6 <HAL_SD_WriteBlocks+0xfa>
          {
            SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
          }
          
          tempbuff += 8U;
 80016f4:	3720      	adds	r7, #32
          bytestransferred += 32U;
 80016f6:	3420      	adds	r4, #32
 80016f8:	e7d3      	b.n	80016a2 <HAL_SD_WriteBlocks+0xb6>
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
#else /* SDIO_STA_STBITERR not defined */
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXFIFOHE))
 80016fa:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80016fc:	0452      	lsls	r2, r2, #17
 80016fe:	d40e      	bmi.n	800171e <HAL_SD_WriteBlocks+0x132>
  }
  else
  {
    /* In case of single data block transfer no need of stop command at all */
#ifdef SDIO_STA_STBITERR
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
 8001700:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001702:	f240 651a 	movw	r5, #1562	; 0x61a
 8001706:	4015      	ands	r5, r2
 8001708:	2d00      	cmp	r5, #0
 800170a:	d0f6      	beq.n	80016fa <HAL_SD_WriteBlocks+0x10e>
      }
    }  
  }
  
  /* Send stop transmission command in case of multiblock write */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 800170c:	6833      	ldr	r3, [r6, #0]
 800170e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001710:	05d9      	lsls	r1, r3, #23
 8001712:	d424      	bmi.n	800175e <HAL_SD_WriteBlocks+0x172>
 8001714:	e02c      	b.n	8001770 <HAL_SD_WriteBlocks+0x184>
 8001716:	441c      	add	r4, r3
 8001718:	460f      	mov	r7, r1
  }
  else
  {
    /* In case of single data block transfer no need of stop command at all */
#ifdef SDIO_STA_STBITERR
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
 800171a:	6833      	ldr	r3, [r6, #0]
 800171c:	e7f0      	b.n	8001700 <HAL_SD_WriteBlocks+0x114>
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXFIFOHE))
      {
        if ((totalnumberofbytes - bytestransferred) < 32U)
 800171e:	ebc4 0309 	rsb	r3, r4, r9
 8001722:	2b1f      	cmp	r3, #31
 8001724:	d811      	bhi.n	800174a <HAL_SD_WriteBlocks+0x15e>
        {
          restwords = ((totalnumberofbytes - bytestransferred) % 4U == 0U) ? ((totalnumberofbytes - bytestransferred) / 4U) : (( totalnumberofbytes -  bytestransferred) / 4U + 1U);
 8001726:	f013 0f03 	tst.w	r3, #3
 800172a:	ea4f 0a93 	mov.w	sl, r3, lsr #2
 800172e:	bf18      	it	ne
 8001730:	f10a 0a01 	addne.w	sl, sl, #1
          
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < restwords; count++)
 8001734:	2500      	movs	r5, #0
 8001736:	00ab      	lsls	r3, r5, #2
 8001738:	4555      	cmp	r5, sl
 800173a:	eb07 0103 	add.w	r1, r7, r3
 800173e:	d0ea      	beq.n	8001716 <HAL_SD_WriteBlocks+0x12a>
          {
            SDIO_WriteFIFO(hsd->Instance, tempbuff);
 8001740:	6830      	ldr	r0, [r6, #0]
 8001742:	f7ff f8aa 	bl	800089a <SDIO_WriteFIFO>
        if ((totalnumberofbytes - bytestransferred) < 32U)
        {
          restwords = ((totalnumberofbytes - bytestransferred) % 4U == 0U) ? ((totalnumberofbytes - bytestransferred) / 4U) : (( totalnumberofbytes -  bytestransferred) / 4U + 1U);
          
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < restwords; count++)
 8001746:	3501      	adds	r5, #1
 8001748:	e7f5      	b.n	8001736 <HAL_SD_WriteBlocks+0x14a>
        else
        {
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < 8U; count++)
          {
            SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
 800174a:	1979      	adds	r1, r7, r5
 800174c:	6830      	ldr	r0, [r6, #0]
 800174e:	3504      	adds	r5, #4
 8001750:	f7ff f8a3 	bl	800089a <SDIO_WriteFIFO>
          }
        }
        else
        {
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < 8U; count++)
 8001754:	2d20      	cmp	r5, #32
 8001756:	d1f8      	bne.n	800174a <HAL_SD_WriteBlocks+0x15e>
          {
            SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
          }
          
          tempbuff += 8U;
 8001758:	3720      	adds	r7, #32
          bytestransferred += 32U;
 800175a:	3420      	adds	r4, #32
 800175c:	e7dd      	b.n	800171a <HAL_SD_WriteBlocks+0x12e>
      }
    }  
  }
  
  /* Send stop transmission command in case of multiblock write */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 800175e:	f1b8 0f01 	cmp.w	r8, #1
 8001762:	d905      	bls.n	8001770 <HAL_SD_WriteBlocks+0x184>
  {    
    if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
 8001764:	6a33      	ldr	r3, [r6, #32]
 8001766:	2b02      	cmp	r3, #2
 8001768:	d802      	bhi.n	8001770 <HAL_SD_WriteBlocks+0x184>
      (hsd->CardType == HIGH_CAPACITY_SD_CARD))
    {
      /* Send stop transmission command */
      errorstate = HAL_SD_StopTransfer(hsd);
 800176a:	4630      	mov	r0, r6
 800176c:	f7ff fe6c 	bl	8001448 <HAL_SD_StopTransfer>
    }
  }
  
  /* Get error state */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
 8001770:	6833      	ldr	r3, [r6, #0]
 8001772:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001774:	0714      	lsls	r4, r2, #28
 8001776:	d503      	bpl.n	8001780 <HAL_SD_WriteBlocks+0x194>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
 8001778:	2208      	movs	r2, #8
 800177a:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_TIMEOUT;
    
    return errorstate;
 800177c:	2004      	movs	r0, #4
 800177e:	e022      	b.n	80017c6 <HAL_SD_WriteBlocks+0x1da>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
 8001780:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001782:	0790      	lsls	r0, r2, #30
 8001784:	d502      	bpl.n	800178c <HAL_SD_WriteBlocks+0x1a0>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
 8001786:	2002      	movs	r0, #2
 8001788:	6398      	str	r0, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_CRC_FAIL;
    
    return errorstate;
 800178a:	e01c      	b.n	80017c6 <HAL_SD_WriteBlocks+0x1da>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR))
 800178c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800178e:	06d1      	lsls	r1, r2, #27
 8001790:	d503      	bpl.n	800179a <HAL_SD_WriteBlocks+0x1ae>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_TXUNDERR);
 8001792:	2210      	movs	r2, #16
 8001794:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_TX_UNDERRUN;
    
    return errorstate;
 8001796:	2005      	movs	r0, #5
 8001798:	e015      	b.n	80017c6 <HAL_SD_WriteBlocks+0x1da>
  }
#ifdef SDIO_STA_STBITERR
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
 800179a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800179c:	0592      	lsls	r2, r2, #22
 800179e:	d504      	bpl.n	80017aa <HAL_SD_WriteBlocks+0x1be>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
 80017a0:	f44f 7200 	mov.w	r2, #512	; 0x200
 80017a4:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_START_BIT_ERR;
    
    return errorstate;
 80017a6:	2007      	movs	r0, #7
 80017a8:	e00d      	b.n	80017c6 <HAL_SD_WriteBlocks+0x1da>
  {
    /* No error flag set */
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80017aa:	f240 52ff 	movw	r2, #1535	; 0x5ff
 80017ae:	639a      	str	r2, [r3, #56]	; 0x38
  /* Wait till the card is in programming state */
  errorstate = SD_IsCardProgramming(hsd, &cardstate);
  
  while ((errorstate == SD_OK) && ((cardstate == SD_CARD_PROGRAMMING) || (cardstate == SD_CARD_RECEIVING)))
  {
    errorstate = SD_IsCardProgramming(hsd, &cardstate);
 80017b0:	4630      	mov	r0, r6
 80017b2:	f10d 0103 	add.w	r1, sp, #3
 80017b6:	f7ff f8c9 	bl	800094c <SD_IsCardProgramming>
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
  
  /* Wait till the card is in programming state */
  errorstate = SD_IsCardProgramming(hsd, &cardstate);
  
  while ((errorstate == SD_OK) && ((cardstate == SD_CARD_PROGRAMMING) || (cardstate == SD_CARD_RECEIVING)))
 80017ba:	b920      	cbnz	r0, 80017c6 <HAL_SD_WriteBlocks+0x1da>
 80017bc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80017c0:	3b06      	subs	r3, #6
 80017c2:	2b01      	cmp	r3, #1
 80017c4:	d9f4      	bls.n	80017b0 <HAL_SD_WriteBlocks+0x1c4>
  {
    errorstate = SD_IsCardProgramming(hsd, &cardstate);
  }
  
  return errorstate;
}
 80017c6:	b00c      	add	sp, #48	; 0x30
 80017c8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080017cc <HAL_SD_GetStatus>:
  * @brief  Gets the current sd card data status.
  * @param  hsd: SD handle
  * @retval Data Transfer state
  */
HAL_SD_TransferStateTypedef HAL_SD_GetStatus(SD_HandleTypeDef *hsd)
{
 80017cc:	b530      	push	{r4, r5, lr}
    
    return errorstate;
  }
  
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 80017ce:	6a43      	ldr	r3, [r0, #36]	; 0x24
  * @brief  Gets the current sd card data status.
  * @param  hsd: SD handle
  * @retval Data Transfer state
  */
HAL_SD_TransferStateTypedef HAL_SD_GetStatus(SD_HandleTypeDef *hsd)
{
 80017d0:	b087      	sub	sp, #28
    
    return errorstate;
  }
  
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 80017d2:	041b      	lsls	r3, r3, #16
 80017d4:	9301      	str	r3, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80017d6:	2340      	movs	r3, #64	; 0x40
 80017d8:	9303      	str	r3, [sp, #12]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80017da:	2300      	movs	r3, #0
  * @brief  Gets the current sd card data status.
  * @param  hsd: SD handle
  * @retval Data Transfer state
  */
HAL_SD_TransferStateTypedef HAL_SD_GetStatus(SD_HandleTypeDef *hsd)
{
 80017dc:	4604      	mov	r4, r0
    return errorstate;
  }
  
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
 80017de:	250d      	movs	r5, #13
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80017e0:	9304      	str	r3, [sp, #16]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80017e2:	a901      	add	r1, sp, #4
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80017e4:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80017e8:	6800      	ldr	r0, [r0, #0]
    return errorstate;
  }
  
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
 80017ea:	9502      	str	r5, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80017ec:	9305      	str	r3, [sp, #20]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80017ee:	f7ff f861 	bl	80008b4 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SEND_STATUS);
 80017f2:	4620      	mov	r0, r4
 80017f4:	4629      	mov	r1, r5
 80017f6:	f7ff f94b 	bl	8000a90 <SD_CmdResp1Error>
  
  if(errorstate != SD_OK)
 80017fa:	b938      	cbnz	r0, 800180c <HAL_SD_GetStatus+0x40>
  {
    return errorstate;
  }
  
  /* Get SD card status */
  *pCardStatus = SDIO_GetResponse(SDIO_RESP1);
 80017fc:	f7ff f870 	bl	80008e0 <SDIO_GetResponse>

  /* Get SD card state */
  cardstate = SD_GetState(hsd);
  
  /* Find SD status according to card state*/
  if (cardstate == SD_CARD_TRANSFER)
 8001800:	f3c0 2043 	ubfx	r0, r0, #9, #4
  {
    return SD_TRANSFER_OK;
 8001804:	3804      	subs	r0, #4
 8001806:	bf18      	it	ne
 8001808:	2001      	movne	r0, #1
 800180a:	e000      	b.n	800180e <HAL_SD_GetStatus+0x42>
  }
  else if(cardstate == SD_CARD_ERROR)
  {
    return SD_TRANSFER_ERROR;
 800180c:	2002      	movs	r0, #2
  }
  else
  {
    return SD_TRANSFER_BUSY;
  }
}
 800180e:	b007      	add	sp, #28
 8001810:	bd30      	pop	{r4, r5, pc}
	...

08001814 <HAL_RCC_OscConfig>:
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001814:	6803      	ldr	r3, [r0, #0]
  *         first and then HSE On or HSE Bypass.
  
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8001816:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001818:	07d9      	lsls	r1, r3, #31
  *         first and then HSE On or HSE Bypass.
  
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800181a:	4604      	mov	r4, r0
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800181c:	d403      	bmi.n	8001826 <HAL_RCC_OscConfig+0x12>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800181e:	6823      	ldr	r3, [r4, #0]
 8001820:	079a      	lsls	r2, r3, #30
 8001822:	d437      	bmi.n	8001894 <HAL_RCC_OscConfig+0x80>
 8001824:	e079      	b.n	800191a <HAL_RCC_OscConfig+0x106>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8001826:	4ba1      	ldr	r3, [pc, #644]	; (8001aac <HAL_RCC_OscConfig+0x298>)
 8001828:	689a      	ldr	r2, [r3, #8]
 800182a:	f002 020c 	and.w	r2, r2, #12
 800182e:	2a04      	cmp	r2, #4
 8001830:	d007      	beq.n	8001842 <HAL_RCC_OscConfig+0x2e>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8001832:	689a      	ldr	r2, [r3, #8]
 8001834:	f002 020c 	and.w	r2, r2, #12
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8001838:	2a08      	cmp	r2, #8
 800183a:	d10b      	bne.n	8001854 <HAL_RCC_OscConfig+0x40>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800183c:	685b      	ldr	r3, [r3, #4]
 800183e:	025b      	lsls	r3, r3, #9
 8001840:	d508      	bpl.n	8001854 <HAL_RCC_OscConfig+0x40>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8001842:	4b9a      	ldr	r3, [pc, #616]	; (8001aac <HAL_RCC_OscConfig+0x298>)
 8001844:	681b      	ldr	r3, [r3, #0]
 8001846:	039f      	lsls	r7, r3, #14
 8001848:	d5e9      	bpl.n	800181e <HAL_RCC_OscConfig+0xa>
 800184a:	6863      	ldr	r3, [r4, #4]
 800184c:	2b00      	cmp	r3, #0
 800184e:	d1e6      	bne.n	800181e <HAL_RCC_OscConfig+0xa>
      {
        return HAL_ERROR;
 8001850:	2001      	movs	r0, #1
 8001852:	e128      	b.n	8001aa6 <HAL_RCC_OscConfig+0x292>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001854:	4b96      	ldr	r3, [pc, #600]	; (8001ab0 <HAL_RCC_OscConfig+0x29c>)
 8001856:	7922      	ldrb	r2, [r4, #4]
 8001858:	701a      	strb	r2, [r3, #0]
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 800185a:	6863      	ldr	r3, [r4, #4]
 800185c:	b16b      	cbz	r3, 800187a <HAL_RCC_OscConfig+0x66>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800185e:	f000 fbb9 	bl	8001fd4 <HAL_GetTick>
 8001862:	4605      	mov	r5, r0
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001864:	4b91      	ldr	r3, [pc, #580]	; (8001aac <HAL_RCC_OscConfig+0x298>)
 8001866:	681b      	ldr	r3, [r3, #0]
 8001868:	039e      	lsls	r6, r3, #14
 800186a:	d4d8      	bmi.n	800181e <HAL_RCC_OscConfig+0xa>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800186c:	f000 fbb2 	bl	8001fd4 <HAL_GetTick>
 8001870:	1b40      	subs	r0, r0, r5
 8001872:	2864      	cmp	r0, #100	; 0x64
 8001874:	d9f6      	bls.n	8001864 <HAL_RCC_OscConfig+0x50>
          {
            return HAL_TIMEOUT;
 8001876:	2003      	movs	r0, #3
 8001878:	e115      	b.n	8001aa6 <HAL_RCC_OscConfig+0x292>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800187a:	f000 fbab 	bl	8001fd4 <HAL_GetTick>
 800187e:	4605      	mov	r5, r0

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001880:	4b8a      	ldr	r3, [pc, #552]	; (8001aac <HAL_RCC_OscConfig+0x298>)
 8001882:	681b      	ldr	r3, [r3, #0]
 8001884:	0398      	lsls	r0, r3, #14
 8001886:	d5ca      	bpl.n	800181e <HAL_RCC_OscConfig+0xa>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001888:	f000 fba4 	bl	8001fd4 <HAL_GetTick>
 800188c:	1b40      	subs	r0, r0, r5
 800188e:	2864      	cmp	r0, #100	; 0x64
 8001890:	d9f6      	bls.n	8001880 <HAL_RCC_OscConfig+0x6c>
 8001892:	e7f0      	b.n	8001876 <HAL_RCC_OscConfig+0x62>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8001894:	4b85      	ldr	r3, [pc, #532]	; (8001aac <HAL_RCC_OscConfig+0x298>)
 8001896:	689a      	ldr	r2, [r3, #8]
 8001898:	f012 0f0c 	tst.w	r2, #12
 800189c:	d007      	beq.n	80018ae <HAL_RCC_OscConfig+0x9a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800189e:	689a      	ldr	r2, [r3, #8]
 80018a0:	f002 020c 	and.w	r2, r2, #12
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 80018a4:	2a08      	cmp	r2, #8
 80018a6:	d10a      	bne.n	80018be <HAL_RCC_OscConfig+0xaa>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80018a8:	685b      	ldr	r3, [r3, #4]
 80018aa:	0259      	lsls	r1, r3, #9
 80018ac:	d407      	bmi.n	80018be <HAL_RCC_OscConfig+0xaa>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80018ae:	4b7f      	ldr	r3, [pc, #508]	; (8001aac <HAL_RCC_OscConfig+0x298>)
 80018b0:	681a      	ldr	r2, [r3, #0]
 80018b2:	0792      	lsls	r2, r2, #30
 80018b4:	d515      	bpl.n	80018e2 <HAL_RCC_OscConfig+0xce>
 80018b6:	68e2      	ldr	r2, [r4, #12]
 80018b8:	2a01      	cmp	r2, #1
 80018ba:	d1c9      	bne.n	8001850 <HAL_RCC_OscConfig+0x3c>
 80018bc:	e011      	b.n	80018e2 <HAL_RCC_OscConfig+0xce>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 80018be:	68e2      	ldr	r2, [r4, #12]
 80018c0:	4b7c      	ldr	r3, [pc, #496]	; (8001ab4 <HAL_RCC_OscConfig+0x2a0>)
 80018c2:	b1e2      	cbz	r2, 80018fe <HAL_RCC_OscConfig+0xea>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80018c4:	2201      	movs	r2, #1
 80018c6:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80018c8:	f000 fb84 	bl	8001fd4 <HAL_GetTick>
 80018cc:	4605      	mov	r5, r0

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80018ce:	4b77      	ldr	r3, [pc, #476]	; (8001aac <HAL_RCC_OscConfig+0x298>)
 80018d0:	681a      	ldr	r2, [r3, #0]
 80018d2:	0797      	lsls	r7, r2, #30
 80018d4:	d405      	bmi.n	80018e2 <HAL_RCC_OscConfig+0xce>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80018d6:	f000 fb7d 	bl	8001fd4 <HAL_GetTick>
 80018da:	1b40      	subs	r0, r0, r5
 80018dc:	2802      	cmp	r0, #2
 80018de:	d9f6      	bls.n	80018ce <HAL_RCC_OscConfig+0xba>
 80018e0:	e7c9      	b.n	8001876 <HAL_RCC_OscConfig+0x62>
            return HAL_TIMEOUT;
          }       
        } 
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80018e2:	681a      	ldr	r2, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80018e4:	21f8      	movs	r1, #248	; 0xf8
 80018e6:	fa91 f1a1 	rbit	r1, r1
 80018ea:	6923      	ldr	r3, [r4, #16]
 80018ec:	fab1 f181 	clz	r1, r1
 80018f0:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 80018f4:	408b      	lsls	r3, r1
 80018f6:	4313      	orrs	r3, r2
 80018f8:	4a6c      	ldr	r2, [pc, #432]	; (8001aac <HAL_RCC_OscConfig+0x298>)
 80018fa:	6013      	str	r3, [r2, #0]
 80018fc:	e00d      	b.n	800191a <HAL_RCC_OscConfig+0x106>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 80018fe:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001900:	f000 fb68 	bl	8001fd4 <HAL_GetTick>
 8001904:	4605      	mov	r5, r0
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001906:	4b69      	ldr	r3, [pc, #420]	; (8001aac <HAL_RCC_OscConfig+0x298>)
 8001908:	681b      	ldr	r3, [r3, #0]
 800190a:	079e      	lsls	r6, r3, #30
 800190c:	d505      	bpl.n	800191a <HAL_RCC_OscConfig+0x106>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800190e:	f000 fb61 	bl	8001fd4 <HAL_GetTick>
 8001912:	1b40      	subs	r0, r0, r5
 8001914:	2802      	cmp	r0, #2
 8001916:	d9f6      	bls.n	8001906 <HAL_RCC_OscConfig+0xf2>
 8001918:	e7ad      	b.n	8001876 <HAL_RCC_OscConfig+0x62>
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800191a:	6823      	ldr	r3, [r4, #0]
 800191c:	0718      	lsls	r0, r3, #28
 800191e:	d403      	bmi.n	8001928 <HAL_RCC_OscConfig+0x114>
        }       
      } 
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8001920:	6823      	ldr	r3, [r4, #0]
 8001922:	0759      	lsls	r1, r3, #29
 8001924:	d544      	bpl.n	80019b0 <HAL_RCC_OscConfig+0x19c>
 8001926:	e01f      	b.n	8001968 <HAL_RCC_OscConfig+0x154>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8001928:	6962      	ldr	r2, [r4, #20]
 800192a:	4b63      	ldr	r3, [pc, #396]	; (8001ab8 <HAL_RCC_OscConfig+0x2a4>)
 800192c:	b172      	cbz	r2, 800194c <HAL_RCC_OscConfig+0x138>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800192e:	2201      	movs	r2, #1
 8001930:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001932:	f000 fb4f 	bl	8001fd4 <HAL_GetTick>
 8001936:	4605      	mov	r5, r0
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001938:	4b5c      	ldr	r3, [pc, #368]	; (8001aac <HAL_RCC_OscConfig+0x298>)
 800193a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800193c:	079a      	lsls	r2, r3, #30
 800193e:	d4ef      	bmi.n	8001920 <HAL_RCC_OscConfig+0x10c>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001940:	f000 fb48 	bl	8001fd4 <HAL_GetTick>
 8001944:	1b40      	subs	r0, r0, r5
 8001946:	2802      	cmp	r0, #2
 8001948:	d9f6      	bls.n	8001938 <HAL_RCC_OscConfig+0x124>
 800194a:	e794      	b.n	8001876 <HAL_RCC_OscConfig+0x62>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 800194c:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800194e:	f000 fb41 	bl	8001fd4 <HAL_GetTick>
 8001952:	4605      	mov	r5, r0
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001954:	4b55      	ldr	r3, [pc, #340]	; (8001aac <HAL_RCC_OscConfig+0x298>)
 8001956:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001958:	079b      	lsls	r3, r3, #30
 800195a:	d5e1      	bpl.n	8001920 <HAL_RCC_OscConfig+0x10c>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800195c:	f000 fb3a 	bl	8001fd4 <HAL_GetTick>
 8001960:	1b40      	subs	r0, r0, r5
 8001962:	2802      	cmp	r0, #2
 8001964:	d9f6      	bls.n	8001954 <HAL_RCC_OscConfig+0x140>
 8001966:	e786      	b.n	8001876 <HAL_RCC_OscConfig+0x62>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8001968:	2300      	movs	r3, #0
 800196a:	9301      	str	r3, [sp, #4]
 800196c:	4b4f      	ldr	r3, [pc, #316]	; (8001aac <HAL_RCC_OscConfig+0x298>)
 800196e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001970:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001974:	641a      	str	r2, [r3, #64]	; 0x40
 8001976:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001978:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800197c:	9301      	str	r3, [sp, #4]
 800197e:	9b01      	ldr	r3, [sp, #4]
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 8001980:	4b4e      	ldr	r3, [pc, #312]	; (8001abc <HAL_RCC_OscConfig+0x2a8>)
 8001982:	681a      	ldr	r2, [r3, #0]
 8001984:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001988:	601a      	str	r2, [r3, #0]
    
    /* Wait for Backup domain Write protection enable */
    tickstart = HAL_GetTick();
 800198a:	f000 fb23 	bl	8001fd4 <HAL_GetTick>
 800198e:	4605      	mov	r5, r0
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8001990:	4b4a      	ldr	r3, [pc, #296]	; (8001abc <HAL_RCC_OscConfig+0x2a8>)
 8001992:	681b      	ldr	r3, [r3, #0]
 8001994:	05df      	lsls	r7, r3, #23
 8001996:	d50e      	bpl.n	80019b6 <HAL_RCC_OscConfig+0x1a2>
        return HAL_TIMEOUT;
      }      
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001998:	4b49      	ldr	r3, [pc, #292]	; (8001ac0 <HAL_RCC_OscConfig+0x2ac>)
 800199a:	7a22      	ldrb	r2, [r4, #8]
 800199c:	701a      	strb	r2, [r3, #0]
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 800199e:	68a3      	ldr	r3, [r4, #8]
 80019a0:	b1bb      	cbz	r3, 80019d2 <HAL_RCC_OscConfig+0x1be>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80019a2:	f000 fb17 	bl	8001fd4 <HAL_GetTick>
 80019a6:	4605      	mov	r5, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80019a8:	4b40      	ldr	r3, [pc, #256]	; (8001aac <HAL_RCC_OscConfig+0x298>)
 80019aa:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80019ac:	079e      	lsls	r6, r3, #30
 80019ae:	d508      	bpl.n	80019c2 <HAL_RCC_OscConfig+0x1ae>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80019b0:	69a3      	ldr	r3, [r4, #24]
 80019b2:	b9eb      	cbnz	r3, 80019f0 <HAL_RCC_OscConfig+0x1dc>
 80019b4:	e05c      	b.n	8001a70 <HAL_RCC_OscConfig+0x25c>
    /* Wait for Backup domain Write protection enable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 80019b6:	f000 fb0d 	bl	8001fd4 <HAL_GetTick>
 80019ba:	1b40      	subs	r0, r0, r5
 80019bc:	2802      	cmp	r0, #2
 80019be:	d9e7      	bls.n	8001990 <HAL_RCC_OscConfig+0x17c>
 80019c0:	e759      	b.n	8001876 <HAL_RCC_OscConfig+0x62>
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80019c2:	f000 fb07 	bl	8001fd4 <HAL_GetTick>
 80019c6:	f241 3388 	movw	r3, #5000	; 0x1388
 80019ca:	1b40      	subs	r0, r0, r5
 80019cc:	4298      	cmp	r0, r3
 80019ce:	d9eb      	bls.n	80019a8 <HAL_RCC_OscConfig+0x194>
 80019d0:	e751      	b.n	8001876 <HAL_RCC_OscConfig+0x62>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80019d2:	f000 faff 	bl	8001fd4 <HAL_GetTick>
 80019d6:	4605      	mov	r5, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80019d8:	4b34      	ldr	r3, [pc, #208]	; (8001aac <HAL_RCC_OscConfig+0x298>)
 80019da:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80019dc:	0798      	lsls	r0, r3, #30
 80019de:	d5e7      	bpl.n	80019b0 <HAL_RCC_OscConfig+0x19c>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80019e0:	f000 faf8 	bl	8001fd4 <HAL_GetTick>
 80019e4:	f241 3388 	movw	r3, #5000	; 0x1388
 80019e8:	1b40      	subs	r0, r0, r5
 80019ea:	4298      	cmp	r0, r3
 80019ec:	d9f4      	bls.n	80019d8 <HAL_RCC_OscConfig+0x1c4>
 80019ee:	e742      	b.n	8001876 <HAL_RCC_OscConfig+0x62>
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 80019f0:	4a2e      	ldr	r2, [pc, #184]	; (8001aac <HAL_RCC_OscConfig+0x298>)
 80019f2:	6892      	ldr	r2, [r2, #8]
 80019f4:	f002 020c 	and.w	r2, r2, #12
 80019f8:	2a08      	cmp	r2, #8
 80019fa:	f43f af29 	beq.w	8001850 <HAL_RCC_OscConfig+0x3c>
 80019fe:	4d31      	ldr	r5, [pc, #196]	; (8001ac4 <HAL_RCC_OscConfig+0x2b0>)
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001a00:	2b02      	cmp	r3, #2
 8001a02:	f04f 0300 	mov.w	r3, #0
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001a06:	602b      	str	r3, [r5, #0]
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001a08:	d140      	bne.n	8001a8c <HAL_RCC_OscConfig+0x278>
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001a0a:	f000 fae3 	bl	8001fd4 <HAL_GetTick>
 8001a0e:	4606      	mov	r6, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001a10:	4b26      	ldr	r3, [pc, #152]	; (8001aac <HAL_RCC_OscConfig+0x298>)
 8001a12:	681b      	ldr	r3, [r3, #0]
 8001a14:	0199      	lsls	r1, r3, #6
 8001a16:	d42d      	bmi.n	8001a74 <HAL_RCC_OscConfig+0x260>
 8001a18:	f647 7ec0 	movw	lr, #32704	; 0x7fc0
 8001a1c:	fa9e feae 	rbit	lr, lr
 8001a20:	f44f 3740 	mov.w	r7, #196608	; 0x30000
            return HAL_TIMEOUT;
          }
        }        

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8001a24:	fabe fe8e 	clz	lr, lr
 8001a28:	fa97 f7a7 	rbit	r7, r7
 8001a2c:	f04f 6670 	mov.w	r6, #251658240	; 0xf000000
 8001a30:	fab7 f787 	clz	r7, r7
 8001a34:	fa96 f6a6 	rbit	r6, r6
 8001a38:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001a3a:	6a20      	ldr	r0, [r4, #32]
 8001a3c:	69e1      	ldr	r1, [r4, #28]
 8001a3e:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001a40:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
 8001a42:	085b      	lsrs	r3, r3, #1
 8001a44:	4301      	orrs	r1, r0
 8001a46:	fa02 f20e 	lsl.w	r2, r2, lr
 8001a4a:	3b01      	subs	r3, #1
 8001a4c:	430a      	orrs	r2, r1
 8001a4e:	40bb      	lsls	r3, r7
 8001a50:	fab6 f686 	clz	r6, r6
 8001a54:	431a      	orrs	r2, r3
 8001a56:	40b4      	lsls	r4, r6
 8001a58:	4b14      	ldr	r3, [pc, #80]	; (8001aac <HAL_RCC_OscConfig+0x298>)
 8001a5a:	4322      	orrs	r2, r4
 8001a5c:	605a      	str	r2, [r3, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << POSITION_VAL(RCC_PLLCFGR_PLLN))             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << POSITION_VAL(RCC_PLLCFGR_PLLP)) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << POSITION_VAL(RCC_PLLCFGR_PLLQ))));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8001a5e:	2301      	movs	r3, #1
 8001a60:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001a62:	f000 fab7 	bl	8001fd4 <HAL_GetTick>
 8001a66:	4604      	mov	r4, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001a68:	4b10      	ldr	r3, [pc, #64]	; (8001aac <HAL_RCC_OscConfig+0x298>)
 8001a6a:	681b      	ldr	r3, [r3, #0]
 8001a6c:	019a      	lsls	r2, r3, #6
 8001a6e:	d507      	bpl.n	8001a80 <HAL_RCC_OscConfig+0x26c>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8001a70:	2000      	movs	r0, #0
 8001a72:	e018      	b.n	8001aa6 <HAL_RCC_OscConfig+0x292>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001a74:	f000 faae 	bl	8001fd4 <HAL_GetTick>
 8001a78:	1b80      	subs	r0, r0, r6
 8001a7a:	2802      	cmp	r0, #2
 8001a7c:	d9c8      	bls.n	8001a10 <HAL_RCC_OscConfig+0x1fc>
 8001a7e:	e6fa      	b.n	8001876 <HAL_RCC_OscConfig+0x62>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001a80:	f000 faa8 	bl	8001fd4 <HAL_GetTick>
 8001a84:	1b00      	subs	r0, r0, r4
 8001a86:	2802      	cmp	r0, #2
 8001a88:	d9ee      	bls.n	8001a68 <HAL_RCC_OscConfig+0x254>
 8001a8a:	e6f4      	b.n	8001876 <HAL_RCC_OscConfig+0x62>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001a8c:	f000 faa2 	bl	8001fd4 <HAL_GetTick>
 8001a90:	4604      	mov	r4, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001a92:	4b06      	ldr	r3, [pc, #24]	; (8001aac <HAL_RCC_OscConfig+0x298>)
 8001a94:	681b      	ldr	r3, [r3, #0]
 8001a96:	019b      	lsls	r3, r3, #6
 8001a98:	d5ea      	bpl.n	8001a70 <HAL_RCC_OscConfig+0x25c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001a9a:	f000 fa9b 	bl	8001fd4 <HAL_GetTick>
 8001a9e:	1b00      	subs	r0, r0, r4
 8001aa0:	2802      	cmp	r0, #2
 8001aa2:	d9f6      	bls.n	8001a92 <HAL_RCC_OscConfig+0x27e>
 8001aa4:	e6e7      	b.n	8001876 <HAL_RCC_OscConfig+0x62>
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 8001aa6:	b003      	add	sp, #12
 8001aa8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001aaa:	bf00      	nop
 8001aac:	40023800 	.word	0x40023800
 8001ab0:	40023802 	.word	0x40023802
 8001ab4:	42470000 	.word	0x42470000
 8001ab8:	42470e80 	.word	0x42470e80
 8001abc:	40007000 	.word	0x40007000
 8001ac0:	40023870 	.word	0x40023870
 8001ac4:	42470060 	.word	0x42470060

08001ac8 <HAL_RCC_ClockConfig>:
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) and the supply voltage of the device. */
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001ac8:	4b4e      	ldr	r3, [pc, #312]	; (8001c04 <HAL_RCC_ClockConfig+0x13c>)
 8001aca:	681a      	ldr	r2, [r3, #0]
 8001acc:	f002 020f 	and.w	r2, r2, #15
 8001ad0:	4291      	cmp	r1, r2
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8001ad2:	b570      	push	{r4, r5, r6, lr}
 8001ad4:	4604      	mov	r4, r0
 8001ad6:	460d      	mov	r5, r1
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) and the supply voltage of the device. */
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001ad8:	d80a      	bhi.n	8001af0 <HAL_RCC_ClockConfig+0x28>
      return HAL_ERROR;
    }
  }
 
  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001ada:	6823      	ldr	r3, [r4, #0]
 8001adc:	0798      	lsls	r0, r3, #30
 8001ade:	d510      	bpl.n	8001b02 <HAL_RCC_ClockConfig+0x3a>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001ae0:	4a49      	ldr	r2, [pc, #292]	; (8001c08 <HAL_RCC_ClockConfig+0x140>)
 8001ae2:	68a1      	ldr	r1, [r4, #8]
 8001ae4:	6890      	ldr	r0, [r2, #8]
 8001ae6:	f020 00f0 	bic.w	r0, r0, #240	; 0xf0
 8001aea:	4301      	orrs	r1, r0
 8001aec:	6091      	str	r1, [r2, #8]
 8001aee:	e008      	b.n	8001b02 <HAL_RCC_ClockConfig+0x3a>
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001af0:	b2ca      	uxtb	r2, r1
 8001af2:	701a      	strb	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8001af4:	681b      	ldr	r3, [r3, #0]
 8001af6:	f003 030f 	and.w	r3, r3, #15
 8001afa:	428b      	cmp	r3, r1
 8001afc:	d0ed      	beq.n	8001ada <HAL_RCC_ClockConfig+0x12>
    {
      return HAL_ERROR;
 8001afe:	2001      	movs	r0, #1
 8001b00:	bd70      	pop	{r4, r5, r6, pc}
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
  }
  
  /*------------------------- SYSCLK Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8001b02:	07d9      	lsls	r1, r3, #31
 8001b04:	d406      	bmi.n	8001b14 <HAL_RCC_ClockConfig+0x4c>
      }
    }
  }    
  
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 8001b06:	4b3f      	ldr	r3, [pc, #252]	; (8001c04 <HAL_RCC_ClockConfig+0x13c>)
 8001b08:	681a      	ldr	r2, [r3, #0]
 8001b0a:	f002 020f 	and.w	r2, r2, #15
 8001b0e:	4295      	cmp	r5, r2
 8001b10:	d357      	bcc.n	8001bc2 <HAL_RCC_ClockConfig+0xfa>
 8001b12:	e05d      	b.n	8001bd0 <HAL_RCC_ClockConfig+0x108>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {    
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    
    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001b14:	6863      	ldr	r3, [r4, #4]
 8001b16:	4a3c      	ldr	r2, [pc, #240]	; (8001c08 <HAL_RCC_ClockConfig+0x140>)
 8001b18:	2b01      	cmp	r3, #1
 8001b1a:	d103      	bne.n	8001b24 <HAL_RCC_ClockConfig+0x5c>
    {
      /* Check the HSE ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001b1c:	6812      	ldr	r2, [r2, #0]
 8001b1e:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8001b22:	e008      	b.n	8001b36 <HAL_RCC_ClockConfig+0x6e>
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 8001b24:	1e99      	subs	r1, r3, #2
 8001b26:	2901      	cmp	r1, #1
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
    {
      /* Check the PLL ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001b28:	6812      	ldr	r2, [r2, #0]
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 8001b2a:	d802      	bhi.n	8001b32 <HAL_RCC_ClockConfig+0x6a>
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
    {
      /* Check the PLL ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001b2c:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 8001b30:	e001      	b.n	8001b36 <HAL_RCC_ClockConfig+0x6e>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001b32:	f012 0f02 	tst.w	r2, #2
 8001b36:	d0e2      	beq.n	8001afe <HAL_RCC_ClockConfig+0x36>
      {
        return HAL_ERROR;
      }
    }
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001b38:	4a33      	ldr	r2, [pc, #204]	; (8001c08 <HAL_RCC_ClockConfig+0x140>)
 8001b3a:	6891      	ldr	r1, [r2, #8]
 8001b3c:	f021 0103 	bic.w	r1, r1, #3
 8001b40:	430b      	orrs	r3, r1
 8001b42:	6093      	str	r3, [r2, #8]
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001b44:	f000 fa46 	bl	8001fd4 <HAL_GetTick>
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001b48:	6863      	ldr	r3, [r4, #4]
 8001b4a:	2b01      	cmp	r3, #1
      }
    }
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001b4c:	4606      	mov	r6, r0
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001b4e:	d10e      	bne.n	8001b6e <HAL_RCC_ClockConfig+0xa6>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8001b50:	4b2d      	ldr	r3, [pc, #180]	; (8001c08 <HAL_RCC_ClockConfig+0x140>)
 8001b52:	689b      	ldr	r3, [r3, #8]
 8001b54:	f003 030c 	and.w	r3, r3, #12
 8001b58:	2b04      	cmp	r3, #4
 8001b5a:	d0d4      	beq.n	8001b06 <HAL_RCC_ClockConfig+0x3e>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001b5c:	f000 fa3a 	bl	8001fd4 <HAL_GetTick>
 8001b60:	f241 3388 	movw	r3, #5000	; 0x1388
 8001b64:	1b80      	subs	r0, r0, r6
 8001b66:	4298      	cmp	r0, r3
 8001b68:	d9f2      	bls.n	8001b50 <HAL_RCC_ClockConfig+0x88>
        {
          return HAL_TIMEOUT;
 8001b6a:	2003      	movs	r0, #3
 8001b6c:	bd70      	pop	{r4, r5, r6, pc}
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001b6e:	2b02      	cmp	r3, #2
 8001b70:	d10d      	bne.n	8001b8e <HAL_RCC_ClockConfig+0xc6>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8001b72:	4b25      	ldr	r3, [pc, #148]	; (8001c08 <HAL_RCC_ClockConfig+0x140>)
 8001b74:	689b      	ldr	r3, [r3, #8]
 8001b76:	f003 030c 	and.w	r3, r3, #12
 8001b7a:	2b08      	cmp	r3, #8
 8001b7c:	d0c3      	beq.n	8001b06 <HAL_RCC_ClockConfig+0x3e>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001b7e:	f000 fa29 	bl	8001fd4 <HAL_GetTick>
 8001b82:	f241 3388 	movw	r3, #5000	; 0x1388
 8001b86:	1b80      	subs	r0, r0, r6
 8001b88:	4298      	cmp	r0, r3
 8001b8a:	d9f2      	bls.n	8001b72 <HAL_RCC_ClockConfig+0xaa>
 8001b8c:	e7ed      	b.n	8001b6a <HAL_RCC_ClockConfig+0xa2>
        {
          return HAL_TIMEOUT;
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK)
 8001b8e:	2b03      	cmp	r3, #3
 8001b90:	d005      	beq.n	8001b9e <HAL_RCC_ClockConfig+0xd6>
        }
      }
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8001b92:	4b1d      	ldr	r3, [pc, #116]	; (8001c08 <HAL_RCC_ClockConfig+0x140>)
 8001b94:	689b      	ldr	r3, [r3, #8]
 8001b96:	f013 0f0c 	tst.w	r3, #12
 8001b9a:	d10a      	bne.n	8001bb2 <HAL_RCC_ClockConfig+0xea>
 8001b9c:	e7b3      	b.n	8001b06 <HAL_RCC_ClockConfig+0x3e>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK)
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
 8001b9e:	4b1a      	ldr	r3, [pc, #104]	; (8001c08 <HAL_RCC_ClockConfig+0x140>)
 8001ba0:	689b      	ldr	r3, [r3, #8]
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001ba2:	f000 fa17 	bl	8001fd4 <HAL_GetTick>
 8001ba6:	f241 3388 	movw	r3, #5000	; 0x1388
 8001baa:	1b80      	subs	r0, r0, r6
 8001bac:	4298      	cmp	r0, r3
 8001bae:	d9f6      	bls.n	8001b9e <HAL_RCC_ClockConfig+0xd6>
 8001bb0:	e7db      	b.n	8001b6a <HAL_RCC_ClockConfig+0xa2>
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001bb2:	f000 fa0f 	bl	8001fd4 <HAL_GetTick>
 8001bb6:	f241 3388 	movw	r3, #5000	; 0x1388
 8001bba:	1b80      	subs	r0, r0, r6
 8001bbc:	4298      	cmp	r0, r3
 8001bbe:	d9e8      	bls.n	8001b92 <HAL_RCC_ClockConfig+0xca>
 8001bc0:	e7d3      	b.n	8001b6a <HAL_RCC_ClockConfig+0xa2>
  
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
  { 
     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001bc2:	b2ea      	uxtb	r2, r5
 8001bc4:	701a      	strb	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8001bc6:	681b      	ldr	r3, [r3, #0]
 8001bc8:	f003 030f 	and.w	r3, r3, #15
 8001bcc:	42ab      	cmp	r3, r5
 8001bce:	d196      	bne.n	8001afe <HAL_RCC_ClockConfig+0x36>
      return HAL_ERROR;
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001bd0:	6823      	ldr	r3, [r4, #0]
 8001bd2:	075a      	lsls	r2, r3, #29
 8001bd4:	d506      	bpl.n	8001be4 <HAL_RCC_ClockConfig+0x11c>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8001bd6:	4a0c      	ldr	r2, [pc, #48]	; (8001c08 <HAL_RCC_ClockConfig+0x140>)
 8001bd8:	68e1      	ldr	r1, [r4, #12]
 8001bda:	6890      	ldr	r0, [r2, #8]
 8001bdc:	f420 50e0 	bic.w	r0, r0, #7168	; 0x1c00
 8001be0:	4301      	orrs	r1, r0
 8001be2:	6091      	str	r1, [r2, #8]
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001be4:	071b      	lsls	r3, r3, #28
 8001be6:	d507      	bpl.n	8001bf8 <HAL_RCC_ClockConfig+0x130>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8001be8:	4b07      	ldr	r3, [pc, #28]	; (8001c08 <HAL_RCC_ClockConfig+0x140>)
 8001bea:	6921      	ldr	r1, [r4, #16]
 8001bec:	689a      	ldr	r2, [r3, #8]
 8001bee:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 8001bf2:	ea42 02c1 	orr.w	r2, r2, r1, lsl #3
 8001bf6:	609a      	str	r2, [r3, #8]
  }

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 8001bf8:	2000      	movs	r0, #0
 8001bfa:	f000 f9b6 	bl	8001f6a <HAL_InitTick>
  
  return HAL_OK;
 8001bfe:	2000      	movs	r0, #0
}
 8001c00:	bd70      	pop	{r4, r5, r6, pc}
 8001c02:	bf00      	nop
 8001c04:	40023c00 	.word	0x40023c00
 8001c08:	40023800 	.word	0x40023800

08001c0c <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8001c0c:	4b1f      	ldr	r3, [pc, #124]	; (8001c8c <HAL_RCC_GetSysClockFreq+0x80>)
 8001c0e:	689a      	ldr	r2, [r3, #8]
 8001c10:	f002 020c 	and.w	r2, r2, #12
 8001c14:	2a04      	cmp	r2, #4
  *         
  *               
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8001c16:	b510      	push	{r4, lr}
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8001c18:	d036      	beq.n	8001c88 <HAL_RCC_GetSysClockFreq+0x7c>
 8001c1a:	2a08      	cmp	r2, #8
 8001c1c:	d001      	beq.n	8001c22 <HAL_RCC_GetSysClockFreq+0x16>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8001c1e:	481c      	ldr	r0, [pc, #112]	; (8001c90 <HAL_RCC_GetSysClockFreq+0x84>)
 8001c20:	bd10      	pop	{r4, pc}
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001c22:	6859      	ldr	r1, [r3, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8001c24:	685a      	ldr	r2, [r3, #4]
      {
        /* HSE used as PLL clock source */
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 8001c26:	685c      	ldr	r4, [r3, #4]
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8001c28:	f412 0f80 	tst.w	r2, #4194304	; 0x400000
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001c2c:	f001 013f 	and.w	r1, r1, #63	; 0x3f
 8001c30:	f647 72c0 	movw	r2, #32704	; 0x7fc0
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8001c34:	d00c      	beq.n	8001c50 <HAL_RCC_GetSysClockFreq+0x44>
 8001c36:	fa92 f2a2 	rbit	r2, r2
      {
        /* HSE used as PLL clock source */
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 8001c3a:	fab2 f382 	clz	r3, r2
 8001c3e:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 8001c42:	4022      	ands	r2, r4
 8001c44:	40da      	lsrs	r2, r3
 8001c46:	4b13      	ldr	r3, [pc, #76]	; (8001c94 <HAL_RCC_GetSysClockFreq+0x88>)
 8001c48:	fbb3 f3f1 	udiv	r3, r3, r1
 8001c4c:	4353      	muls	r3, r2
 8001c4e:	e00b      	b.n	8001c68 <HAL_RCC_GetSysClockFreq+0x5c>
 8001c50:	fa92 f2a2 	rbit	r2, r2
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 8001c54:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8001c58:	480d      	ldr	r0, [pc, #52]	; (8001c90 <HAL_RCC_GetSysClockFreq+0x84>)
 8001c5a:	fab2 f282 	clz	r2, r2
 8001c5e:	4023      	ands	r3, r4
 8001c60:	40d3      	lsrs	r3, r2
 8001c62:	fbb0 f1f1 	udiv	r1, r0, r1
 8001c66:	434b      	muls	r3, r1
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1U) *2U);
 8001c68:	4a08      	ldr	r2, [pc, #32]	; (8001c8c <HAL_RCC_GetSysClockFreq+0x80>)
 8001c6a:	6850      	ldr	r0, [r2, #4]
 8001c6c:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 8001c70:	fa92 f2a2 	rbit	r2, r2
 8001c74:	fab2 f282 	clz	r2, r2
 8001c78:	f400 3040 	and.w	r0, r0, #196608	; 0x30000
 8001c7c:	40d0      	lsrs	r0, r2
 8001c7e:	3001      	adds	r0, #1
 8001c80:	0040      	lsls	r0, r0, #1
      
      sysclockfreq = pllvco/pllp;
 8001c82:	fbb3 f0f0 	udiv	r0, r3, r0
      break;
 8001c86:	bd10      	pop	{r4, pc}
      sysclockfreq = HSI_VALUE;
       break;
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 8001c88:	4802      	ldr	r0, [pc, #8]	; (8001c94 <HAL_RCC_GetSysClockFreq+0x88>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8001c8a:	bd10      	pop	{r4, pc}
 8001c8c:	40023800 	.word	0x40023800
 8001c90:	00f42400 	.word	0x00f42400
 8001c94:	007a1200 	.word	0x007a1200

08001c98 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8001c98:	b508      	push	{r3, lr}
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 8001c9a:	f7ff ffb7 	bl	8001c0c <HAL_RCC_GetSysClockFreq>
 8001c9e:	4b08      	ldr	r3, [pc, #32]	; (8001cc0 <HAL_RCC_GetHCLKFreq+0x28>)
 8001ca0:	22f0      	movs	r2, #240	; 0xf0
 8001ca2:	689b      	ldr	r3, [r3, #8]
 8001ca4:	fa92 f2a2 	rbit	r2, r2
 8001ca8:	fab2 f282 	clz	r2, r2
 8001cac:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8001cb0:	40d3      	lsrs	r3, r2
 8001cb2:	4a04      	ldr	r2, [pc, #16]	; (8001cc4 <HAL_RCC_GetHCLKFreq+0x2c>)
 8001cb4:	5cd3      	ldrb	r3, [r2, r3]
 8001cb6:	40d8      	lsrs	r0, r3
 8001cb8:	4b03      	ldr	r3, [pc, #12]	; (8001cc8 <HAL_RCC_GetHCLKFreq+0x30>)
 8001cba:	6018      	str	r0, [r3, #0]
  return SystemCoreClock;
}
 8001cbc:	bd08      	pop	{r3, pc}
 8001cbe:	bf00      	nop
 8001cc0:	40023800 	.word	0x40023800
 8001cc4:	080023c0 	.word	0x080023c0
 8001cc8:	20000004 	.word	0x20000004

08001ccc <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001ccc:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001cd0:	680f      	ldr	r7, [r1, #0]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8001cd2:	2300      	movs	r3, #0
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
 8001cd4:	2201      	movs	r2, #1
 8001cd6:	409a      	lsls	r2, r3
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001cd8:	ea02 0407 	and.w	r4, r2, r7

    if(iocurrent == ioposition)
 8001cdc:	4294      	cmp	r4, r2
 8001cde:	f040 80bb 	bne.w	8001e58 <HAL_GPIO_Init+0x18c>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001ce2:	684a      	ldr	r2, [r1, #4]
 8001ce4:	f022 0610 	bic.w	r6, r2, #16
 8001ce8:	2e02      	cmp	r6, #2
 8001cea:	d116      	bne.n	8001d1a <HAL_GPIO_Init+0x4e>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8001cec:	ea4f 0cd3 	mov.w	ip, r3, lsr #3
 8001cf0:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 8001cf4:	f003 0807 	and.w	r8, r3, #7
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8001cf8:	f8dc 5020 	ldr.w	r5, [ip, #32]
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 8001cfc:	ea4f 0888 	mov.w	r8, r8, lsl #2
 8001d00:	f04f 090f 	mov.w	r9, #15
 8001d04:	fa09 f908 	lsl.w	r9, r9, r8
 8001d08:	ea25 0909 	bic.w	r9, r5, r9
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
 8001d0c:	690d      	ldr	r5, [r1, #16]
 8001d0e:	fa05 f808 	lsl.w	r8, r5, r8
 8001d12:	ea49 0508 	orr.w	r5, r9, r8
        GPIOx->AFR[position >> 3U] = temp;
 8001d16:	f8cc 5020 	str.w	r5, [ip, #32]
 8001d1a:	005d      	lsls	r5, r3, #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8001d1c:	f04f 0c03 	mov.w	ip, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8001d20:	f8d0 9000 	ldr.w	r9, [r0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8001d24:	fa0c fc05 	lsl.w	ip, ip, r5
 8001d28:	ea6f 0c0c 	mvn.w	ip, ip
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001d2c:	f002 0803 	and.w	r8, r2, #3
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8001d30:	ea0c 0909 	and.w	r9, ip, r9
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001d34:	fa08 f805 	lsl.w	r8, r8, r5
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001d38:	3e01      	subs	r6, #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001d3a:	ea49 0808 	orr.w	r8, r9, r8
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001d3e:	2e01      	cmp	r6, #1

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
      GPIOx->MODER = temp;
 8001d40:	f8c0 8000 	str.w	r8, [r0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001d44:	d810      	bhi.n	8001d68 <HAL_GPIO_Init+0x9c>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8001d46:	6886      	ldr	r6, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8001d48:	ea0c 0806 	and.w	r8, ip, r6
        temp |= (GPIO_Init->Speed << (position * 2U));
 8001d4c:	68ce      	ldr	r6, [r1, #12]
 8001d4e:	40ae      	lsls	r6, r5
 8001d50:	ea48 0606 	orr.w	r6, r8, r6
        GPIOx->OSPEEDR = temp;
 8001d54:	6086      	str	r6, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8001d56:	6846      	ldr	r6, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8001d58:	ea26 0804 	bic.w	r8, r6, r4
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8001d5c:	f3c2 1600 	ubfx	r6, r2, #4, #1
 8001d60:	409e      	lsls	r6, r3
 8001d62:	ea48 0606 	orr.w	r6, r8, r6
        GPIOx->OTYPER = temp;
 8001d66:	6046      	str	r6, [r0, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8001d68:	68c6      	ldr	r6, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8001d6a:	ea0c 0c06 	and.w	ip, ip, r6
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8001d6e:	688e      	ldr	r6, [r1, #8]
 8001d70:	40ae      	lsls	r6, r5
 8001d72:	ea4c 0506 	orr.w	r5, ip, r6
      GPIOx->PUPDR = temp;
 8001d76:	60c5      	str	r5, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001d78:	00d5      	lsls	r5, r2, #3
 8001d7a:	d56d      	bpl.n	8001e58 <HAL_GPIO_Init+0x18c>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001d7c:	4e3a      	ldr	r6, [pc, #232]	; (8001e68 <HAL_GPIO_Init+0x19c>)
 8001d7e:	2500      	movs	r5, #0
 8001d80:	9501      	str	r5, [sp, #4]
 8001d82:	f8d6 c044 	ldr.w	ip, [r6, #68]	; 0x44
 8001d86:	f44c 4c80 	orr.w	ip, ip, #16384	; 0x4000
 8001d8a:	f8c6 c044 	str.w	ip, [r6, #68]	; 0x44
 8001d8e:	6c76      	ldr	r6, [r6, #68]	; 0x44
 8001d90:	f406 4680 	and.w	r6, r6, #16384	; 0x4000
 8001d94:	9601      	str	r6, [sp, #4]
 8001d96:	9e01      	ldr	r6, [sp, #4]
 8001d98:	f023 0603 	bic.w	r6, r3, #3
 8001d9c:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
 8001da0:	f506 369c 	add.w	r6, r6, #79872	; 0x13800

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 8001da4:	f003 0c03 	and.w	ip, r3, #3
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
 8001da8:	f8d6 9008 	ldr.w	r9, [r6, #8]
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 8001dac:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 8001db0:	f04f 080f 	mov.w	r8, #15
 8001db4:	fa08 f80c 	lsl.w	r8, r8, ip
 8001db8:	ea29 0808 	bic.w	r8, r9, r8
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8001dbc:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 8001e70 <HAL_GPIO_Init+0x1a4>
 8001dc0:	4548      	cmp	r0, r9
 8001dc2:	d019      	beq.n	8001df8 <HAL_GPIO_Init+0x12c>
 8001dc4:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 8001dc8:	f505 3501 	add.w	r5, r5, #132096	; 0x20400
 8001dcc:	42a8      	cmp	r0, r5
 8001dce:	d00e      	beq.n	8001dee <HAL_GPIO_Init+0x122>
 8001dd0:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001dd4:	42a8      	cmp	r0, r5
 8001dd6:	d00c      	beq.n	8001df2 <HAL_GPIO_Init+0x126>
 8001dd8:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001ddc:	42a8      	cmp	r0, r5
 8001dde:	d00a      	beq.n	8001df6 <HAL_GPIO_Init+0x12a>
 8001de0:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001de4:	42a8      	cmp	r0, r5
 8001de6:	bf14      	ite	ne
 8001de8:	2505      	movne	r5, #5
 8001dea:	2504      	moveq	r5, #4
 8001dec:	e004      	b.n	8001df8 <HAL_GPIO_Init+0x12c>
 8001dee:	2501      	movs	r5, #1
 8001df0:	e002      	b.n	8001df8 <HAL_GPIO_Init+0x12c>
 8001df2:	2502      	movs	r5, #2
 8001df4:	e000      	b.n	8001df8 <HAL_GPIO_Init+0x12c>
 8001df6:	2503      	movs	r5, #3
 8001df8:	fa05 f50c 	lsl.w	r5, r5, ip
 8001dfc:	ea45 0508 	orr.w	r5, r5, r8
        SYSCFG->EXTICR[position >> 2U] = temp;
 8001e00:	60b5      	str	r5, [r6, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8001e02:	4e1a      	ldr	r6, [pc, #104]	; (8001e6c <HAL_GPIO_Init+0x1a0>)
 8001e04:	f8d6 c000 	ldr.w	ip, [r6]
        temp &= ~((uint32_t)iocurrent);
 8001e08:	43e5      	mvns	r5, r4
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8001e0a:	f412 3f80 	tst.w	r2, #65536	; 0x10000
        {
          temp |= iocurrent;
 8001e0e:	bf14      	ite	ne
 8001e10:	ea44 0c0c 	orrne.w	ip, r4, ip
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
 8001e14:	ea05 0c0c 	andeq.w	ip, r5, ip
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
        }
        EXTI->IMR = temp;
 8001e18:	f8c6 c000 	str.w	ip, [r6]

        temp = EXTI->EMR;
 8001e1c:	6876      	ldr	r6, [r6, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8001e1e:	f412 3f00 	tst.w	r2, #131072	; 0x20000
        {
          temp |= iocurrent;
 8001e22:	bf14      	ite	ne
 8001e24:	ea44 0c06 	orrne.w	ip, r4, r6
          temp |= iocurrent;
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
 8001e28:	ea05 0c06 	andeq.w	ip, r5, r6
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
        }
        EXTI->EMR = temp;
 8001e2c:	4e0f      	ldr	r6, [pc, #60]	; (8001e6c <HAL_GPIO_Init+0x1a0>)
 8001e2e:	f8c6 c004 	str.w	ip, [r6, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8001e32:	f8d6 c008 	ldr.w	ip, [r6, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001e36:	f412 1f80 	tst.w	r2, #1048576	; 0x100000
        {
          temp |= iocurrent;
 8001e3a:	bf14      	ite	ne
 8001e3c:	ea44 0c0c 	orrne.w	ip, r4, ip
        }
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
 8001e40:	ea05 0c0c 	andeq.w	ip, r5, ip
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;
 8001e44:	f8c6 c008 	str.w	ip, [r6, #8]

        temp = EXTI->FTSR;
 8001e48:	68f6      	ldr	r6, [r6, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001e4a:	0292      	lsls	r2, r2, #10
        {
          temp |= iocurrent;
        }
        EXTI->FTSR = temp;
 8001e4c:	4a07      	ldr	r2, [pc, #28]	; (8001e6c <HAL_GPIO_Init+0x1a0>)
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
 8001e4e:	bf54      	ite	pl
 8001e50:	ea05 0406 	andpl.w	r4, r5, r6
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 8001e54:	4334      	orrmi	r4, r6
        }
        EXTI->FTSR = temp;
 8001e56:	60d4      	str	r4, [r2, #12]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8001e58:	3301      	adds	r3, #1
 8001e5a:	2b10      	cmp	r3, #16
 8001e5c:	f47f af3a 	bne.w	8001cd4 <HAL_GPIO_Init+0x8>
        }
        EXTI->FTSR = temp;
      }
    }
  }
}
 8001e60:	b003      	add	sp, #12
 8001e62:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8001e66:	bf00      	nop
 8001e68:	40023800 	.word	0x40023800
 8001e6c:	40013c00 	.word	0x40013c00
 8001e70:	40020000 	.word	0x40020000

08001e74 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8001e74:	b902      	cbnz	r2, 8001e78 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 8001e76:	0409      	lsls	r1, r1, #16
 8001e78:	6181      	str	r1, [r0, #24]
 8001e7a:	4770      	bx	lr

08001e7c <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001e7c:	4a07      	ldr	r2, [pc, #28]	; (8001e9c <HAL_NVIC_SetPriorityGrouping+0x20>)
 8001e7e:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001e80:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001e84:	041b      	lsls	r3, r3, #16
 8001e86:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8001e88:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8001e8c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8001e90:	f000 0007 	and.w	r0, r0, #7

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8001e94:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8001e98:	60d3      	str	r3, [r2, #12]
 8001e9a:	4770      	bx	lr
 8001e9c:	e000ed00 	.word	0xe000ed00

08001ea0 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001ea0:	4b16      	ldr	r3, [pc, #88]	; (8001efc <HAL_NVIC_SetPriority+0x5c>)
 8001ea2:	68db      	ldr	r3, [r3, #12]
 8001ea4:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8001ea8:	b570      	push	{r4, r5, r6, lr}
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001eaa:	1d1d      	adds	r5, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001eac:	f1c3 0407 	rsb	r4, r3, #7
 8001eb0:	2c04      	cmp	r4, #4
 8001eb2:	bf28      	it	cs
 8001eb4:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001eb6:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001eb8:	f04f 0501 	mov.w	r5, #1
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001ebc:	bf8c      	ite	hi
 8001ebe:	3b03      	subhi	r3, #3
 8001ec0:	2300      	movls	r3, #0

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001ec2:	fa05 f404 	lsl.w	r4, r5, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001ec6:	fa05 f603 	lsl.w	r6, r5, r3

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001eca:	3c01      	subs	r4, #1
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001ecc:	3e01      	subs	r6, #1

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001ece:	4021      	ands	r1, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001ed0:	4032      	ands	r2, r6

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001ed2:	fa01 f303 	lsl.w	r3, r1, r3
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8001ed6:	4313      	orrs	r3, r2
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 8001ed8:	2800      	cmp	r0, #0
 8001eda:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001ede:	da05      	bge.n	8001eec <HAL_NVIC_SetPriority+0x4c>
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001ee0:	b2da      	uxtb	r2, r3
 8001ee2:	f000 000f 	and.w	r0, r0, #15
 8001ee6:	4b06      	ldr	r3, [pc, #24]	; (8001f00 <HAL_NVIC_SetPriority+0x60>)
 8001ee8:	541a      	strb	r2, [r3, r0]
 8001eea:	bd70      	pop	{r4, r5, r6, pc}
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001eec:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8001ef0:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8001ef4:	b2db      	uxtb	r3, r3
 8001ef6:	f880 3300 	strb.w	r3, [r0, #768]	; 0x300
 8001efa:	bd70      	pop	{r4, r5, r6, pc}
 8001efc:	e000ed00 	.word	0xe000ed00
 8001f00:	e000ed14 	.word	0xe000ed14

08001f04 <HAL_NVIC_EnableIRQ>:
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8001f04:	0942      	lsrs	r2, r0, #5
 8001f06:	2301      	movs	r3, #1
 8001f08:	f000 001f 	and.w	r0, r0, #31
 8001f0c:	fa03 f000 	lsl.w	r0, r3, r0
 8001f10:	4b01      	ldr	r3, [pc, #4]	; (8001f18 <HAL_NVIC_EnableIRQ+0x14>)
 8001f12:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 8001f16:	4770      	bx	lr
 8001f18:	e000e100 	.word	0xe000e100

08001f1c <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8001f1c:	3801      	subs	r0, #1
 8001f1e:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8001f22:	d20a      	bcs.n	8001f3a <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8001f24:	4b06      	ldr	r3, [pc, #24]	; (8001f40 <HAL_SYSTICK_Config+0x24>)
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001f26:	4a07      	ldr	r2, [pc, #28]	; (8001f44 <HAL_SYSTICK_Config+0x28>)
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8001f28:	6058      	str	r0, [r3, #4]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001f2a:	21f0      	movs	r1, #240	; 0xf0
 8001f2c:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8001f30:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001f32:	2207      	movs	r2, #7
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8001f34:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001f36:	601a      	str	r2, [r3, #0]
 8001f38:	4770      	bx	lr
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
 8001f3a:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8001f3c:	4770      	bx	lr
 8001f3e:	bf00      	nop
 8001f40:	e000e010 	.word	0xe000e010
 8001f44:	e000ed00 	.word	0xe000ed00

08001f48 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 8001f48:	4b04      	ldr	r3, [pc, #16]	; (8001f5c <HAL_SYSTICK_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8001f4a:	681a      	ldr	r2, [r3, #0]
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8001f4c:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8001f4e:	bf0c      	ite	eq
 8001f50:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8001f54:	f022 0204 	bicne.w	r2, r2, #4
 8001f58:	601a      	str	r2, [r3, #0]
 8001f5a:	4770      	bx	lr
 8001f5c:	e000e010 	.word	0xe000e010

08001f60 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 8001f60:	4770      	bx	lr

08001f62 <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 8001f62:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 8001f64:	f7ff fffc 	bl	8001f60 <HAL_SYSTICK_Callback>
 8001f68:	bd08      	pop	{r3, pc}

08001f6a <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8001f6a:	b510      	push	{r4, lr}
 8001f6c:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000U);
 8001f6e:	f7ff fe93 	bl	8001c98 <HAL_RCC_GetHCLKFreq>
 8001f72:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8001f76:	fbb0 f0f3 	udiv	r0, r0, r3
 8001f7a:	f7ff ffcf 	bl	8001f1c <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0U);
 8001f7e:	f04f 30ff 	mov.w	r0, #4294967295
 8001f82:	4621      	mov	r1, r4
 8001f84:	2200      	movs	r2, #0
 8001f86:	f7ff ff8b 	bl	8001ea0 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 8001f8a:	2000      	movs	r0, #0
 8001f8c:	bd10      	pop	{r4, pc}
	...

08001f90 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8001f90:	b508      	push	{r3, lr}
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8001f92:	4b0b      	ldr	r3, [pc, #44]	; (8001fc0 <HAL_Init+0x30>)
 8001f94:	681a      	ldr	r2, [r3, #0]
 8001f96:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8001f9a:	601a      	str	r2, [r3, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
 8001f9c:	681a      	ldr	r2, [r3, #0]
 8001f9e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8001fa2:	601a      	str	r2, [r3, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8001fa4:	681a      	ldr	r2, [r3, #0]
 8001fa6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001faa:	601a      	str	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001fac:	2003      	movs	r0, #3
 8001fae:	f7ff ff65 	bl	8001e7c <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8001fb2:	2000      	movs	r0, #0
 8001fb4:	f7ff ffd9 	bl	8001f6a <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 8001fb8:	f000 f854 	bl	8002064 <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
}
 8001fbc:	2000      	movs	r0, #0
 8001fbe:	bd08      	pop	{r3, pc}
 8001fc0:	40023c00 	.word	0x40023c00

08001fc4 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8001fc4:	4b02      	ldr	r3, [pc, #8]	; (8001fd0 <HAL_IncTick+0xc>)
 8001fc6:	681a      	ldr	r2, [r3, #0]
 8001fc8:	3201      	adds	r2, #1
 8001fca:	601a      	str	r2, [r3, #0]
 8001fcc:	4770      	bx	lr
 8001fce:	bf00      	nop
 8001fd0:	20000050 	.word	0x20000050

08001fd4 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8001fd4:	4b01      	ldr	r3, [pc, #4]	; (8001fdc <HAL_GetTick+0x8>)
 8001fd6:	6818      	ldr	r0, [r3, #0]
}
 8001fd8:	4770      	bx	lr
 8001fda:	bf00      	nop
 8001fdc:	20000050 	.word	0x20000050

08001fe0 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 8001fe0:	b513      	push	{r0, r1, r4, lr}
 8001fe2:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = 0U;
  tickstart = HAL_GetTick();
 8001fe4:	f7ff fff6 	bl	8001fd4 <HAL_GetTick>
 8001fe8:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
 8001fea:	f7ff fff3 	bl	8001fd4 <HAL_GetTick>
 8001fee:	9b01      	ldr	r3, [sp, #4]
 8001ff0:	1b00      	subs	r0, r0, r4
 8001ff2:	4298      	cmp	r0, r3
 8001ff4:	d3f9      	bcc.n	8001fea <HAL_Delay+0xa>
  {
  }
}
 8001ff6:	b002      	add	sp, #8
 8001ff8:	bd10      	pop	{r4, pc}
	...

08001ffc <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8001ffc:	4a0f      	ldr	r2, [pc, #60]	; (800203c <SystemInit+0x40>)
 8001ffe:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8002002:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8002006:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800200a:	4b0d      	ldr	r3, [pc, #52]	; (8002040 <SystemInit+0x44>)
 800200c:	6819      	ldr	r1, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800200e:	2000      	movs	r0, #0
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8002010:	f041 0101 	orr.w	r1, r1, #1
 8002014:	6019      	str	r1, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8002016:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8002018:	6819      	ldr	r1, [r3, #0]
 800201a:	f021 7184 	bic.w	r1, r1, #17301504	; 0x1080000
 800201e:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 8002022:	6019      	str	r1, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8002024:	4907      	ldr	r1, [pc, #28]	; (8002044 <SystemInit+0x48>)
 8002026:	6059      	str	r1, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8002028:	6819      	ldr	r1, [r3, #0]
 800202a:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 800202e:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8002030:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8002032:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8002036:	6093      	str	r3, [r2, #8]
 8002038:	4770      	bx	lr
 800203a:	bf00      	nop
 800203c:	e000ed00 	.word	0xe000ed00
 8002040:	40023800 	.word	0x40023800
 8002044:	24003010 	.word	0x24003010

08002048 <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 8002048:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800204a:	f7ff ffbb 	bl	8001fc4 <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 800204e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
  HAL_SYSTICK_IRQHandler();
 8002052:	f7ff bf86 	b.w	8001f62 <HAL_SYSTICK_IRQHandler>
	...

08002058 <SDIO_IRQHandler>:
void SDIO_IRQHandler(void)
{
  /* USER CODE BEGIN SDIO_IRQn 0 */

  /* USER CODE END SDIO_IRQn 0 */
  HAL_SD_IRQHandler(&hsd);
 8002058:	4801      	ldr	r0, [pc, #4]	; (8002060 <SDIO_IRQHandler+0x8>)
 800205a:	f7fe be12 	b.w	8000c82 <HAL_SD_IRQHandler>
 800205e:	bf00      	nop
 8002060:	200002e0 	.word	0x200002e0

08002064 <HAL_MspInit>:

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8002064:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_0);
 8002066:	2007      	movs	r0, #7
 8002068:	f7ff ff08 	bl	8001e7c <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 800206c:	2100      	movs	r1, #0
 800206e:	f04f 30ff 	mov.w	r0, #4294967295
 8002072:	460a      	mov	r2, r1

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8002074:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_0);

  /* System interrupt init*/
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8002078:	f7ff bf12 	b.w	8001ea0 <HAL_NVIC_SetPriority>

0800207c <HAL_SD_MspInit>:

  /* USER CODE END MspInit 1 */
}

void HAL_SD_MspInit(SD_HandleTypeDef* hsd)
{
 800207c:	b5f0      	push	{r4, r5, r6, r7, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hsd->Instance==SDIO)
 800207e:	6802      	ldr	r2, [r0, #0]
 8002080:	4b19      	ldr	r3, [pc, #100]	; (80020e8 <HAL_SD_MspInit+0x6c>)
 8002082:	429a      	cmp	r2, r3

  /* USER CODE END MspInit 1 */
}

void HAL_SD_MspInit(SD_HandleTypeDef* hsd)
{
 8002084:	b087      	sub	sp, #28

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hsd->Instance==SDIO)
 8002086:	d12d      	bne.n	80020e4 <HAL_SD_MspInit+0x68>
  {
  /* USER CODE BEGIN SDIO_MspInit 0 */

  /* USER CODE END SDIO_MspInit 0 */
    /* Peripheral clock enable */
    __SDIO_CLK_ENABLE();
 8002088:	2400      	movs	r4, #0
 800208a:	f503 3386 	add.w	r3, r3, #68608	; 0x10c00
 800208e:	9400      	str	r4, [sp, #0]
 8002090:	6c5a      	ldr	r2, [r3, #68]	; 0x44
                          |GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8002092:	4816      	ldr	r0, [pc, #88]	; (80020ec <HAL_SD_MspInit+0x70>)
  {
  /* USER CODE BEGIN SDIO_MspInit 0 */

  /* USER CODE END SDIO_MspInit 0 */
    /* Peripheral clock enable */
    __SDIO_CLK_ENABLE();
 8002094:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8002098:	645a      	str	r2, [r3, #68]	; 0x44
 800209a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    PD2     ------> SDIO_CMD 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11 
                          |GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800209c:	9403      	str	r4, [sp, #12]
  {
  /* USER CODE BEGIN SDIO_MspInit 0 */

  /* USER CODE END SDIO_MspInit 0 */
    /* Peripheral clock enable */
    __SDIO_CLK_ENABLE();
 800209e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80020a2:	9300      	str	r3, [sp, #0]
 80020a4:	9b00      	ldr	r3, [sp, #0]
    PC12     ------> SDIO_CK
    PD2     ------> SDIO_CMD 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11 
                          |GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80020a6:	2702      	movs	r7, #2
    PC10     ------> SDIO_D2
    PC11     ------> SDIO_D3
    PC12     ------> SDIO_CK
    PD2     ------> SDIO_CMD 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11 
 80020a8:	f44f 53f8 	mov.w	r3, #7936	; 0x1f00
                          |GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 80020ac:	2603      	movs	r6, #3
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
 80020ae:	250c      	movs	r5, #12
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80020b0:	a901      	add	r1, sp, #4
    PC10     ------> SDIO_D2
    PC11     ------> SDIO_D3
    PC12     ------> SDIO_CK
    PD2     ------> SDIO_CMD 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11 
 80020b2:	9301      	str	r3, [sp, #4]
                          |GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80020b4:	9702      	str	r7, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 80020b6:	9604      	str	r6, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
 80020b8:	9505      	str	r5, [sp, #20]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80020ba:	f7ff fe07 	bl	8001ccc <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_2;
 80020be:	2304      	movs	r3, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80020c0:	eb0d 0103 	add.w	r1, sp, r3
 80020c4:	480a      	ldr	r0, [pc, #40]	; (80020f0 <HAL_SD_MspInit+0x74>)
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = GPIO_PIN_2;
 80020c6:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80020c8:	9702      	str	r7, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80020ca:	9403      	str	r4, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 80020cc:	9604      	str	r6, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
 80020ce:	9505      	str	r5, [sp, #20]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80020d0:	f7ff fdfc 	bl	8001ccc <HAL_GPIO_Init>

  /* Peripheral interrupt init*/
    HAL_NVIC_SetPriority(SDIO_IRQn, 0, 0);
 80020d4:	2031      	movs	r0, #49	; 0x31
 80020d6:	4621      	mov	r1, r4
 80020d8:	4622      	mov	r2, r4
 80020da:	f7ff fee1 	bl	8001ea0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SDIO_IRQn);
 80020de:	2031      	movs	r0, #49	; 0x31
 80020e0:	f7ff ff10 	bl	8001f04 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN SDIO_MspInit 1 */

  /* USER CODE END SDIO_MspInit 1 */
  }

}
 80020e4:	b007      	add	sp, #28
 80020e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80020e8:	40012c00 	.word	0x40012c00
 80020ec:	40020800 	.word	0x40020800
 80020f0:	40020c00 	.word	0x40020c00

080020f4 <SystemClock_Config>:
}

/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 80020f4:	b570      	push	{r4, r5, r6, lr}
 80020f6:	b094      	sub	sp, #80	; 0x50

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  __PWR_CLK_ENABLE();
 80020f8:	2400      	movs	r4, #0
 80020fa:	4b24      	ldr	r3, [pc, #144]	; (800218c <SystemClock_Config+0x98>)
 80020fc:	9401      	str	r4, [sp, #4]
 80020fe:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002100:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002104:	641a      	str	r2, [r3, #64]	; 0x40
 8002106:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002108:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800210c:	9301      	str	r3, [sp, #4]
 800210e:	9b01      	ldr	r3, [sp, #4]

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8002110:	4b1f      	ldr	r3, [pc, #124]	; (8002190 <SystemClock_Config+0x9c>)
 8002112:	9402      	str	r4, [sp, #8]
 8002114:	681a      	ldr	r2, [r3, #0]
 8002116:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 800211a:	601a      	str	r2, [r3, #0]
 800211c:	681b      	ldr	r3, [r3, #0]

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 800211e:	940f      	str	r4, [sp, #60]	; 0x3c
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  __PWR_CLK_ENABLE();

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8002120:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8002124:	9302      	str	r3, [sp, #8]
 8002126:	9b02      	ldr	r3, [sp, #8]

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8002128:	2301      	movs	r3, #1
 800212a:	930b      	str	r3, [sp, #44]	; 0x2c
  RCC_OscInitStruct.HSICalibrationValue = 16;
 800212c:	2310      	movs	r3, #16
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 192;
 800212e:	22c0      	movs	r2, #192	; 0xc0

  __PWR_CLK_ENABLE();

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8002130:	2502      	movs	r5, #2
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
 8002132:	930c      	str	r3, [sp, #48]	; 0x30
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 192;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
 8002134:	2604      	movs	r6, #4
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
 8002136:	2308      	movs	r3, #8
  RCC_OscInitStruct.PLL.PLLN = 192;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
  RCC_OscInitStruct.PLL.PLLQ = 8;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8002138:	a808      	add	r0, sp, #32
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 192;
 800213a:	9211      	str	r2, [sp, #68]	; 0x44
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
 800213c:	9310      	str	r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLN = 192;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
  RCC_OscInitStruct.PLL.PLLQ = 8;
 800213e:	9313      	str	r3, [sp, #76]	; 0x4c

  __PWR_CLK_ENABLE();

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8002140:	9508      	str	r5, [sp, #32]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8002142:	950e      	str	r5, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 192;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
 8002144:	9612      	str	r6, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLQ = 8;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8002146:	f7ff fb65 	bl	8001814 <HAL_RCC_OscConfig>

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800214a:	230f      	movs	r3, #15
 800214c:	9303      	str	r3, [sp, #12]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 800214e:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3);
 8002152:	2103      	movs	r1, #3

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8002154:	9306      	str	r3, [sp, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3);
 8002156:	a803      	add	r0, sp, #12
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8002158:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800215c:	9307      	str	r3, [sp, #28]
  RCC_OscInitStruct.PLL.PLLQ = 8;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800215e:	9504      	str	r5, [sp, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8002160:	9405      	str	r4, [sp, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3);
 8002162:	f7ff fcb1 	bl	8001ac8 <HAL_RCC_ClockConfig>

  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8002166:	f7ff fd97 	bl	8001c98 <HAL_RCC_GetHCLKFreq>
 800216a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800216e:	fbb0 f0f3 	udiv	r0, r0, r3
 8002172:	f7ff fed3 	bl	8001f1c <HAL_SYSTICK_Config>

  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 8002176:	4630      	mov	r0, r6
 8002178:	f7ff fee6 	bl	8001f48 <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 800217c:	f04f 30ff 	mov.w	r0, #4294967295
 8002180:	4621      	mov	r1, r4
 8002182:	4622      	mov	r2, r4
 8002184:	f7ff fe8c 	bl	8001ea0 <HAL_NVIC_SetPriority>
}
 8002188:	b014      	add	sp, #80	; 0x50
 800218a:	bd70      	pop	{r4, r5, r6, pc}
 800218c:	40023800 	.word	0x40023800
 8002190:	40007000 	.word	0x40007000

08002194 <main>:
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

int main(void)
{
 8002194:	b500      	push	{lr}
 8002196:	b089      	sub	sp, #36	; 0x24
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOD_CLK_ENABLE();
 8002198:	2400      	movs	r4, #0
  /* USER CODE END 1 */

  /* MCU Configuration----------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 800219a:	f7ff fef9 	bl	8001f90 <HAL_Init>

  /* Configure the system clock */
  SystemClock_Config();
 800219e:	f7ff ffa9 	bl	80020f4 <SystemClock_Config>
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOD_CLK_ENABLE();
 80021a2:	4b1a      	ldr	r3, [pc, #104]	; (800220c <main+0x78>)
 80021a4:	9401      	str	r4, [sp, #4]
 80021a6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  __GPIOC_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, Led_Green_Pin|Led_Orange_Pin|Led_Red_Pin|Led_Blue_Pin, GPIO_PIN_RESET);
 80021a8:	4819      	ldr	r0, [pc, #100]	; (8002210 <main+0x7c>)
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOD_CLK_ENABLE();
 80021aa:	f042 0208 	orr.w	r2, r2, #8
 80021ae:	631a      	str	r2, [r3, #48]	; 0x30
 80021b0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80021b2:	f002 0208 	and.w	r2, r2, #8
 80021b6:	9201      	str	r2, [sp, #4]
 80021b8:	9a01      	ldr	r2, [sp, #4]
  __GPIOC_CLK_ENABLE();
 80021ba:	9402      	str	r4, [sp, #8]
 80021bc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80021be:	f042 0204 	orr.w	r2, r2, #4
 80021c2:	631a      	str	r2, [r3, #48]	; 0x30
 80021c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80021c6:	f003 0304 	and.w	r3, r3, #4

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, Led_Green_Pin|Led_Orange_Pin|Led_Red_Pin|Led_Blue_Pin, GPIO_PIN_RESET);
 80021ca:	4622      	mov	r2, r4

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOD_CLK_ENABLE();
  __GPIOC_CLK_ENABLE();
 80021cc:	9302      	str	r3, [sp, #8]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, Led_Green_Pin|Led_Orange_Pin|Led_Red_Pin|Led_Blue_Pin, GPIO_PIN_RESET);
 80021ce:	f44f 4170 	mov.w	r1, #61440	; 0xf000

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOD_CLK_ENABLE();
  __GPIOC_CLK_ENABLE();
 80021d2:	9b02      	ldr	r3, [sp, #8]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, Led_Green_Pin|Led_Orange_Pin|Led_Red_Pin|Led_Blue_Pin, GPIO_PIN_RESET);
 80021d4:	f7ff fe4e 	bl	8001e74 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : Led_Green_Pin Led_Orange_Pin Led_Red_Pin Led_Blue_Pin */
  GPIO_InitStruct.Pin = Led_Green_Pin|Led_Orange_Pin|Led_Red_Pin|Led_Blue_Pin;
 80021d8:	f44f 4370 	mov.w	r3, #61440	; 0xf000
 80021dc:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80021de:	480c      	ldr	r0, [pc, #48]	; (8002210 <main+0x7c>)
  HAL_GPIO_WritePin(GPIOD, Led_Green_Pin|Led_Orange_Pin|Led_Red_Pin|Led_Blue_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pins : Led_Green_Pin Led_Orange_Pin Led_Red_Pin Led_Blue_Pin */
  GPIO_InitStruct.Pin = Led_Green_Pin|Led_Orange_Pin|Led_Red_Pin|Led_Blue_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80021e0:	9405      	str	r4, [sp, #20]
  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, Led_Green_Pin|Led_Orange_Pin|Led_Red_Pin|Led_Blue_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pins : Led_Green_Pin Led_Orange_Pin Led_Red_Pin Led_Blue_Pin */
  GPIO_InitStruct.Pin = Led_Green_Pin|Led_Orange_Pin|Led_Red_Pin|Led_Blue_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80021e2:	2301      	movs	r3, #1
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80021e4:	a903      	add	r1, sp, #12
  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, Led_Green_Pin|Led_Orange_Pin|Led_Red_Pin|Led_Blue_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pins : Led_Green_Pin Led_Orange_Pin Led_Red_Pin Led_Blue_Pin */
  GPIO_InitStruct.Pin = Led_Green_Pin|Led_Orange_Pin|Led_Red_Pin|Led_Blue_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80021e6:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 80021e8:	9406      	str	r4, [sp, #24]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80021ea:	f7ff fd6f 	bl	8001ccc <HAL_GPIO_Init>

/* SDIO init function */
void MX_SDIO_SD_Init(void)
{

  hsd.Instance = SDIO;
 80021ee:	4b09      	ldr	r3, [pc, #36]	; (8002214 <main+0x80>)
 80021f0:	4a09      	ldr	r2, [pc, #36]	; (8002218 <main+0x84>)
  hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING;
  hsd.Init.ClockBypass = SDIO_CLOCK_BYPASS_DISABLE;
 80021f2:	609c      	str	r4, [r3, #8]
/* SDIO init function */
void MX_SDIO_SD_Init(void)
{

  hsd.Instance = SDIO;
  hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING;
 80021f4:	e883 0014 	stmia.w	r3, {r2, r4}
  hsd.Init.ClockBypass = SDIO_CLOCK_BYPASS_DISABLE;
  hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE;
  hsd.Init.BusWide = SDIO_BUS_WIDE_4B;
 80021f8:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80021fc:	611a      	str	r2, [r3, #16]
  hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
  hsd.Init.ClockDiv = 255;
 80021fe:	22ff      	movs	r2, #255	; 0xff
{

  hsd.Instance = SDIO;
  hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING;
  hsd.Init.ClockBypass = SDIO_CLOCK_BYPASS_DISABLE;
  hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE;
 8002200:	60dc      	str	r4, [r3, #12]
  hsd.Init.BusWide = SDIO_BUS_WIDE_4B;
  hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
 8002202:	615c      	str	r4, [r3, #20]
  hsd.Init.ClockDiv = 255;
 8002204:	619a      	str	r2, [r3, #24]
  SystemClock_Config();

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_SDIO_SD_Init();
  MX_FATFS_Init();
 8002206:	f000 f809 	bl	800221c <MX_FATFS_Init>
 800220a:	e7fe      	b.n	800220a <main+0x76>
 800220c:	40023800 	.word	0x40023800
 8002210:	40020c00 	.word	0x40020c00
 8002214:	200002e0 	.word	0x200002e0
 8002218:	40012c00 	.word	0x40012c00

0800221c <MX_FATFS_Init>:
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */    

void MX_FATFS_Init(void) 
{
 800221c:	b508      	push	{r3, lr}
  /*## FatFS: Link the SD driver ###########################*/
  retSD = FATFS_LinkDriver(&SD_Driver, SD_Path);
 800221e:	490a      	ldr	r1, [pc, #40]	; (8002248 <MX_FATFS_Init+0x2c>)
 8002220:	480a      	ldr	r0, [pc, #40]	; (800224c <MX_FATFS_Init+0x30>)
 8002222:	f7fe f863 	bl	80002ec <FATFS_LinkDriver>
 8002226:	4b0a      	ldr	r3, [pc, #40]	; (8002250 <MX_FATFS_Init+0x34>)

  /* USER CODE BEGIN Init */

  uint8_t result;

  result = f_mount(&SDFatFs, (TCHAR const*)SD_Path, 1);
 8002228:	4907      	ldr	r1, [pc, #28]	; (8002248 <MX_FATFS_Init+0x2c>)
/* USER CODE END Variables */    

void MX_FATFS_Init(void) 
{
  /*## FatFS: Link the SD driver ###########################*/
  retSD = FATFS_LinkDriver(&SD_Driver, SD_Path);
 800222a:	7018      	strb	r0, [r3, #0]

  /* USER CODE BEGIN Init */

  uint8_t result;

  result = f_mount(&SDFatFs, (TCHAR const*)SD_Path, 1);
 800222c:	2201      	movs	r2, #1
 800222e:	4809      	ldr	r0, [pc, #36]	; (8002254 <MX_FATFS_Init+0x38>)
 8002230:	f7fe faa4 	bl	800077c <f_mount>

  if(result != 0)
 8002234:	b138      	cbz	r0, 8002246 <MX_FATFS_Init+0x2a>
  {
	  HAL_GPIO_WritePin(GPIOD,Led_Red_Pin,GPIO_PIN_SET);
 8002236:	4808      	ldr	r0, [pc, #32]	; (8002258 <MX_FATFS_Init+0x3c>)
 8002238:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 800223c:	2201      	movs	r2, #1
  }

  /* additional user code for init */     
  /* USER CODE END Init */
}
 800223e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  result = f_mount(&SDFatFs, (TCHAR const*)SD_Path, 1);

  if(result != 0)
  {
	  HAL_GPIO_WritePin(GPIOD,Led_Red_Pin,GPIO_PIN_SET);
 8002242:	f7ff be17 	b.w	8001e74 <HAL_GPIO_WritePin>
 8002246:	bd08      	pop	{r3, pc}
 8002248:	20000341 	.word	0x20000341
 800224c:	080023ac 	.word	0x080023ac
 8002250:	20000340 	.word	0x20000340
 8002254:	200000b0 	.word	0x200000b0
 8002258:	40020c00 	.word	0x40020c00

0800225c <BSP_SD_Init>:
  * @brief  Initializes the SD card device.
  * @param  None
  * @retval SD status
  */
uint8_t BSP_SD_Init(void)
{
 800225c:	b507      	push	{r0, r1, r2, lr}
 * @param  None
 * @retval Returns if SD is detected or not
 */
uint8_t BSP_SD_IsDetected(void)
{
  __IO uint8_t status = SD_PRESENT;
 800225e:	2001      	movs	r0, #1
 8002260:	f88d 0007 	strb.w	r0, [sp, #7]

  /* USER CODE BEGIN 1 */
  /* user code can be inserted here */
  /* USER CODE END 1 */    
  
  return status;
 8002264:	f89d 3007 	ldrb.w	r3, [sp, #7]
  */
uint8_t BSP_SD_Init(void)
{
  uint8_t SD_state = MSD_OK;
  /* Check if the SD card is plugged in the slot */
  if (BSP_SD_IsDetected() != SD_PRESENT)
 8002268:	4283      	cmp	r3, r0
 800226a:	d10c      	bne.n	8002286 <BSP_SD_Init+0x2a>
  {
    return MSD_ERROR;
  }
  SD_state = HAL_SD_Init(&hsd, &SDCardInfo);
 800226c:	4807      	ldr	r0, [pc, #28]	; (800228c <BSP_SD_Init+0x30>)
 800226e:	4908      	ldr	r1, [pc, #32]	; (8002290 <BSP_SD_Init+0x34>)
 8002270:	f7fe fe8a 	bl	8000f88 <HAL_SD_Init>
#ifdef BUS_4BITS
  if (SD_state == MSD_OK)
 8002274:	b938      	cbnz	r0, 8002286 <BSP_SD_Init+0x2a>
  {
    if (HAL_SD_WideBusOperation_Config(&hsd, SDIO_BUS_WIDE_4B) != SD_OK)
 8002276:	4805      	ldr	r0, [pc, #20]	; (800228c <BSP_SD_Init+0x30>)
 8002278:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800227c:	f7ff f84e 	bl	800131c <HAL_SD_WideBusOperation_Config>
{
  uint8_t SD_state = MSD_OK;
  /* Check if the SD card is plugged in the slot */
  if (BSP_SD_IsDetected() != SD_PRESENT)
  {
    return MSD_ERROR;
 8002280:	3000      	adds	r0, #0
 8002282:	bf18      	it	ne
 8002284:	2001      	movne	r0, #1
      SD_state = MSD_OK;
    }
  }
#endif
  return SD_state;
}
 8002286:	b003      	add	sp, #12
 8002288:	f85d fb04 	ldr.w	pc, [sp], #4
 800228c:	200002e0 	.word	0x200002e0
 8002290:	20000058 	.word	0x20000058

08002294 <BSP_SD_ReadBlocks>:
  * @param  BlockSize: SD card data block size, that should be 512
  * @param  NumOfBlocks: Number of SD blocks to read 
  * @retval SD status
  */
uint8_t BSP_SD_ReadBlocks(uint32_t *pData, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumOfBlocks)
{
 8002294:	b513      	push	{r0, r1, r4, lr}
  if(HAL_SD_ReadBlocks(&hsd, pData, ReadAddr, BlockSize, NumOfBlocks) != SD_OK)  
 8002296:	9c04      	ldr	r4, [sp, #16]
 8002298:	9400      	str	r4, [sp, #0]
 800229a:	9c05      	ldr	r4, [sp, #20]
 800229c:	9401      	str	r4, [sp, #4]
  * @param  BlockSize: SD card data block size, that should be 512
  * @param  NumOfBlocks: Number of SD blocks to read 
  * @retval SD status
  */
uint8_t BSP_SD_ReadBlocks(uint32_t *pData, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumOfBlocks)
{
 800229e:	4601      	mov	r1, r0
  if(HAL_SD_ReadBlocks(&hsd, pData, ReadAddr, BlockSize, NumOfBlocks) != SD_OK)  
 80022a0:	4803      	ldr	r0, [pc, #12]	; (80022b0 <BSP_SD_ReadBlocks+0x1c>)
 80022a2:	f7ff f8e8 	bl	8001476 <HAL_SD_ReadBlocks>
  }
  else
  {
    return MSD_OK;
  }
}
 80022a6:	3000      	adds	r0, #0
 80022a8:	bf18      	it	ne
 80022aa:	2001      	movne	r0, #1
 80022ac:	b002      	add	sp, #8
 80022ae:	bd10      	pop	{r4, pc}
 80022b0:	200002e0 	.word	0x200002e0

080022b4 <BSP_SD_WriteBlocks>:
  * @param  BlockSize: SD card data block size, that should be 512
  * @param  NumOfBlocks: Number of SD blocks to write
  * @retval SD status
  */
uint8_t BSP_SD_WriteBlocks(uint32_t *pData, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumOfBlocks)
{
 80022b4:	b513      	push	{r0, r1, r4, lr}
  if(HAL_SD_WriteBlocks(&hsd, pData, WriteAddr, BlockSize, NumOfBlocks) != SD_OK)  
 80022b6:	9c04      	ldr	r4, [sp, #16]
 80022b8:	9400      	str	r4, [sp, #0]
 80022ba:	9c05      	ldr	r4, [sp, #20]
 80022bc:	9401      	str	r4, [sp, #4]
  * @param  BlockSize: SD card data block size, that should be 512
  * @param  NumOfBlocks: Number of SD blocks to write
  * @retval SD status
  */
uint8_t BSP_SD_WriteBlocks(uint32_t *pData, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumOfBlocks)
{
 80022be:	4601      	mov	r1, r0
  if(HAL_SD_WriteBlocks(&hsd, pData, WriteAddr, BlockSize, NumOfBlocks) != SD_OK)  
 80022c0:	4803      	ldr	r0, [pc, #12]	; (80022d0 <BSP_SD_WriteBlocks+0x1c>)
 80022c2:	f7ff f993 	bl	80015ec <HAL_SD_WriteBlocks>
  }
  else
  {
    return MSD_OK;
  }
}
 80022c6:	3000      	adds	r0, #0
 80022c8:	bf18      	it	ne
 80022ca:	2001      	movne	r0, #1
 80022cc:	b002      	add	sp, #8
 80022ce:	bd10      	pop	{r4, pc}
 80022d0:	200002e0 	.word	0x200002e0

080022d4 <BSP_SD_GetStatus>:
  *            @arg  SD_TRANSFER_BUSY: Data transfer is acting
  *            @arg  SD_TRANSFER_ERROR: Data transfer error 
  */
HAL_SD_TransferStateTypedef BSP_SD_GetStatus(void)
{
  return(HAL_SD_GetStatus(&hsd));
 80022d4:	4801      	ldr	r0, [pc, #4]	; (80022dc <BSP_SD_GetStatus+0x8>)
 80022d6:	f7ff ba79 	b.w	80017cc <HAL_SD_GetStatus>
 80022da:	bf00      	nop
 80022dc:	200002e0 	.word	0x200002e0

080022e0 <BSP_SD_GetCardInfo>:
  * @brief  Get SD information about specific SD card.
  * @param  CardInfo: Pointer to HAL_SD_CardInfoTypedef structure
  * @retval None 
  */
void BSP_SD_GetCardInfo(HAL_SD_CardInfoTypedef* CardInfo)
{
 80022e0:	4601      	mov	r1, r0
  /* Get SD card Information */
  HAL_SD_Get_CardInfo(&hsd, CardInfo);
 80022e2:	4801      	ldr	r0, [pc, #4]	; (80022e8 <BSP_SD_GetCardInfo+0x8>)
 80022e4:	f7fe bd0b 	b.w	8000cfe <HAL_SD_Get_CardInfo>
 80022e8:	200002e0 	.word	0x200002e0

080022ec <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    		 /* set stack pointer */
 80022ec:	f8df d03c 	ldr.w	sp, [pc, #60]	; 800232c <LoopFillZerobss+0x16>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 80022f0:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 80022f2:	f000 b804 	b.w	80022fe <LoopCopyDataInit>

080022f6 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 80022f6:	4b0e      	ldr	r3, [pc, #56]	; (8002330 <LoopFillZerobss+0x1a>)
  ldr  r3, [r3, r1]
 80022f8:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 80022fa:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 80022fc:	3104      	adds	r1, #4

080022fe <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 80022fe:	480d      	ldr	r0, [pc, #52]	; (8002334 <LoopFillZerobss+0x1e>)
  ldr  r3, =_edata
 8002300:	4b0d      	ldr	r3, [pc, #52]	; (8002338 <LoopFillZerobss+0x22>)
  adds  r2, r0, r1
 8002302:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8002304:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8002306:	f4ff aff6 	bcc.w	80022f6 <CopyDataInit>
  ldr  r2, =_sbss
 800230a:	4a0c      	ldr	r2, [pc, #48]	; (800233c <LoopFillZerobss+0x26>)
  b  LoopFillZerobss
 800230c:	f000 b803 	b.w	8002316 <LoopFillZerobss>

08002310 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8002310:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8002312:	f842 3b04 	str.w	r3, [r2], #4

08002316 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8002316:	4b0a      	ldr	r3, [pc, #40]	; (8002340 <LoopFillZerobss+0x2a>)
  cmp  r2, r3
 8002318:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800231a:	f4ff aff9 	bcc.w	8002310 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 800231e:	f7ff fe6d 	bl	8001ffc <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8002322:	f000 f811 	bl	8002348 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8002326:	f7ff ff35 	bl	8002194 <main>
  bx  lr    
 800232a:	4770      	bx	lr

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    		 /* set stack pointer */
 800232c:	20020000 	.word	0x20020000
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 8002330:	080023d8 	.word	0x080023d8
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8002334:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8002338:	20000008 	.word	0x20000008
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 800233c:	20000008 	.word	0x20000008
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8002340:	20000348 	.word	0x20000348

08002344 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8002344:	f7ff bffe 	b.w	8002344 <ADC_IRQHandler>

08002348 <__libc_init_array>:
 8002348:	b570      	push	{r4, r5, r6, lr}
 800234a:	4b0e      	ldr	r3, [pc, #56]	; (8002384 <__libc_init_array+0x3c>)
 800234c:	4d0e      	ldr	r5, [pc, #56]	; (8002388 <__libc_init_array+0x40>)
 800234e:	1aed      	subs	r5, r5, r3
 8002350:	10ad      	asrs	r5, r5, #2
 8002352:	2400      	movs	r4, #0
 8002354:	461e      	mov	r6, r3
 8002356:	42ac      	cmp	r4, r5
 8002358:	d004      	beq.n	8002364 <__libc_init_array+0x1c>
 800235a:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
 800235e:	4790      	blx	r2
 8002360:	3401      	adds	r4, #1
 8002362:	e7f8      	b.n	8002356 <__libc_init_array+0xe>
 8002364:	f000 f816 	bl	8002394 <_init>
 8002368:	4d08      	ldr	r5, [pc, #32]	; (800238c <__libc_init_array+0x44>)
 800236a:	4b09      	ldr	r3, [pc, #36]	; (8002390 <__libc_init_array+0x48>)
 800236c:	1aed      	subs	r5, r5, r3
 800236e:	10ad      	asrs	r5, r5, #2
 8002370:	2400      	movs	r4, #0
 8002372:	461e      	mov	r6, r3
 8002374:	42ac      	cmp	r4, r5
 8002376:	d004      	beq.n	8002382 <__libc_init_array+0x3a>
 8002378:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
 800237c:	4790      	blx	r2
 800237e:	3401      	adds	r4, #1
 8002380:	e7f8      	b.n	8002374 <__libc_init_array+0x2c>
 8002382:	bd70      	pop	{r4, r5, r6, pc}
 8002384:	080023d0 	.word	0x080023d0
 8002388:	080023d0 	.word	0x080023d0
 800238c:	080023d4 	.word	0x080023d4
 8002390:	080023d0 	.word	0x080023d0

08002394 <_init>:
 8002394:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002396:	bf00      	nop
 8002398:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800239a:	bc08      	pop	{r3}
 800239c:	469e      	mov	lr, r3
 800239e:	4770      	bx	lr

080023a0 <_fini>:
 80023a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80023a2:	bf00      	nop
 80023a4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80023a6:	bc08      	pop	{r3}
 80023a8:	469e      	mov	lr, r3
 80023aa:	4770      	bx	lr
